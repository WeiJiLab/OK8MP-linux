<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">pylon C++ Programmer&#39;s Guide for Linux</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Programmer's Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="pylon_programmingguide.html#hi_hints">Getting Started</a> </li>
<li><a class="el" href="pylon_programmingguide.html#buildingapplications_brief">Common Settings for Building Applications with pylon</a> </li>
<li><a class="el" href="pylon_programmingguide.html#debugging_brief">Debugging pylon Applications Using GigE Cameras</a> </li>
<li><a class="el" href="pylon_programmingguide.html#initterminate">Initialization/Uninitialization of the pylon Runtime Library</a> </li>
<li><a class="el" href="pylon_programmingguide.html#errorhandling">Error Handling</a> </li>
<li><a class="el" href="pylon_programmingguide.html#enumerating_and_creating_brief">Creating a pylon Device</a> </li>
<li><a class="el" href="pylon_programmingguide.html#hi_instantcameras">The Instant Camera Classes</a> </li>
<li><a class="el" href="pylon_programmingguide.html#configuringcameras">Accessing Parameters</a> </li>
<li><a class="el" href="pylon_programmingguide.html#hi_grabbingimages">Grabbing Images</a> </li>
<li><a class="el" href="pylon_programmingguide.html#hi_advanced_features">Using Advanced Camera Features</a> </li>
<li><a class="el" href="pylon_programmingguide.html#hi_image_handling">Image Handling</a></li>
</ul>
<h1><a class="anchor" id="hi_hints"></a>
Getting Started</h1>
<p>The pylon Programmer's Guide is a quick guide on how to program using the Basler pylon C++ API. It can be used together with the <a class="el" href="sample_code.html">pylon sample code</a> for getting started. Additionally, the <a href="modules.html" class="el">API reference</a> provides documentation about the Basler pylon C++ interface. The documentation of the interfaces is also available in the header files of pylon.</p>
<h1><a class="anchor" id="buildingapplications_brief"></a>
Common Settings for Building Applications with pylon</h1>
<p>This section shows the most common Linux build settings for building an application using pylon and the GNU tool chain. Consult the <a class="el" href="pylon_advanced_topics.html#buildingapplications">Advanced Topics</a> section for more information.</p>
<p>To collect all the required parameters to build a pylon-based application, we created the <code>pylon-config</code> utility. It works like <code>pkg-config</code> and you can call <code>pylon-config &amp;ndash;help</code> to get a list of supported parameters.</p>
<p>In a typical GNU Make-based project you can add the following lines to your Makefile: </p><div class="fragment"><div class="line">PYLON_ROOT ?= /opt/pylon6</div><div class="line">CPPFLAGS   += $(shell $(PYLON_ROOT)/bin/pylon-config --cflags)</div><div class="line">LDFLAGS    += $(shell $(PYLON_ROOT)/bin/pylon-config --libs-rpath)</div><div class="line">LDLIBS     += $(shell $(PYLON_ROOT)/bin/pylon-config --libs)</div></div><!-- fragment --><p>If needed, you can now overwrite the default installation path using the environment variable &lt;PYLON_ROOT&gt;. E.g.: </p><div class="fragment"><div class="line">PYLON_ROOT=/path/to/your/pylon/install make</div></div><!-- fragment --><h1><a class="anchor" id="debugging_brief"></a>
Debugging pylon Applications Using GigE Cameras</h1>
<p>When debugging a pylon application using GigE cameras you may encounter heartbeat timeouts. The application must send special network packets to the camera in defined intervals. If the camera doesn't receive these heartbeats it will consider the connection as broken and won't accept any commands from the application. This requires setting the heartbeat timeout of a camera to a higher value when debugging. The <a class="el" href="pylon_advanced_topics.html#debugging">Advanced Topics</a> section shows how to do this.</p>
<h1><a class="anchor" id="initterminate"></a>
Initialization/Uninitialization of the pylon Runtime Library</h1>
<p>The pylon runtime system must be initialized before use. A pylon-based application must call the <code><a class="el" href="namespace_pylon.html#af8226766d27eea5b88d21e56889719ce" title="Initializes the pylon runtime system. ">PylonInitialize()</a></code> method before using any other functions of the pylon runtime system. Before an application exits, it must call the <code><a class="el" href="namespace_pylon.html#abc016fa068af2d088de26dd899a1f544" title="Frees up resources allocated by the pylon runtime system. ">PylonTerminate()</a></code> method to free resources allocated by the pylon runtime system.</p>
<p>The <code><a class="el" href="class_pylon_1_1_pylon_auto_init_term.html" title="Helper class to automagically call PylonInitialize and PylonTerminate in constructor and destructor...">Pylon::PylonAutoInitTerm</a></code> convenience class helps to do the above. The constructor of <code>PylonAutoInitTerm</code> calls <code><a class="el" href="namespace_pylon.html#af8226766d27eea5b88d21e56889719ce" title="Initializes the pylon runtime system. ">PylonInitialize()</a></code>, the destructor calls <code><a class="el" href="namespace_pylon.html#abc016fa068af2d088de26dd899a1f544" title="Frees up resources allocated by the pylon runtime system. ">PylonTerminate()</a></code>. This ensures that the pylon runtime system is initialized during the lifetime of an object of the <code>PylonAutoInitTerm</code> type.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_pylon_includes_8h.html">pylon/PylonIncludes.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_pylon.html">Pylon</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line"></div><div class="line">  <a class="code" href="class_pylon_1_1_pylon_auto_init_term.html">Pylon::PylonAutoInitTerm</a> autoInitTerm;  <span class="comment">// PylonInitialize() will be called now</span></div><div class="line"></div><div class="line">  <span class="comment">// Use pylon</span></div><div class="line">  <span class="comment">// ..</span></div><div class="line"></div><div class="line">}  <span class="comment">// autoInitTerm&#39;s destructor calls PylonTerminate() now</span></div></div><!-- fragment --><h1><a class="anchor" id="errorhandling"></a>
Error Handling</h1>
<p>In the case of errors, the methods of pylon classes may throw C++ exceptions. The pylon C++ API throws exceptions of type <code>GenericException</code> or that are subclasses of GenericException. You should guard pylon calls with exception handlers catching <code>GenericException</code>. Example: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line">  camera.Width.SetValue( 640 );</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> GenericException &amp; e)</div><div class="line">{</div><div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Failed to set the AOI width. Reason: &quot;</span></div><div class="line">  &lt;&lt; e.GetDescription() &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="enumerating_and_creating_brief"></a>
Creating a pylon Device</h1>
<p>In pylon, physical camera devices are represented by <a class="el" href="struct_pylon_1_1_i_pylon_device.html">pylon Devices</a>. The following example shows how to create a pylon Device:</p>
<div class="fragment"><div class="line">IPylonDevice* pDevice = CTlFactory::GetInstance().CreateFirstDevice();</div></div><!-- fragment --><p>The first found camera device is created, e.g. for a vision system that uses only one camera. The <a class="el" href="pylon_advanced_topics.html#enumerating_and_creating">Advanced Topics</a> section shows how to handle multiple camera devices and how to find specific camera devices.</p>
<h1><a class="anchor" id="hi_instantcameras"></a>
The Instant Camera Classes</h1>
<p>Instant Camera classes make it possible to grab images with a few lines of code reducing the programming effort to a minimum. An Instant Camera class uses a pylon Device internally. The pylon Device needs to be created and attached to the Instant Camera object for operation.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Create an instant camera object with the camera device found first.</span></div><div class="line">CInstantCamera camera( CTlFactory::GetInstance().CreateFirstDevice());</div><div class="line"></div><div class="line"><span class="comment">// Print the model name of the camera.</span></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Using device &quot;</span> &lt;&lt; camera.GetDeviceInfo().GetModelName() &lt;&lt; endl;</div><div class="line"></div><div class="line"><span class="comment">// Start the grabbing of c_countOfImagesToGrab images.</span></div><div class="line"><span class="comment">// The camera device is parameterized with a default configuration which</span></div><div class="line"><span class="comment">// sets up free-running continuous acquisition.</span></div><div class="line">camera.StartGrabbing( c_countOfImagesToGrab);</div><div class="line"></div><div class="line"><span class="comment">// This smart pointer will receive the grab result data.</span></div><div class="line">CGrabResultPtr ptrGrabResult;</div><div class="line"></div><div class="line"><span class="comment">// Camera.StopGrabbing() is called automatically by the RetrieveResult() method</span></div><div class="line"><span class="comment">// when c_countOfImagesToGrab images have been retrieved.</span></div><div class="line"><span class="keywordflow">while</span> ( camera.IsGrabbing())</div><div class="line">{</div><div class="line">    <span class="comment">// Wait for an image and then retrieve it. A timeout of 5000 ms is used.</span></div><div class="line">    camera.RetrieveResult( 5000, ptrGrabResult, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Image grabbed successfully?</span></div><div class="line">    <span class="keywordflow">if</span> (ptrGrabResult-&gt;GrabSucceeded())</div><div class="line">    {</div><div class="line">        <span class="comment">// Access the image data.</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;SizeX: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetWidth() &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;SizeY: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetHeight() &lt;&lt; endl;</div><div class="line">        <span class="keyword">const</span> uint8_t *pImageBuffer = (uint8_t *) ptrGrabResult-&gt;GetBuffer();</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Gray value of first pixel: &quot;</span> &lt;&lt; (uint32_t) pImageBuffer[0] &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorCode() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorDescription() &lt;&lt; endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The above code snippet can be found in the code sample <a class="el" href="sample_code.html#sample_Grab">Grab</a>.</p>
<h2><a class="anchor" id="hi_mainfeatures_instantcameras"></a>
The Main Features of an Instant Camera Class</h2>
<p>The Instant Camera classes establish convenient access to a camera device while being highly customizable. The following list shows the main features of an Instant Camera class:</p>
<ul>
<li>It serves as single access point for accessing camera functionality. </li>
<li>It can be used "out of the shelf" without setting any parameters. The camera uses a default configuration for the device. The default configuration can be overridden. </li>
<li>It handles pylon Device lifetime. </li>
<li>It opens and closes a pylon Device automatically. </li>
<li>It handles the creation, reuse and destruction of buffers. </li>
<li>It provides a grab loop thread if required. </li>
<li>It detects camera device removal. </li>
<li>It supports advanced camera features like chunk mode and event reporting (camera events). </li>
<li>Is extensible using derivation. </li>
<li>Is extensible by registering additional event handler objects.</li>
</ul>
<h2><a class="anchor" id="hi_typesof_instantcameras"></a>
Types of Instant Camera Classes</h2>
<p>Before starting to program you need to decide what Instant Camera class to use. The following table shows the available Instant Camera classes:</p>
<table  border="1" class="table" frame="void" cellspacing="6" cellpadding="7">
<tr>
<th>Name of Class </th><th>Usable for Device Type </th><th>Device-specific  </th></tr>
<tr>
<td><code><a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">Pylon::CInstantCamera</a></code> (recommended) </td><td>All cameras </td><td>No   </td></tr>
<tr>
<td><code><a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">Pylon::CBaslerUniversalInstantCamera</a></code> (recommended for novice users) </td><td>All cameras </td><td>No  </td></tr>
</table>
<p>The <a class="el" href="class_pylon_1_1_c_instant_camera.html"><code>CInstantCamera</code> </a> and the <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html"><code>CBaslerUniversalInstantCamera</code> </a> camera classes allow you to operate camera devices of all types.</p>
<p>The <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html"><code>CBaslerUniversalInstantCamera</code> </a> class is a specialization of the <a class="el" href="class_pylon_1_1_c_instant_camera.html"><code>CInstantCamera</code> </a> class, extending it by a parameter class. The parameter class provides a member for each camera parameter. The additional parameter class provides IDE auto completion (e.g., IntelliSense in Visual Studio) and is helpful when developing an application. It adds a small but neglectable runtime overhead.</p>
<h2><a class="anchor" id="hi_eventhandler_instantcameras"></a>
Instant Camera Event Handler Basics</h2>
<p>The Instant Camera classes allow to register event handler objects for customizing the behavior of the camera object, for processing grab results, and for handling camera events. The following list shows the available event handler types.</p>
<ul>
<li>Configuration event handler - can be used for customizing the behavior of the camera; must be derived from the <code><a class="el" href="class_pylon_1_1_c_configuration_event_handler.html" title="The configuration event handler base class. ">Pylon::CConfigurationEventHandler</a></code> base class. </li>
<li>Image event handler - can be used for processing the grab results; must be derived from the <code><a class="el" href="class_pylon_1_1_c_image_event_handler.html" title="The image event handler base class. ">Pylon::CImageEventHandler</a></code> base class. </li>
<li>Camera event handler - must be used for processing camera events; must be derived from the <code><a class="el" href="class_pylon_1_1_c_camera_event_handler.html" title="The camera event handler base class. ">Pylon::CCameraEventHandler</a></code> base class.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For the <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html"><code>CBaslerUniversalInstantCamera</code> </a> class, separate event handler base classes are available. These classes use the <code>CBaslerUniversalInstantCamera</code> class and the corresponding grab result smart pointer class.</dd></dl>
<p>A custom event handler class can override one or more virtual methods of the base class. For instance whenever <code><a class="el" href="class_pylon_1_1_c_configuration_event_handler.html#ae1824c64953412d5fecb1456a6396113" title="This method is called after the attached Pylon Device has been opened. ">Pylon::CConfigurationEventHandler::OnOpened</a></code> is called by an Instant Camera object it is the right time to set up camera parameters. The following code snippet shows an example of a configuration event handler setting the image area of interest (Image AOI) and the pixel format.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CPixelFormatAndAoiConfiguration : <span class="keyword">public</span> <a class="code" href="class_pylon_1_1_c_configuration_event_handler.html">Pylon::CConfigurationEventHandler</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_pylon_1_1_c_configuration_event_handler.html#ae1824c64953412d5fecb1456a6396113">OnOpened</a>( <a class="code" href="class_pylon_1_1_c_instant_camera.html">Pylon::CInstantCamera</a>&amp; camera)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Allow all the names in the namespace GenApi to be used without qualification.</span></div><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespace_pylon.html">Pylon</a>;</div><div class="line"></div><div class="line">            <span class="comment">// Get the camera control object.</span></div><div class="line">            <a class="code" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>&amp; nodemap = camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#a3227195969200a52200364bf31e9c586">GetNodeMap</a>();</div><div class="line"></div><div class="line">            <span class="comment">// Get the parameters for setting the image area of interest (Image AOI).</span></div><div class="line">            <a class="code" href="class_pylon_1_1_c_integer_parameter.html">CIntegerParameter</a> width(nodemap, <span class="stringliteral">&quot;Width&quot;</span>);</div><div class="line">            <a class="code" href="class_pylon_1_1_c_integer_parameter.html">CIntegerParameter</a> height(nodemap, <span class="stringliteral">&quot;Height&quot;</span>);</div><div class="line">            <a class="code" href="class_pylon_1_1_c_integer_parameter.html">CIntegerParameter</a> offsetX(nodemap, <span class="stringliteral">&quot;OffsetX&quot;</span>);</div><div class="line">            <a class="code" href="class_pylon_1_1_c_integer_parameter.html">CIntegerParameter</a> offsetY(nodemap, <span class="stringliteral">&quot;OffsetY&quot;</span>);</div><div class="line"></div><div class="line">            <span class="comment">// Maximize the Image AOI.</span></div><div class="line">            offsetX.TrySetToMinimum(); <span class="comment">// Set to minimum if writable.</span></div><div class="line">            offsetY.TrySetToMinimum(); <span class="comment">// Set to minimum if writable.</span></div><div class="line">            width.SetToMaximum();</div><div class="line">            height.SetToMaximum();</div><div class="line"></div><div class="line">            <span class="comment">// Set the pixel data format.</span></div><div class="line">            <a class="code" href="class_pylon_1_1_c_enum_parameter.html">CEnumParameter</a>(nodemap, <span class="stringliteral">&quot;PixelFormat&quot;</span>).<a class="code" href="class_pylon_1_1_c_enum_parameter.html#a91551053a695b38b1b729833a5ac4855">SetValue</a>(<span class="stringliteral">&quot;Mono8&quot;</span>);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="class_pylon_1_1_generic_exception.html">Pylon::GenericException</a>&amp; e)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">throw</span> <a class="code" href="group___base___public_impl.html#ga16e6d812cf9af13e0f4106c77689e46b">RUNTIME_EXCEPTION</a>( <span class="stringliteral">&quot;Could not apply configuration. const GenericException caught in OnOpened method msg=%hs&quot;</span>, e.<a class="code" href="class_pylon_1_1_generic_exception.html#a1dec55837e066cb059ca5999143293b8">what</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>One or more event handler objects can be registered at the Instant Camera object. The following code snippet shows an example of how the above event handler is registered and appended to the configuration event handler list.</p>
<div class="fragment"><div class="line"><span class="comment">// Register an additional configuration handler to set the image format and adjust the AOI.</span></div><div class="line"><span class="comment">// By setting the registration mode to RegistrationMode_Append, the configuration handler is added instead of replacing</span></div><div class="line"><span class="comment">// the already registered configuration handler.</span></div><div class="line">camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#aefc4e8480ceec5fe3991f059e1c4d8d4">RegisterConfiguration</a>( <span class="keyword">new</span> CPixelFormatAndAoiConfiguration, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga6ad39f74e5f882a64461ad02c70567eda06f0a0d28b2552f5b7240e2344d37302">RegistrationMode_Append</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>);</div></div><!-- fragment --><p>For more information about registering and deregistering event handlers consult the interface documentation of the <a class="el" href="pylon_programmingguide.html#hi_typesof_instantcameras">Instant Camera class</a> used and the codes of the following samples: <a class="el" href="sample_code.html#sample_ParametrizeCamera_Configurations">ParametrizeCamera_Configurations</a>, <a class="el" href="sample_code.html#sample_Grab_UsingGrabLoopThread">Grab_UsingGrabLoopThread</a>, and <a class="el" href="sample_code.html#sample_Grab_CameraEvents">Grab_CameraEvents</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to use the Instant Camera classes without using event handler objects.</dd></dl>
<h2><a class="anchor" id="hi_eventhandler_configurations"></a>
Configurations</h2>
<p>Configuration event handler classes are also just called "configurations" because they encapsulate certain camera configurations. The pylon C++ API comes with the following configuration classes:</p>
<ul>
<li><code><a class="el" href="class_pylon_1_1_c_acquire_single_frame_configuration.html" title="An instant camera configuration for single frame acquisition, Use together with CInstantCamera::GrabO...">Pylon::CAcquireSingleFrameConfiguration</a></code> - for single frame acquisition mode. </li>
<li><code><a class="el" href="class_pylon_1_1_c_acquire_continuous_configuration.html" title="Changes the configuration of the camera to free-running continuous acquisition. ">Pylon::CAcquireContinuousConfiguration</a></code> - for continuous frame acquistion mode. </li>
<li><code><a class="el" href="class_pylon_1_1_c_software_trigger_configuration.html" title="Changes the configuration of the camera so that the acquisition of frames is triggered by software tr...">Pylon::CSoftwareTriggerConfiguration</a></code> - for software trigger mode. </li>
<li><code><a class="el" href="class_pylon_1_1_c_action_trigger_configuration.html" title="Changes the configuration of the camera so that it is triggered by the first available action command...">Pylon::CActionTriggerConfiguration</a></code> - for triggers using action commands (applies to GigE Vision only)</li>
</ul>
<p>These classes are provided as header files. This makes it possible to see what parameters of the camera are changed. The code can be copied and modified for creating own configuration classes. <code><a class="el" href="class_pylon_1_1_c_software_trigger_configuration.html" title="Changes the configuration of the camera so that the acquisition of frames is triggered by software tr...">Pylon::CSoftwareTriggerConfiguration</a></code> for instance can be used as basis for creating a hardware trigger configuration with few modifications. <code><a class="el" href="class_pylon_1_1_c_acquire_continuous_configuration.html" title="Changes the configuration of the camera to free-running continuous acquisition. ">Pylon::CAcquireContinuousConfiguration</a></code> is already registered when creating an Instant Camera class, providing a default setup that will work for most cameras.</p>
<p>The following example shows how to apply the software trigger configuration:</p>
<div class="fragment"><div class="line"><span class="comment">// Register the standard configuration event handler for enabling software triggering.</span></div><div class="line"><span class="comment">// The software trigger configuration handler replaces the default configuration</span></div><div class="line"><span class="comment">// as all currently registered configuration handlers are removed by setting the registration mode to RegistrationMode_ReplaceAll.</span></div><div class="line">camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#aefc4e8480ceec5fe3991f059e1c4d8d4">RegisterConfiguration</a>( <span class="keyword">new</span> CSoftwareTriggerConfiguration, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga6ad39f74e5f882a64461ad02c70567eda622d43aab16f129b874526cd63d1a74b">RegistrationMode_ReplaceAll</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>);</div></div><!-- fragment --><p>The code sample <a class="el" href="sample_code.html#sample_ParametrizeCamera_Configurations">ParametrizeCamera_Configurations</a> provides more examples showing the use of configurations.</p>
<h2><a class="anchor" id="hi_instant_camera_array"></a>
Handling Multiple Cameras Using Instant Camera Arrays</h2>
<p>The Instant Camera Array classes help managing multiple cameras in a system. An Instant Camera Array represents an array of instant camera objects. It provides almost the same interface as an Instant Camera for grabbing. The main purpose of the CInstantCameraArray is to simplify waiting for images and camera events of multiple cameras in one thread. This is done by providing a single RetrieveResult method for all cameras in the array. The following classes are available:</p>
<ul>
<li><code><a class="el" href="class_pylon_1_1_c_instant_camera_array.html" title="Supports grabbing with multiple camera devices. ">Pylon::CInstantCameraArray</a></code> </li>
<li><code><a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera_array.html" title="Universal instant camera array. ">Pylon::CBaslerUniversalInstantCameraArray</a></code> </li>
</ul>
<p>The <a class="el" href="sample_code.html#sample_Grab_MultipleCameras">Grab_MultipleCameras</a> code sample illustrates the use of the <a class="el" href="class_pylon_1_1_c_instant_camera_array.html"><code>CInstantCameraArray</code> </a> class.</p>
<h1><a class="anchor" id="configuringcameras"></a>
Accessing Parameters</h1>
<p>For camera configuration and for accessing other parameters, the pylon API uses the technologies defined by the GenICam standard. The GenICam specification (<a href="http://www.GenICam.org">http://www.GenICam.org</a>) defines a format for camera parameter description files. These files describe the configuration interface of GenICam compliant cameras. The description files are written in XML (eXtensible Markup Language) and describe camera registers, their interdependencies, and all other information needed to access high-level features such as Gain, Exposure Time, or Image Format by means of low level register read and write operations.</p>
<p>The elements of a camera description file are represented as software objects called Nodes. For example, a node can represent a single camera register, a camera parameter such as Gain, a set of available parameter values, etc. Each node implements the <code><a class="el" href="struct_gen_api_1_1_i_node.html" title="Interface common to all nodes. ">GenApi::INode</a></code> interface.</p>
<p>The nodes have different types. For example, there are nodes representing integer values and other nodes representing strings. For each type of parameter, there is an interface in GenApi. pylon provides additional interfaces and parameter classes to simplify access to the GenApi interfaces. These interfaces and parameter classes are described in the <a class="el" href="pylon_programmingguide.html#ParameterTypes">Parameter Types</a> section. The <a class="el" href="pylon_programmingguide.html#AccessModes">Access Modes for Parameters</a> section introduces the concept of a parameter access mode. An access mode property is used to determine whether a parameter is available, readable, or writable.</p>
<p>The complete set of nodes is stored in a data structure called node map.</p>
<dl class="section note"><dt>Note</dt><dd>Not only camera devices are parameterized using GenICam node maps. Also, most pylon objects provide node maps to provide access to their parameters. Therefore, a common way for accessing parameters is established.</dd></dl>
<h2><a class="anchor" id="OpeningAndClosing"></a>
Opening and Closing a Camera</h2>
<p>Before reading or writing parameters of a camera, the drivers involved must be initialized and a connection to the physical camera device must be established. This is done by calling the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d55354035ee749bc587b4d923a22c5f"><code>Open()</code> </a> method. The camera can be closed using the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a56fd8d061c6762f8f60e14a0e1345738"><code>Close()</code> </a> method.</p>
<h2><a class="anchor" id="native_parameter_access"></a>
Native Parameter Access</h2>
<p>pylon provides programming interface classes that are created from parameter description files using the code generators. These classes are exported by the Universal Instant Camera class. This provides a member for each available parameter. The <code><a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">Pylon::CBaslerUniversalInstantCamera</a></code> class extends the GenApi interfaces to simplify parameterization. This is the easiest way to access parameters.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Maximize the image area of interest (Image AOI).</span></div><div class="line">camera.OffsetX.TrySetToMinimum();</div><div class="line">camera.OffsetY.TrySetToMinimum();</div><div class="line">camera.Width.SetToMaximum();</div><div class="line">camera.Height.SetToMaximum();</div><div class="line"></div><div class="line"><span class="comment">// Set the pixel data format.</span></div><div class="line">camera.PixelFormat.SetValue(PixelFormat_Mono8);</div></div><!-- fragment --><p>The <a class="el" href="sample_code.html#sample_ParametrizeCamera_NativeParameterAccess">ParametrizeCamera_NativeParameterAccess</a> code sample shows how to access parameters via the <code><a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">Pylon::CBaslerUniversalInstantCamera</a></code> class.</p>
<h2><a class="anchor" id="generic_parameter_access"></a>
Generic Parameter Access</h2>
<p>The complete set of nodes is stored in a data structure called node map. At runtime, a node map is instantiated from an XML description. The parameters or nodes must be accessed using a node map object together with pylon parameter classes based on <a class="el" href="class_pylon_1_1_c_parameter.html" title="CParameter class used to simplify access to GenApi parameters. ">Pylon::CParameter</a>.</p>
<p>Example (setting the same parameters as in the above example):</p>
<div class="fragment"><div class="line"><span class="comment">// Allow all the names in the namespace GenApi to be used without qualification.</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_pylon.html">Pylon</a>;</div><div class="line"></div><div class="line"><span class="comment">// Get the camera control object.</span></div><div class="line"><a class="code" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>&amp; nodemap = camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#a3227195969200a52200364bf31e9c586">GetNodeMap</a>();</div><div class="line"></div><div class="line"><span class="comment">// Get the parameters for setting the image area of interest (Image AOI).</span></div><div class="line"><a class="code" href="class_pylon_1_1_c_integer_parameter.html">CIntegerParameter</a> width(nodemap, <span class="stringliteral">&quot;Width&quot;</span>);</div><div class="line"><a class="code" href="class_pylon_1_1_c_integer_parameter.html">CIntegerParameter</a> height(nodemap, <span class="stringliteral">&quot;Height&quot;</span>);</div><div class="line"><a class="code" href="class_pylon_1_1_c_integer_parameter.html">CIntegerParameter</a> offsetX(nodemap, <span class="stringliteral">&quot;OffsetX&quot;</span>);</div><div class="line"><a class="code" href="class_pylon_1_1_c_integer_parameter.html">CIntegerParameter</a> offsetY(nodemap, <span class="stringliteral">&quot;OffsetY&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Maximize the Image AOI.</span></div><div class="line">offsetX.TrySetToMinimum(); <span class="comment">// Set to minimum if writable.</span></div><div class="line">offsetY.TrySetToMinimum(); <span class="comment">// Set to minimum if writable.</span></div><div class="line">width.SetToMaximum();</div><div class="line">height.SetToMaximum();</div><div class="line"></div><div class="line"><span class="comment">// Set the pixel data format.</span></div><div class="line"><a class="code" href="class_pylon_1_1_c_enum_parameter.html">CEnumParameter</a>(nodemap, <span class="stringliteral">&quot;PixelFormat&quot;</span>).<a class="code" href="class_pylon_1_1_c_enum_parameter.html#a91551053a695b38b1b729833a5ac4855">SetValue</a>(<span class="stringliteral">&quot;Mono8&quot;</span>);</div></div><!-- fragment --><p>The <a class="el" href="sample_code.html#sample_ParametrizeCamera_GenericParameterAccess">ParametrizeCamera_GenericParameterAccess</a> code sample shows how to use the generic parameter access.</p>
<h2><a class="anchor" id="where_to_find_parameters"></a>
Where to Find Information About Camera Parameters</h2>
<p>The following sources can be used to get information about camera parameters:</p>
<ul>
<li>The camera User's Manual </li>
<li>The interface documentation of the <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html"><code>CBaslerUniversalInstantCamera</code> </a> class. </li>
<li>The pylon Viewer </li>
<li>The <a class="el" href="index.html#parameter_reference">Parameter Reference</a> </li>
<li>The pylon samples</li>
</ul>
<h2><a class="anchor" id="ParameterTypes"></a>
Parameter Types</h2>
<h3><a class="anchor" id="IntegerParameters"></a>
Integer Parameters</h3>
<p>The <code><a class="el" href="struct_gen_api_1_1_i_integer.html" title="Interface for integer properties. ">GenApi::IInteger</a></code> interface (optionally extended by <code><a class="el" href="struct_pylon_1_1_i_integer_ex.html" title="Extends the GenApi::IInteger interface with convenience methods. ">Pylon::IIntegerEx</a></code> and <code><a class="el" href="class_pylon_1_1_c_integer_parameter.html" title="CIntegerParameter class used to simplify access to GenApi parameters. ">Pylon::CIntegerParameter</a></code>) is used to access integer parameters. An integer parameter represents a feature that can be set by an integer number, such as a camera's image width or height in pixels. The current value of an integer parameter is augmented by a minimum and a maximum value, defining a range of allowed values for the parameter, and by an increment that acts as a 'step width' for changes to the parameter's value. The set of all allowed values for an integer parameter can hence be expressed as x&#160;:=&#160;{minimum}&#160;+&#160;N&#160;*&#160;{increment}, with N&#160;=&#160;0,1,2&#160;..., x&#160;&lt;=&#160;{maximum}. The current value, minimum, maximum, and increment can all be accessed as 64 bit values. The following example prints all valid values for the Width parameter:</p>
<div class="fragment"><div class="line">camera.Width = camera.Width.GetMin();</div><div class="line">int64_t w = camera.Width.GetMin();</div><div class="line"><span class="keywordflow">while</span> ( w &lt;= camera.Width.GetMax() )</div><div class="line">{</div><div class="line">  cout &lt;&lt; w;</div><div class="line">  w += camera.Width.GetInc();</div><div class="line">}</div></div><!-- fragment --><p>There are two equivalent possibilities for setting a value using the <code><a class="el" href="struct_gen_api_1_1_i_integer.html" title="Interface for integer properties. ">GenApi::IInteger</a></code> interface: </p><ul>
<li>Using the assignment operator, e.g.: <div class="fragment"><div class="line">camera.Width = 500; </div></div><!-- fragment --> </li>
<li>Using the <code>SetValue()</code> method, e.g.: <div class="fragment"><div class="line">camera.Width.SetValue( 500 ); </div></div><!-- fragment --></li>
</ul>
<p>There are also two equivalent ways to get a parameter's current value: </p><ul>
<li>Using the function call operator, e.g.: <div class="fragment"><div class="line">t = camera.Width(); </div></div><!-- fragment --> </li>
<li>Using the GetValue() method, e.g.: <div class="fragment"><div class="line">t = camera.Width.GetValue(); </div></div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="FloatingPointParameters"></a>
Floating Point Parameters</h3>
<p>Floating point parameters are represented by <code><a class="el" href="struct_gen_api_1_1_i_float.html" title="Interface for float properties. ">GenApi::IFloat</a></code>, <code><a class="el" href="struct_pylon_1_1_i_float_ex.html" title="Extends the GenApi::IFloat interface with convenience methods. ">Pylon::IFloatEx</a></code>, and <code><a class="el" href="class_pylon_1_1_c_float_parameter.html" title="CFloatParameter class used to simplify access to GenApi parameters. ">Pylon::CFloatParameter</a></code> objects. A float parameter represents a feature that can be set by a floating-point value, such as a camera's exposure time expressed in seconds. The floating point parameter is similar to the integer parameter with two exceptions: all values are of the 'double' type (double precision floating point numbers as defined by the IEEE 754 standard) and there is no increment value. Hence, a float parameter is allowed to take any value from the interval {minimum} &lt;= x &lt;={maximum}.</p>
<h3><a class="anchor" id="BooleanParameters"></a>
Boolean Parameters</h3>
<p>A Boolean parameter represents a binary-valued feature which can be enabled or disabled. It is represented by the <code><a class="el" href="struct_gen_api_1_1_i_boolean.html" title="Interface for Boolean properties. ">GenApi::IBoolean</a></code> interface and <code><a class="el" href="struct_pylon_1_1_i_boolean_ex.html" title="Extends the GenApi::IBoolean interface with convenience methods. ">Pylon::IBooleanEx</a></code> and <code>CBooleanParameter</code> objects. Example: Any 'switch' to enable or disable a feature, such as a camera's external trigger input. Set and get operations are similar to the ones used by the <code><a class="el" href="struct_gen_api_1_1_i_integer.html" title="Interface for integer properties. ">GenApi::IInteger</a></code> interface.</p>
<h3><a class="anchor" id="EnumerationParameters"></a>
Enumeration Parameters</h3>
<p>The <code><a class="el" href="struct_gen_api_1_1_i_enumeration.html" title="Interface for enumeration properties. ">GenApi::IEnumeration</a></code> interface (optionally extended by <code><a class="el" href="struct_pylon_1_1_i_enumeration_ex.html" title="Extends the GenApi::IEnumeration interface with convenience methods. ">Pylon::IEnumerationEx</a></code>, <code><a class="el" href="class_pylon_1_1_c_enum_parameter.html" title="CEnumParameter class used to simplify access to GenApi parameters. ">Pylon::CEnumParameter</a></code>, and <code>Pylon::IEnumerationT</code>) is used to represent camera parameters that can take any value from a predefined set. Example: Parameters such as PixelFormat or TestImageSelector.</p>
<p>Example: </p><div class="fragment"><div class="line">camera.PixelFormat.SetValue( PixelFormat_Mono16 );</div></div><!-- fragment --><h3><a class="anchor" id="CommandParameters"></a>
Command Parameters</h3>
<p>Command parameters (<code><a class="el" href="struct_gen_api_1_1_i_command.html">GenApi::ICommand</a></code>, <code><a class="el" href="struct_pylon_1_1_i_command_ex.html" title="Extends the GenApi::ICommand interface with convenience methods. ">Pylon::ICommandEx</a></code>, and <code><a class="el" href="class_pylon_1_1_c_command_parameter.html" title="CCommandParameter class used to simplify access to GenApi parameters. ">Pylon::CCommandParameter</a></code>) are used for parameters that trigger an action or an operation inside of the camera, e.g., issue a software trigger. The action is issued by calling the <code><a class="el" href="struct_gen_api_1_1_i_command.html#a4e72b6ccf61c1f92a1334b9e59eb4fc6" title="Execute the command. ">GenApi::ICommand::Execute()</a></code> method. The <code><a class="el" href="struct_gen_api_1_1_i_command.html#a76edd8064041fff5d6a92fc8739af327" title="Query whether the command is executed. ">GenApi::ICommand::IsDone()</a></code> method can be used to determine whether a running operation has finished.</p>
<h3><a class="anchor" id="StringPrameters"></a>
String Parameters</h3>
<p>The <code><a class="el" href="struct_gen_api_1_1_i_string.html" title="Interface for string properties. ">GenApi::IString</a></code> interface and the <code><a class="el" href="struct_pylon_1_1_i_string_ex.html" title="Extends the GenApi::IString interface with convenience methods. ">Pylon::IStringEx</a></code> and <code><a class="el" href="class_pylon_1_1_c_string_parameter.html" title="CStringParameter class used to simplify access to GenApi parameters. ">Pylon::CStringParameter</a></code> objects provide access to string parameters. The <code><a class="el" href="class_gen_i_cam_1_1gcstring.html" title="A string class which is a clone of std::string. ">GenICam::gcstring</a></code> class is used to represent strings. The <code>gcstring</code> class is similar to the C++ Standard Library <code>std::string</code> class. pylon uses <code><a class="el" href="class_gen_i_cam_1_1gcstring.html" title="A string class which is a clone of std::string. ">GenICam::gcstring</a></code> by providing the <code><a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9" title="Pylon&#39;s string definition. ">Pylon::String_t</a></code> type definition.</p>
<h2><a class="anchor" id="AccessModes"></a>
Access Modes for Parameters</h2>
<p>Each parameter has an access mode that describes whether a feature is implemented, available, readable, and writable. For a given camera, a feature may not be implemented at all. For example, a monochrome camera will not include a white balance feature. Depending on the camera's state, a feature may temporarily not be available. For example, a parameter related to external triggering may not be available when the camera is in free run mode. Available features can be read-only, write-only, or readable and writable.</p>
<p>The current state of a parameter can be queried by calling the parameter's <code>GetAccessMode()</code> method, which returns a <code><a class="el" href="group___gen_api___public_utilities.html#ga0900b33e900e2021e1941455c38207c7">GenApi::EAccessMode</a></code> enumeration value described in the following table:</p>
<table  border="1" class="table" frame="void" cellspacing="6" cellpadding="7">
<tr>
<th>EAccessMode</th><th>Implemented</th><th>Available</th><th>Readable</th><th>Writable </th></tr>
<tr>
<td>NI</td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>NA</td><td>Yes</td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>WO</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes </td></tr>
<tr>
<td>RO</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No </td></tr>
<tr>
<td>RW</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes </td></tr>
</table>
<p>Typically, it is sufficient to check if a parameter is readable or writable. For this purpose, all pylon parameter interfaces and classes implement the methods <code><a class="el" href="struct_pylon_1_1_i_value_ex.html#aecafd04d36b4c3a49a79b1368e102db5" title="Indicates whether the parameter is readable. ">Pylon::IValueEx::IsReadable()</a></code> and <code><a class="el" href="struct_pylon_1_1_i_value_ex.html#a4108d39c129f1e3b43c8e7b39ace1b28" title="Indicates whether the parameter is writable. ">Pylon::IValueEx::IsWritable()</a></code>.</p>
<h2><a class="anchor" id="HandlingDifferencesInParameterSets"></a>
Handling Differences Between Different Cameras Models</h2>
<p>Most features, e.g., Gain, are named according to the GenICam Standard Feature Naming Convention (SFNC). The SFNC defines a common set of features, their behavior, and the related parameter names. All Basler USB 3.0 and CoaXPress as well as most GigE, e.g., ace 2 GigE, cameras are based on the SFNC version 2.0 or later. Older Basler GigE camera models, however, are based on previous SFNC versions. Accordingly, the behavior of these cameras and some parameter names will be different. The following sections show how to handle this.</p>
<h3><a class="anchor" id="UsingTryMethods"></a>
Try Methods</h3>
<p>The pylon parameter interfaces and classes provide methods that are prefixed with "Try", e.g., <code>Pylon::IEnumerationEx::TrySetValue(int64_t)</code>. For these methods, the action is executed if the parameter is writable. Sometimes, the value must also be settable.</p>
<p>Example showing how turn GainAuto off if the camera provides GainAuto: </p><div class="fragment"><div class="line">CEnumParameter gainAuto(nodemap, <span class="stringliteral">&quot;GainAuto&quot;</span>);</div><div class="line">gainAuto.TrySetValue(<span class="stringliteral">&quot;Off&quot;</span>);</div></div><!-- fragment --><p>For the exact semantics of a "Try" method, check its documentation.</p>
<h3><a class="anchor" id="UsingOrDefaultMethods"></a>
OrDefault Methods</h3>
<p>Methods that are suffixed with "OrDefault", e.g., GetValueOrDefault(), can be used to read a parameter value if it is readable or otherwise return a default value.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">//code that runs for cameras with and without chunk support.</span></div><div class="line"><span class="keywordflow">if</span> (camera.ChunkModeActive.GetValueOrDefault(<span class="keyword">false</span>))</div><div class="line">{</div><div class="line">    <span class="comment">//do something if chunk mode is active</span></div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="CheckingSfncVersion"></a>
Checking the SFNC Version</h3>
<p>If your code has to work with multiple camera device types that are compatible with different SFNC versions, you can use <a class="el" href="class_pylon_1_1_c_instant_camera.html#a90d2817d90e2a6b0a2fa120666bc702a">GetSfncVersion() </a> to handle differences in parameter name and behavior.</p>
<p>Example for <a class="el" href="pylon_programmingguide.html#generic_parameter_access">Generic Parameter Access</a> :</p>
<div class="fragment"><div class="line"><span class="comment">// Check to see which Standard Feature Naming Convention (SFNC) is used by the camera device.</span></div><div class="line"><span class="keywordflow">if</span> ( camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#a90d2817d90e2a6b0a2fa120666bc702a">GetSfncVersion</a>() &gt;= Sfnc_2_0_0)</div><div class="line">{</div><div class="line">    <span class="comment">// Access the Gain float type node. This node is available for USB camera devices.</span></div><div class="line">    <span class="comment">// USB camera devices are compliant to SFNC version 2.0.</span></div><div class="line">    CFloatParameter gain(nodemap, <span class="stringliteral">&quot;Gain&quot;</span>);</div><div class="line">    gain.SetValuePercentOfRange(50.0);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Gain (50%)       : &quot;</span> &lt;&lt; gain.GetValue() &lt;&lt; <span class="stringliteral">&quot; (Min: &quot;</span> &lt;&lt; gain.GetMin() &lt;&lt; <span class="stringliteral">&quot;; Max: &quot;</span> &lt;&lt; gain.GetMax() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="comment">// Access the GainRaw integer type node. This node is available for IIDC 1394 and GigE camera devices.</span></div><div class="line">    CIntegerParameter gainRaw(nodemap, <span class="stringliteral">&quot;GainRaw&quot;</span>);</div><div class="line">    gainRaw.SetValuePercentOfRange(50.0);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Gain (50%)       : &quot;</span> &lt;&lt; gainRaw.GetValue() &lt;&lt; <span class="stringliteral">&quot; (Min: &quot;</span> &lt;&lt; gainRaw.GetMin() &lt;&lt; <span class="stringliteral">&quot;; Max: &quot;</span> &lt;&lt; gainRaw.GetMax() &lt;&lt; <span class="stringliteral">&quot;; Inc: &quot;</span> &lt;&lt; gainRaw.GetInc() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="hi_grabbingimages"></a>
Grabbing Images</h1>
<p>This section shows how to grab images using the Instant Camera class. Before grabbing images the camera parameters must be set up using one or more of the following approaches:</p>
<ul>
<li>Registered <a class="el" href="pylon_programmingguide.html#hi_eventhandler_configurations">configuration objects</a> configure the camera. </li>
<li>The camera is set up using code in the program flow after <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d55354035ee749bc587b4d923a22c5f"><code>Open()</code> </a> is called. </li>
<li>The camera is preconfigured, e.g. using the pylon Viewer. The settings are stored in a user set in the camera and become active when the camera powers up, provided the user set was selected as the "startup set". </li>
<li>The parameters are loaded from disk. The <a class="el" href="pylon_advanced_topics.html#loadsavecamerafeatures">Advanced Topics</a> section shows how to do this.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Using the latter three approaches may require to remove the default configuration after the Instant Camera object has been created. The following example shows how to do this. The configuration must be removed before calling the Open() method.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Create a camera object</span></div><div class="line">CInstantCamera camera;</div><div class="line"><span class="comment">// Remove the default configuration</span></div><div class="line">camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#aefc4e8480ceec5fe3991f059e1c4d8d4">RegisterConfiguration</a>( (CConfigurationEventHandler*) NULL, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga6ad39f74e5f882a64461ad02c70567eda622d43aab16f129b874526cd63d1a74b">RegistrationMode_ReplaceAll</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5ab2a4bc04535c971546bf9ad9511e80dc">Cleanup_None</a>);</div></div><!-- fragment --><h2><a class="anchor" id="AcquireTransferGrabHi"></a>
Acquire, Transfer, and Grab Images</h2>
<p>In this document we distinguish between image acquisition, image data transfer, and image grabbing.</p>
<p>We denote the processes inside the camera as image acquisition. When a camera starts image acquisition, the sensor is exposed. When exposure is complete, the image data is read out from the sensor.</p>
<p>The acquired image data is transferred from the camera's memory to the computer using an interface such as USB or Gigabit Ethernet.</p>
<p>The process of writing the image data into the computer's main memory is referred to as "grabbing" an image.</p>
<h2><a class="anchor" id="hi_grab_result"></a>
The Grab Result</h2>
<p>The data of a grabbed image is held by a <a class="el" href="class_pylon_1_1_c_grab_result_data.html"><code>Grab</code> <code>Result</code> <code>Data</code> </a> object. The Grab Result Data object can't be directly accessed. It is always held by a grab result smart pointer, e.g. the basic grab result smart pointer <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html"><code>CGrabResultPtr</code> </a>. The combination of smart pointer and Grab Result Data object is also referred to as grab result. The smart pointer controls the reuse and the lifetime of the Grab Result Data object and the associated image buffer. When all smart pointers referencing a Grab Result Data object go out of scope, the grab result's image buffer is reused for grabbing. Due to the smart pointer concept, a Grab Result Data object and the associated image buffer can live longer than the camera object used for grabbing the image data. The <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html"><code>CBaslerUniversalInstantCamera</code> </a> class has a specific Grab Result Data object and a specific grab result smart pointer. The specific grab result smart pointer can be converted to or from the basic grab result smart pointer CGrabResultPtr by copying or assigning.</p>
<dl class="section note"><dt>Note</dt><dd>The grabbing will stop with a buffer underrun when the grab results are never released, e.g. when put into a container.</dd></dl>
<p>The grab result smart pointer classes provide a cast operator that allows passing a grab result smart pointer directly to functions or methods that take a <code>const</code> <code><a class="el" href="struct_pylon_1_1_i_image.html" title="Usable to access image properties and image buffer. ">Pylon::IImage</a>&amp;</code> as parameter, e.g. image saving functions.</p>
<dl class="section attention"><dt>Attention</dt><dd>The returned reference to <code>IImage</code> is only valid as long the grab result smart pointer it came from is not destroyed.</dd></dl>
<h2><a class="anchor" id="buffer_handling"></a>
Buffer Handling</h2>
<p>New buffers are automatically allocated for each grab session starting with <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a>. The buffer of a grabbed image is held by the Grab Result Data object. While the grabbing is in progress a buffer is reused when the Grab Result Data object is released by the grab result smart pointer. If the Grab Result Data object is released when the grabbing has stopped then the buffer is freed.</p>
<p>The number of used image data buffers can be set using the <a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a9205abb1850ef7e5f1a79fe2ccd377f9"><code>MaxNumBuffer</code> </a> parameter. The default amount of buffers used for grabbing is 10. The buffer size required for grabbing is automatically determined.</p>
<p>The number of allocated buffers is automatically reduced when grabbing a defined number of images smaller than the value of <code>MaxNumBuffer</code>, e.g. 5.</p>
<dl class="section note"><dt>Note</dt><dd>A buffer factory can be attached to an Instant Camera object for using user provided buffers. The use of a buffer factory is optional and intended for advanced use cases only. Consult the <a class="el" href="pylon_advanced_topics.html#buffer_factory">Advanced Topics</a> section for more information.</dd></dl>
<h2><a class="anchor" id="grab_engine"></a>
The Grab Engine</h2>
<p>The Instant Camera grab engine consists of an empty buffer queue, an output queue, and a grab thread. The grab engine uses a Low Level API stream grabber to grab images. The empty buffer queue and the output queue can hold the number of buffers defined by the <a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a9205abb1850ef7e5f1a79fe2ccd377f9">MaxNumBuffer </a> parameter. <a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#ab91a278d159ff95e0c78c772a7259d67">MaxNumQueuedBuffer </a> buffers are passed to the Low Level API stream grabber at any time. All queues work in FIFO mode (First-In-First-Out). The grab engine thread ensures that the stream grabber does not run out of buffers as long as buffers are available in the empty buffer queue.</p>
<h2><a class="anchor" id="grab_strategy_one_by_one_pg"></a>
The Default Grab Strategy One By One</h2>
<p>The Instant Camera supports different grab strategies. The default strategy is One By One. When the grab strategy One By One is used images are processed in the order of their acquisition.</p>
<div class="image">
<img src="pylon_buffer_flow_one_by_one.png" alt="pylon_buffer_flow_one_by_one.png"/>
<div class="caption">
The Buffer Flow Using Grab Strategy One By One</div></div>
<ul>
<li>The Instant Camera grab engine unqueues buffers from the Empty Buffer Queue and queues the empty buffers at the Low Level API stream grabber (1). </li>
<li>The camera device is triggered (2). An image is acquired by the camera device, it is transfered to the computer and then grabbed into an empty buffer. </li>
<li>The Instant Camera grab engine thread is notified that a filled buffer is available. The filled buffer is retrieved by the grab engine thread (3) and is put into the Output Queue. </li>
<li>The application thread waiting inside the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8">RetrieveResult() </a> method is notified, it stops waiting for a grab result, and it retrieves the filled buffer (4) as part of a grab result data object. </li>
<li>The grab result data object is held by a grab result smart pointer. After the application has processed the image data the filled buffer is returned to the Empty Buffer Queue (5). This is done by the grab result smart pointer destructor or when the grab result data object is explicitly released. Returned buffers are used again for grabbing.</li>
</ul>
<p>More information about grab strategies can be found in the <a class="el" href="pylon_advanced_topics.html#grab_strategies">advanced topics section</a>.</p>
<h2><a class="anchor" id="hi_grab_loop"></a>
Grabbing Images in a Loop</h2>
<p>The following example shows a simple grab loop:</p>
<div class="fragment"><div class="line"><span class="comment">// Create an instant camera object with the camera device found first.</span></div><div class="line">CInstantCamera camera( CTlFactory::GetInstance().CreateFirstDevice());</div><div class="line"></div><div class="line"><span class="comment">// Print the model name of the camera.</span></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Using device &quot;</span> &lt;&lt; camera.GetDeviceInfo().GetModelName() &lt;&lt; endl;</div><div class="line"></div><div class="line"><span class="comment">// Start the grabbing of c_countOfImagesToGrab images.</span></div><div class="line"><span class="comment">// The camera device is parameterized with a default configuration which</span></div><div class="line"><span class="comment">// sets up free-running continuous acquisition.</span></div><div class="line">camera.StartGrabbing( c_countOfImagesToGrab);</div><div class="line"></div><div class="line"><span class="comment">// This smart pointer will receive the grab result data.</span></div><div class="line">CGrabResultPtr ptrGrabResult;</div><div class="line"></div><div class="line"><span class="comment">// Camera.StopGrabbing() is called automatically by the RetrieveResult() method</span></div><div class="line"><span class="comment">// when c_countOfImagesToGrab images have been retrieved.</span></div><div class="line"><span class="keywordflow">while</span> ( camera.IsGrabbing())</div><div class="line">{</div><div class="line">    <span class="comment">// Wait for an image and then retrieve it. A timeout of 5000 ms is used.</span></div><div class="line">    camera.RetrieveResult( 5000, ptrGrabResult, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Image grabbed successfully?</span></div><div class="line">    <span class="keywordflow">if</span> (ptrGrabResult-&gt;GrabSucceeded())</div><div class="line">    {</div><div class="line">        <span class="comment">// Access the image data.</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;SizeX: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetWidth() &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;SizeY: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetHeight() &lt;&lt; endl;</div><div class="line">        <span class="keyword">const</span> uint8_t *pImageBuffer = (uint8_t *) ptrGrabResult-&gt;GetBuffer();</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Gray value of first pixel: &quot;</span> &lt;&lt; (uint32_t) pImageBuffer[0] &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorCode() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorDescription() &lt;&lt; endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The camera object is created. The grabbing is started by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a>. Since the camera is not open yet, it is automatically opened by the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a> method. The default configuration event handler is called and it applies the default configuration. Images are grabbed continuously by the Instant Camera object and the grab results are placed into the Instant Camera's output queue in the order they are aqcuired by the camera (Grab Strategy One By One). The <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><code>RetrieveResult()</code> </a> method is used to wait for a grab result and for retrieving it from the output queue. Some of the grab result data is printed to the screen after it is retrieved. <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><code>StopGrabbing()</code> </a> is called automatically by the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><code>RetrieveResult()</code> </a> method when <code>c_countOfImagesToGrab</code> images have been retrieved. The while statement condition is used to check if the grabbing has been stopped.</p>
<p>It is possible to start grabbing for an unlimited number of images by omitting the maximum number of images to grab in the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a> call and call <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><code>StopGrabbing()</code> </a> from inside the grab loop to finish grabbing.</p>
<p>The above code snippet can be found in the <a class="el" href="sample_code.html#sample_Grab">Grab</a> code sample.</p>
<h2><a class="anchor" id="hi_grab_grabloop_thread"></a>
Grabbing Images Using the Grab Loop Thread Provided by the Instant Camera</h2>
<p>The Instant Camera class can optionally provide a grab loop thread. The thread runs a grab loop calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><code>RetrieveResult()</code> </a> repeatedly. When using the provided grab loop thread an image event handler is required to process the grab results.</p>
<p>The following image event handler is used:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CImageEventPrinter : <span class="keyword">public</span> CImageEventHandler</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnImageGrabbed( CInstantCamera&amp; camera, <span class="keyword">const</span> CGrabResultPtr&amp; ptrGrabResult)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;OnImageGrabbed event for device &quot;</span> &lt;&lt; camera.GetDeviceInfo().GetModelName() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">// Image grabbed successfully?</span></div><div class="line">        <span class="keywordflow">if</span> (ptrGrabResult-&gt;GrabSucceeded())</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;SizeX: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetWidth() &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;SizeY: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetHeight() &lt;&lt; std::endl;</div><div class="line">            <span class="keyword">const</span> uint8_t *pImageBuffer = (uint8_t *) ptrGrabResult-&gt;GetBuffer();</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Gray value of first pixel: &quot;</span> &lt;&lt; (uint32_t) pImageBuffer[0] &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorCode() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorDescription() &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The following example shows how to grab using the grab loop thread provided by the Instant Camera object:</p>
<div class="fragment"><div class="line"><span class="comment">// The image event printer serves as sample image processing.</span></div><div class="line"><span class="comment">// When using the grab loop thread provided by the Instant Camera object, an image event handler processing the grab</span></div><div class="line"><span class="comment">// results must be created and registered.</span></div><div class="line">camera.RegisterImageEventHandler( <span class="keyword">new</span> CImageEventPrinter, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga6ad39f74e5f882a64461ad02c70567eda06f0a0d28b2552f5b7240e2344d37302">RegistrationMode_Append</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>);</div><div class="line"></div><div class="line"><span class="comment">// Start the grabbing using the grab loop thread, by setting the grabLoopType parameter</span></div><div class="line"><span class="comment">// to GrabLoop_ProvidedByInstantCamera. The grab results are delivered to the image event handlers.</span></div><div class="line"><span class="comment">// The GrabStrategy_OneByOne default grab strategy is used.</span></div><div class="line">camera.StartGrabbing( <a class="code" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a3a3229ee04054114d6929a1ee325be9a">GrabLoop_ProvidedByInstantCamera</a>);</div><div class="line"></div><div class="line">cerr &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Enter \&quot;t\&quot; to trigger the camera or \&quot;e\&quot; to exit and press enter? (t/e)&quot;</span> &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line"><span class="comment">// Wait for user input to trigger the camera or exit the program.</span></div><div class="line"><span class="comment">// The grabbing is stopped, the device is closed and destroyed automatically when the camera object goes out of scope.</span></div><div class="line"><span class="keywordtype">char</span> key;</div><div class="line"><span class="keywordflow">do</span></div><div class="line">{</div><div class="line">    cin.get(key);</div><div class="line">    <span class="keywordflow">if</span> ( (key == <span class="charliteral">&#39;t&#39;</span> || key == <span class="charliteral">&#39;T&#39;</span>))</div><div class="line">    {</div><div class="line">        <span class="comment">// Execute the software trigger. Wait up to 1000 ms for the camera to be ready for trigger.</span></div><div class="line">        <span class="keywordflow">if</span> ( camera.WaitForFrameTriggerReady( 1000, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>))</div><div class="line">        {</div><div class="line">            camera.ExecuteSoftwareTrigger();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordflow">while</span> ( (key != <span class="charliteral">&#39;e&#39;</span>) &amp;&amp; (key != <span class="charliteral">&#39;E&#39;</span>));</div></div><!-- fragment --><p>First, the image event handler is registered. It prints a message on the screen for every grabbed image. It serves as image processing in this example. The grabbing is started using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a> for an unlimited number of images and uses the grab loop thread provided by the Instant Camera object by setting the second parameter to GrabLoop_ProvidedByInstantCamera. The main thread can now be used to query the user for input to either trigger an image or to exit the input loop. The grabbing is not explicitly stopped in this example and could be stopped by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><code>StopGrabbing()</code> </a>. The above code snippet can be found in the <a class="el" href="sample_code.html#sample_Grab_UsingGrabLoopThread">Grab_UsingGrabLoopThread</a> code sample.</p>
<h2><a class="anchor" id="hi_grab_one"></a>
Grabbing a Single Image</h2>
<p>For convenience, the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a17b74eca17e24b3ee7c7517fc223f6e3"><code>GrabOne()</code> </a> method can be used to grab a single image. The following code shows a simplified version of what is done:</p>
<div class="fragment"><div class="line"><span class="comment">//grab one image</span></div><div class="line">StartGrabbing( 1, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a1006c968199ded056843b9c42854b206">GrabLoop_ProvidedByUser</a>);</div><div class="line"></div><div class="line"><span class="comment">//grab is stopped automatically due to maxImages = 1</span></div><div class="line"><span class="keywordflow">return</span> RetrieveResult( timeoutMs, grabResult, timeoutHandling) &amp;&amp; grabResult-&gt;GrabSucceeded();</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a17b74eca17e24b3ee7c7517fc223f6e3"><code>GrabOne()</code> </a> is more efficient if the pylon Device is already open, otherwise the pylon Device is opened and closed automatically for each call.</dd>
<dd>
Grabbing single images using Software Trigger (<a class="el" href="class_pylon_1_1_c_software_trigger_configuration.html"><code>CSoftwareTriggerConfiguration</code> </a>) is recommended if you want to maximize the frame rate. This is because the overhead per grabbed image is reduced compared to Single Frame Acquisition. The grabbing can be started using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a>. Images are grabbed using the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a7506b5b38079ba4583a088a620187b29"><code>WaitForFrameTriggerReady()</code> </a>,<a class="el" href="class_pylon_1_1_c_instant_camera.html#ae5a4e166d9198dd4706a1c72c0bc2bc6"><code>ExecuteSoftwareTrigger()</code> </a> and <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><code>RetrieveResult()</code> </a> methods instead of using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a17b74eca17e24b3ee7c7517fc223f6e3"><code>GrabOne()</code> </a>. The grabbing can be stopped using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><code>StopGrabbing()</code> </a> when done.</dd></dl>
<h1><a class="anchor" id="hi_advanced_features"></a>
Using Advanced Camera Features</h1>
<h2><a class="anchor" id="hi_grabbingevents"></a>
Handling Camera Events</h2>
<p>Basler GigE Vision and USB3 Vision cameras can send event messages. For example, when a sensor exposure has finished, the camera can send an Exposure End event to the computer. Events can be received by registering an image event handler at an Instant Camera class. See the <a class="el" href="pylon_advanced_topics.html#hi_grabbingevents_ref">Advanced Topics</a> section for more information.</p>
<h2><a class="anchor" id="hi_parsingchunks"></a>
Accessing Chunk Features</h2>
<p>Basler Cameras are able to send additional information as so-called data chunks appended to the image data, such as frame counters, time stamps, or CRC checksums. Data chunks are automatically parsed by the Instant Camera class if activated. See the <a class="el" href="pylon_advanced_topics.html#hi_parsingchunks_ref">Advanced Topics</a> section for more information.</p>
<h2><a class="anchor" id="hi_pnp"></a>
Getting Informed About Camera Device Removal</h2>
<p>To get informed about camera device removal the method <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3bc410c61618d7565455751991ce2791"><code>IsCameraDeviceRemoved()</code> </a> can be queried or a <a class="el" href="pylon_programmingguide.html#hi_eventhandler_configurations">configuration event handler</a> can be registered. The virtual method <a class="el" href="class_pylon_1_1_c_configuration_event_handler.html#afe121efea7306bb5f3d0b8a958d82677"><code>OnCameraDeviceRemoved()</code> </a> is called if a camera device is removed. See the <a class="el" href="pylon_advanced_topics.html#hi_pnp_ref">Advanced Topics</a> section for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>OnCameraDeviceRemoved</code> call is made from a separate thread.</dd></dl>
<h2><a class="anchor" id="hi_broadcast_multicast"></a>
GigE Multicast/Broadcast: Grab Images of One Camera on Multiple Computers</h2>
<p>Basler GigE cameras can be configured to send the image data stream to multiple destinations. Either IP multicasts or IP broadcasts can be used. For more information consult the <a class="el" href="pylon_advanced_topics.html#MulticastGrabbing">advanced topics section</a>.</p>
<h1><a class="anchor" id="hi_image_handling"></a>
Image Handling</h1>
<p>Besides the Instant Camera classes used for grabbing images pylon offers additional <a class="el" href="group___pylon___image_handling_support.html">Image Handling Support</a> support for handling grabbed images. There are an image class, an image format converter, and the loading and saving of images.</p>
<h2><a class="anchor" id="hi_pylon_image"></a>
The pylon Image Class</h2>
<p>When working with image data the handling of buffer size and lifetime often involves a lot of coding. The <code><a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">Pylon::CPylonImage</a></code> class simplifies this. It also allows to attach a buffer of a grab result preventing its reuse as long as required. Additionally, user buffers or buffers provided by third party software packages can be connected. Besides that, the pylon Image class helps when working with image planes or AOIs. The <a class="el" href="sample_code.html#sample_Utility_Image">Utility_Image</a> code sample shows the use of the pylon Image class.</p>
<h2><a class="anchor" id="hi_image_format_converter"></a>
The Image Format Converter</h2>
<p>The <code><a class="el" href="class_pylon_1_1_c_image_format_converter.html" title="Creates new images by converting a source image to another format. ">Pylon::CImageFormatConverter</a></code> creates new images by converting a source image to a different format. Once the format converter is configured it can convert almost all image formats supported by Basler camera devices. The <a class="el" href="sample_code.html#sample_Utility_ImageFormatConverter">Utility_ImageFormatConverter</a> code sample shows the use of the Image Format Converter class.</p>
<h2><a class="anchor" id="hi_video_writer"></a>
The Video Writer</h2>
<p>The <code><a class="el" href="class_pylon_1_1_c_video_writer.html" title="Supports writing video files. ">Pylon::CVideoWriter</a></code> can be used to create video files in the MP4 format. The <a class="el" href="sample_code.html#sample_Utility_GrabVideo">Utility_GrabVideo</a> code sample shows the use of the Video Writer class.</p>
<h2><a class="anchor" id="hi_image_load_save"></a>
Loading and Saving Images</h2>
<p>The <code><a class="el" href="class_pylon_1_1_c_image_persistence.html" title="Contains static functions supporting loading and saving of images. ">Pylon::CImagePersistence</a></code> class supports loading and saving images to disk. The pylon Image classes use this interface internally and provide methods for loading and saving. The <a class="el" href="sample_code.html#sample_Utility_ImageLoadAndSave">Utility_ImageLoadAndSave</a> code sample shows how to load and save images. </p>
</div></div><!-- contents -->
<hr>
<div id="projectname">pylon <span id="projectnumber">6.1.0</span></div>
<address><small>Copyright (c) 2006-2020 <a href="http://www.baslerweb.com/">Basler AG</a>   (Mon Mar 16 2020 10:56:52)</small></address>
</body>
</html>
