<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_pylon.html">Pylon</a></li><li class="navelem"><a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_pylon_1_1_c_pylon_image-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pylon::CPylonImage Class Reference<div class="ingroups"><a class="el" href="group___pylon___image_handling_support.html">Image Handling Support</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Describes an image.  
 <a href="class_pylon_1_1_c_pylon_image.html#details">More...</a></p>

<p><code>#include &lt;pylon/PylonImage.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Pylon::CPylonImage:</div>
<div class="dyncontent">
<div class="center"><img src="class_pylon_1_1_c_pylon_image__inherit__graph.png" border="0" usemap="#_pylon_1_1_c_pylon_image_inherit__map" alt="Inheritance graph"/></div>
<map name="_pylon_1_1_c_pylon_image_inherit__map" id="_pylon_1_1_c_pylon_image_inherit__map">
<area shape="rect" id="node2" href="class_pylon_1_1_c_pylon_image_base.html" title="Provides basic functionality for pylon image classes. " alt="" coords="5,155,177,181"/>
<area shape="rect" id="node3" href="struct_pylon_1_1_i_reusable_image.html" title="Extends the IImage interface to be able to reuse the image&#39;s resources to represent a different image..." alt="" coords="12,80,171,107"/>
<area shape="rect" id="node4" href="struct_pylon_1_1_i_image.html" title="Usable to access image properties and image buffer. " alt="" coords="40,5,143,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aecb46ef772304a287a627ba96f410a37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#aecb46ef772304a287a627ba96f410a37">CPylonImage</a> ()</td></tr>
<tr class="memdesc:aecb46ef772304a287a627ba96f410a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an invalid image.  <a href="#aecb46ef772304a287a627ba96f410a37">More...</a><br /></td></tr>
<tr class="separator:aecb46ef772304a287a627ba96f410a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e275391dfbb13da96e240acb84e6cdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a8e275391dfbb13da96e240acb84e6cdd">CPylonImage</a> (const <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a> &amp;source)</td></tr>
<tr class="memdesc:a8e275391dfbb13da96e240acb84e6cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the image properties and creates a reference to the buffer of the source image.  <a href="#a8e275391dfbb13da96e240acb84e6cdd">More...</a><br /></td></tr>
<tr class="separator:a8e275391dfbb13da96e240acb84e6cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bfc85bc6d54968700190acc7228d83"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a20bfc85bc6d54968700190acc7228d83">~CPylonImage</a> ()</td></tr>
<tr class="memdesc:a20bfc85bc6d54968700190acc7228d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a pylon image object.  <a href="#a20bfc85bc6d54968700190acc7228d83">More...</a><br /></td></tr>
<tr class="separator:a20bfc85bc6d54968700190acc7228d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccbc10251918387c31fb04f8500f48a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#acccbc10251918387c31fb04f8500f48a">operator=</a> (const <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a> &amp;source)</td></tr>
<tr class="memdesc:acccbc10251918387c31fb04f8500f48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the image properties and creates a reference to the buffer of the source image.  <a href="#acccbc10251918387c31fb04f8500f48a">More...</a><br /></td></tr>
<tr class="separator:acccbc10251918387c31fb04f8500f48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a4cf91476cc2ea8046e7cd1166b916"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a00a4cf91476cc2ea8046e7cd1166b916">CopyImage</a> (const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;image)</td></tr>
<tr class="memdesc:a00a4cf91476cc2ea8046e7cd1166b916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the image data from a different image.  <a href="#a00a4cf91476cc2ea8046e7cd1166b916">More...</a><br /></td></tr>
<tr class="separator:a00a4cf91476cc2ea8046e7cd1166b916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3637eb34de9fb8db6fa327c49210a0fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a3637eb34de9fb8db6fa327c49210a0fe">CopyImage</a> (const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;image, size_t newPaddingX)</td></tr>
<tr class="memdesc:a3637eb34de9fb8db6fa327c49210a0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the image data from a different image and changes the padding while copying.  <a href="#a3637eb34de9fb8db6fa327c49210a0fe">More...</a><br /></td></tr>
<tr class="separator:a3637eb34de9fb8db6fa327c49210a0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e19a23d246c352a8213cca5c54fb8b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a9e19a23d246c352a8213cca5c54fb8b5">CopyImage</a> (void *pBuffer, size_t bufferSizeBytes, <a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> pixelType, uint32_t width, uint32_t height, size_t paddingX, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> orientation=<a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a>)</td></tr>
<tr class="memdesc:a9e19a23d246c352a8213cca5c54fb8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the image data from a provided buffer.  <a href="#a9e19a23d246c352a8213cca5c54fb8b5">More...</a><br /></td></tr>
<tr class="separator:a9e19a23d246c352a8213cca5c54fb8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec6e7d1a7afccbbe55c73dedb5d0014"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a1ec6e7d1a7afccbbe55c73dedb5d0014">AttachGrabResultBufferWithUserHints</a> (const <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a> &amp;grabResult, <a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> pixelType, uint32_t width, uint32_t height, size_t paddingX, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> orientation=<a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a>)</td></tr>
<tr class="memdesc:a1ec6e7d1a7afccbbe55c73dedb5d0014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a grab result buffer using additional hints.  <a href="#a1ec6e7d1a7afccbbe55c73dedb5d0014">More...</a><br /></td></tr>
<tr class="separator:a1ec6e7d1a7afccbbe55c73dedb5d0014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc2a45eeaa8b2e7b3b9837f1a30c5b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a9ddc2a45eeaa8b2e7b3b9837f1a30c5b">AttachGrabResultBuffer</a> (const <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a> &amp;grabResult)</td></tr>
<tr class="memdesc:a9ddc2a45eeaa8b2e7b3b9837f1a30c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a grab result buffer.  <a href="#a9ddc2a45eeaa8b2e7b3b9837f1a30c5b">More...</a><br /></td></tr>
<tr class="separator:a9ddc2a45eeaa8b2e7b3b9837f1a30c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67baf1ca3232cbfb75e20a4238fca49a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a67baf1ca3232cbfb75e20a4238fca49a">AttachUserBuffer</a> (void *pBuffer, size_t bufferSizeBytes, <a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> pixelType, uint32_t width, uint32_t height, size_t paddingX, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> orientation=<a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a>)</td></tr>
<tr class="memdesc:a67baf1ca3232cbfb75e20a4238fca49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a user buffer.  <a href="#a67baf1ca3232cbfb75e20a4238fca49a">More...</a><br /></td></tr>
<tr class="separator:a67baf1ca3232cbfb75e20a4238fca49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab40430c31d24af39e49587eab4bab0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a9ab40430c31d24af39e49587eab4bab0">IsValid</a> () const </td></tr>
<tr class="memdesc:a9ab40430c31d24af39e49587eab4bab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to check whether an image is valid.  <a href="#a9ab40430c31d24af39e49587eab4bab0">More...</a><br /></td></tr>
<tr class="separator:a9ab40430c31d24af39e49587eab4bab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654b22ae664ce9e0ab14c1854e1b5ae7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a654b22ae664ce9e0ab14c1854e1b5ae7">GetPixelType</a> () const </td></tr>
<tr class="memdesc:a654b22ae664ce9e0ab14c1854e1b5ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current pixel type.  <a href="#a654b22ae664ce9e0ab14c1854e1b5ae7">More...</a><br /></td></tr>
<tr class="separator:a654b22ae664ce9e0ab14c1854e1b5ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c91921b4502697206c877ded8cd42cd"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a2c91921b4502697206c877ded8cd42cd">GetWidth</a> () const </td></tr>
<tr class="memdesc:a2c91921b4502697206c877ded8cd42cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of columns in pixels.  <a href="#a2c91921b4502697206c877ded8cd42cd">More...</a><br /></td></tr>
<tr class="separator:a2c91921b4502697206c877ded8cd42cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a28c115bd785ef5a0914cd8bd349b38"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a5a28c115bd785ef5a0914cd8bd349b38">GetHeight</a> () const </td></tr>
<tr class="memdesc:a5a28c115bd785ef5a0914cd8bd349b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of rows.  <a href="#a5a28c115bd785ef5a0914cd8bd349b38">More...</a><br /></td></tr>
<tr class="separator:a5a28c115bd785ef5a0914cd8bd349b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcf4e0c0785af11e5a836d2be1fa4af"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#aedcf4e0c0785af11e5a836d2be1fa4af">GetPaddingX</a> () const </td></tr>
<tr class="memdesc:aedcf4e0c0785af11e5a836d2be1fa4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of extra data bytes at the end of each row.  <a href="#aedcf4e0c0785af11e5a836d2be1fa4af">More...</a><br /></td></tr>
<tr class="separator:aedcf4e0c0785af11e5a836d2be1fa4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a53fa195f8de1f28cf31a518b9556c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a59a53fa195f8de1f28cf31a518b9556c">GetOrientation</a> () const </td></tr>
<tr class="memdesc:a59a53fa195f8de1f28cf31a518b9556c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertical orientation of the image in memory.  <a href="#a59a53fa195f8de1f28cf31a518b9556c">More...</a><br /></td></tr>
<tr class="separator:a59a53fa195f8de1f28cf31a518b9556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414d746b31c5b9b79d6fb61849f77ea"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a5414d746b31c5b9b79d6fb61849f77ea">GetBuffer</a> ()</td></tr>
<tr class="memdesc:a5414d746b31c5b9b79d6fb61849f77ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the buffer.  <a href="#a5414d746b31c5b9b79d6fb61849f77ea">More...</a><br /></td></tr>
<tr class="separator:a5414d746b31c5b9b79d6fb61849f77ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a35cd85f503dfce4051cc58bd4759"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a145a35cd85f503dfce4051cc58bd4759">GetBuffer</a> () const </td></tr>
<tr class="memdesc:a145a35cd85f503dfce4051cc58bd4759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the buffer containing the image.  <a href="#a145a35cd85f503dfce4051cc58bd4759">More...</a><br /></td></tr>
<tr class="separator:a145a35cd85f503dfce4051cc58bd4759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7288552affcf345c35be5cf5a507d50"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#af7288552affcf345c35be5cf5a507d50">GetImageSize</a> () const </td></tr>
<tr class="memdesc:af7288552affcf345c35be5cf5a507d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the image in bytes.  <a href="#af7288552affcf345c35be5cf5a507d50">More...</a><br /></td></tr>
<tr class="separator:af7288552affcf345c35be5cf5a507d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ad712f2d0dfd4c1d28d78409135ef6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a58ad712f2d0dfd4c1d28d78409135ef6">IsUnique</a> () const </td></tr>
<tr class="memdesc:a58ad712f2d0dfd4c1d28d78409135ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the referenced buffer is only referenced by this image.  <a href="#a58ad712f2d0dfd4c1d28d78409135ef6">More...</a><br /></td></tr>
<tr class="separator:a58ad712f2d0dfd4c1d28d78409135ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43d7fccd92d2e00d74eecef6a5c4af2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#af43d7fccd92d2e00d74eecef6a5c4af2">GetStride</a> (size_t &amp;strideBytes) const </td></tr>
<tr class="memdesc:af43d7fccd92d2e00d74eecef6a5c4af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stride in bytes.  <a href="#af43d7fccd92d2e00d74eecef6a5c4af2">More...</a><br /></td></tr>
<tr class="separator:af43d7fccd92d2e00d74eecef6a5c4af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc4a78afd065c613a5c7b1d84274b8b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#addc4a78afd065c613a5c7b1d84274b8b">IsSupportedPixelType</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> pixelType) const </td></tr>
<tr class="memdesc:addc4a78afd065c613a5c7b1d84274b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to check whether the pixel type is supported.  <a href="#addc4a78afd065c613a5c7b1d84274b8b">More...</a><br /></td></tr>
<tr class="separator:addc4a78afd065c613a5c7b1d84274b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de7573649c0a382a4040a4947e51dc9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a3de7573649c0a382a4040a4947e51dc9">IsAdditionalPaddingSupported</a> () const </td></tr>
<tr class="memdesc:a3de7573649c0a382a4040a4947e51dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to check whether the value of PaddingX can be defined by the user.  <a href="#a3de7573649c0a382a4040a4947e51dc9">More...</a><br /></td></tr>
<tr class="separator:a3de7573649c0a382a4040a4947e51dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebc34f672632902d160250baad044c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9">Reset</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> pixelType, uint32_t width, uint32_t height, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> orientation=<a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a>)</td></tr>
<tr class="memdesc:a7ebc34f672632902d160250baad044c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the image properties and allocates a new buffer if required.  <a href="#a7ebc34f672632902d160250baad044c9">More...</a><br /></td></tr>
<tr class="separator:a7ebc34f672632902d160250baad044c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330605847833bb8c023222c8b65305f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a330605847833bb8c023222c8b65305f6">Reset</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> pixelType, uint32_t width, uint32_t height, size_t paddingX, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> orientation=<a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a>)</td></tr>
<tr class="memdesc:a330605847833bb8c023222c8b65305f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset( EPixelType, uint32_t, uint32_t, EImageOrientation)</a> method by settable paddingX.  <a href="#a330605847833bb8c023222c8b65305f6">More...</a><br /></td></tr>
<tr class="separator:a330605847833bb8c023222c8b65305f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e80bb3083a3a62aa6e522b7e1cda4d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a7e80bb3083a3a62aa6e522b7e1cda4d9">Release</a> ()</td></tr>
<tr class="memdesc:a7e80bb3083a3a62aa6e522b7e1cda4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the image buffer and resets to an invalid image.  <a href="#a7e80bb3083a3a62aa6e522b7e1cda4d9">More...</a><br /></td></tr>
<tr class="separator:a7e80bb3083a3a62aa6e522b7e1cda4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc93a7c60b41df13d3c131a72eefc519"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc93a7c60b41df13d3c131a72eefc519"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#acc93a7c60b41df13d3c131a72eefc519">IsUserBufferAttached</a> () const </td></tr>
<tr class="memdesc:acc93a7c60b41df13d3c131a72eefc519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the referenced buffer has been provided by the user. <br /></td></tr>
<tr class="separator:acc93a7c60b41df13d3c131a72eefc519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312c778047d241822f5ed2e265c7ff35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312c778047d241822f5ed2e265c7ff35"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a312c778047d241822f5ed2e265c7ff35">IsGrabResultBufferAttached</a> () const </td></tr>
<tr class="memdesc:a312c778047d241822f5ed2e265c7ff35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the referenced buffer has been provided by a grab result. <br /></td></tr>
<tr class="separator:a312c778047d241822f5ed2e265c7ff35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04ceb442ec929f4ec2c7a43e358bbf3"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#af04ceb442ec929f4ec2c7a43e358bbf3">GetAllocatedBufferSize</a> () const </td></tr>
<tr class="memdesc:af04ceb442ec929f4ec2c7a43e358bbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the used buffer.  <a href="#af04ceb442ec929f4ec2c7a43e358bbf3">More...</a><br /></td></tr>
<tr class="separator:af04ceb442ec929f4ec2c7a43e358bbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f144c4fcc3676ce68a76fd288f4b94f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a6f144c4fcc3676ce68a76fd288f4b94f">ChangePixelType</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> pixelType)</td></tr>
<tr class="memdesc:a6f144c4fcc3676ce68a76fd288f4b94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the pixel type of the image.  <a href="#a6f144c4fcc3676ce68a76fd288f4b94f">More...</a><br /></td></tr>
<tr class="separator:a6f144c4fcc3676ce68a76fd288f4b94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750744d96585230d5bcab162a71404c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#a750744d96585230d5bcab162a71404c1">GetPlane</a> (size_t planeIndex) const </td></tr>
<tr class="memdesc:a750744d96585230d5bcab162a71404c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new pylon image for a plane of the image.  <a href="#a750744d96585230d5bcab162a71404c1">More...</a><br /></td></tr>
<tr class="separator:a750744d96585230d5bcab162a71404c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2feef6107750688a12f3c396c21ca7d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#ad2feef6107750688a12f3c396c21ca7d">GetAoi</a> (uint32_t topLeftX, uint32_t topLeftY, uint32_t width, uint32_t height) const </td></tr>
<tr class="memdesc:ad2feef6107750688a12f3c396c21ca7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new pylon image for an image area of interest (Image AOI) derived from the image.  <a href="#ad2feef6107750688a12f3c396c21ca7d">More...</a><br /></td></tr>
<tr class="separator:ad2feef6107750688a12f3c396c21ca7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ea36e435611e22913d822dd31adf26"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image_base.html#ae1ea36e435611e22913d822dd31adf26">Save</a> (<a class="el" href="group___pylon___image_handling_support.html#ga8bf3ed15161132846cd68070762ba2bd">EImageFileFormat</a> imageFileFormat, const <a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9">String_t</a> &amp;filename, <a class="el" href="class_pylon_1_1_c_image_persistence_options.html">CImagePersistenceOptions</a> *pOptions=NULL) const </td></tr>
<tr class="memdesc:ae1ea36e435611e22913d822dd31adf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the image to disk.  <a href="#ae1ea36e435611e22913d822dd31adf26">More...</a><br /></td></tr>
<tr class="separator:ae1ea36e435611e22913d822dd31adf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95aae72ac9ff4bf54dc8d5be8e7daf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image_base.html#a4c95aae72ac9ff4bf54dc8d5be8e7daf">Load</a> (const <a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9">String_t</a> &amp;filename)</td></tr>
<tr class="memdesc:a4c95aae72ac9ff4bf54dc8d5be8e7daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an image from a disk.  <a href="#a4c95aae72ac9ff4bf54dc8d5be8e7daf">More...</a><br /></td></tr>
<tr class="separator:a4c95aae72ac9ff4bf54dc8d5be8e7daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f247b680097fb56400c0d9831ba80bf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image_base.html#a0f247b680097fb56400c0d9831ba80bf">CanSaveWithoutConversion</a> (<a class="el" href="group___pylon___image_handling_support.html#ga8bf3ed15161132846cd68070762ba2bd">EImageFileFormat</a> imageFileFormat) const </td></tr>
<tr class="memdesc:a0f247b680097fb56400c0d9831ba80bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to check whether the image can be saved without prior conversion.  <a href="#a0f247b680097fb56400c0d9831ba80bf">More...</a><br /></td></tr>
<tr class="separator:a0f247b680097fb56400c0d9831ba80bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff77baf6d580431c6c72097f679e58b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_pylon_1_1_s_pixel_data.html">SPixelData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image_base.html#aff77baf6d580431c6c72097f679e58b3">GetPixelData</a> (uint32_t posX, uint32_t posY) const </td></tr>
<tr class="memdesc:aff77baf6d580431c6c72097f679e58b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the data of a pixel.  <a href="#aff77baf6d580431c6c72097f679e58b3">More...</a><br /></td></tr>
<tr class="separator:aff77baf6d580431c6c72097f679e58b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa7c78d9b78895cc86291fd8c7e4d0e6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html#aa7c78d9b78895cc86291fd8c7e4d0e6e">Create</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> pixelType, uint32_t width, uint32_t height, size_t paddingX=0, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> orientation=<a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a>)</td></tr>
<tr class="memdesc:aa7c78d9b78895cc86291fd8c7e4d0e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an image and allocates a buffer for it.  <a href="#aa7c78d9b78895cc86291fd8c7e4d0e6e">More...</a><br /></td></tr>
<tr class="separator:aa7c78d9b78895cc86291fd8c7e4d0e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes an image. </p>
<ul>
<li>
Automatically handles size and lifetime of the image buffer. </li>
<li>
Allows to take over a buffer of grab result which is preventing its reuse as long as required. </li>
<li>
Allows to connect user buffers or buffers provided by third party software packages. </li>
<li>
Provides methods for loading and saving an image in different file formats. </li>
<li>
Serves as the main target format for the image format converter <code><a class="el" href="class_pylon_1_1_c_image_format_converter.html" title="Creates new images by converting a source image to another format. ">CImageFormatConverter</a></code>. </li>
<li>
Eases working with planar images. </li>
<li>
Eases extraction of AOIs, e.g. for thumbnail images of defects. </li>
</ul>
<dl class="section user"><dt>Buffer Handling:</dt><dd>The buffer that is automatically created by the <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a> class or a hosted grab result buffer are replaced by a larger buffer if required. The size of the allocated buffer is never decreased. Referenced user buffers are never automatically replaced by a larger buffer. Referenced grab result buffers are never reused. See the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method for more details. The <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7e80bb3083a3a62aa6e522b7e1cda4d9" title="Releases the image buffer and resets to an invalid image. ">Release()</a> method can be used to detach a user buffer, release a hosted grab result buffer or to free an allocated buffer.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>The <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a> class is not thread-safe. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aecb46ef772304a287a627ba96f410a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pylon::CPylonImage::CPylonImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an invalid image. </p>
<p>See <a class="el" href="struct_pylon_1_1_i_image.html" title="Usable to access image properties and image buffer. ">Pylon::IImage</a> on how the properties of an invalid image are returned.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e275391dfbb13da96e240acb84e6cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pylon::CPylonImage::CPylonImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the image properties and creates a reference to the buffer of the source image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The source image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
Another reference to the source image buffer is created. </li>
<li>
Creates an invalid image if the source image is invalid. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a20bfc85bc6d54968700190acc7228d83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Pylon::CPylonImage::~CPylonImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a pylon image object. </p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9ddc2a45eeaa8b2e7b3b9837f1a30c5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::AttachGrabResultBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>grabResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a grab result buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grabResult</td><td>The source image represented by a grab result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The image properties are taken from the grab result. </li>
<li>
The grab result buffer is used by the image class. </li>
<li>
Another reference to the grab result buffer is created. This prevents the buffer's reuse for grabbing. </li>
<li>
Creates an invalid image if the <code>grabResult</code> is invalid. </li>
<li>
Creates an invalid image if the grab was not successful. See <a class="el" href="class_pylon_1_1_c_grab_result_data.html#a57fbc04cd2abf3bf6307e07131dd0503" title="Returns true if an image has been grabbed successfully and false in the case of an error...">CGrabResultData::GrabSucceeded()</a>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when no buffer with the required size could be allocated. Throws an exception when the preconditions of the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ec6e7d1a7afccbbe55c73dedb5d0014"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::AttachGrabResultBufferWithUserHints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>grabResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>paddingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a grab result buffer using additional hints. </p>
<p>This allows to display grabbed data in a user-defined way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grabResult</td><td>The source buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The number of rows in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paddingX</td><td>The number of extra data bytes at the end of each row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The vertical orientation of the image in the image buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The <code>grabResult</code> must be valid. </li>
<li>
The <code>pixelType</code> must be valid. </li>
<li>
The <code>width</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The <code>height</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The image properties are taken from the <code>width</code>, <code>height</code>, <code>pixelType</code>, <code>paddingX</code> and <code>orientation</code> parameters. </li>
<li>
The grab result buffer is used by the image class. </li>
<li>
Another reference to the grab result buffer is created. This prevents the buffer's reuse for grabbing. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met. Throws an exception if the buffer size of the grabresult is too small for an image with the given parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a67baf1ca3232cbfb75e20a4238fca49a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::AttachUserBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>paddingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a user buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>The pointer to the buffer of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSizeBytes</td><td>The size of the buffer of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The number of rows in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paddingX</td><td>The number of extra data bytes at the end of each row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The vertical orientation of the image in the image buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The pixel type must be valid. </li>
<li>
The <code>width</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The <code>height</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The pointer to the source buffer must not be NULL. </li>
<li>
The source buffer must be large enough to hold the image described by the parameters. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The image properties are taken from the passed parameters. </li>
<li>
The user buffer is used by the image class. </li>
<li>
The buffer must not be freed while being attached. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f247b680097fb56400c0d9831ba80bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CPylonImageBase::CanSaveWithoutConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga8bf3ed15161132846cd68070762ba2bd">EImageFileFormat</a>&#160;</td>
          <td class="paramname"><em>imageFileFormat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to check whether the image can be saved without prior conversion. </p>
<p>This is a convenience method that calls <a class="el" href="class_pylon_1_1_c_image_persistence.html#a01a7ee0507d68216cd97db758e933a51" title="Can be used to check whether the given image can be saved without prior conversion. ">CImagePersistence::CanSaveWithoutConversion()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imageFileFormat</td><td>Target file format for the image to be saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true, if the image can be saved without prior conversion.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f144c4fcc3676ce68a76fd288f4b94f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::ChangePixelType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the pixel type of the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The new pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
Pylon::SamplesPerPixel( oldPixelType) == Pylon::SamplesPerPixel( newPixelType) </li>
<li>
Pylon::BitPerPixel( oldPixelType) == Pylon::BitPerPixel( newPixelType) </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the new pixel type properties do not match the existing ones. </dd></dl>

</div>
</div>
<a class="anchor" id="a00a4cf91476cc2ea8046e7cd1166b916"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::CopyImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the image data from a different image. </p>
<p>This method is used for making a full copy of an image. Calls the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method to set the same image properties as the source image and copies the image data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image, e.g. a <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a>, CPylonBitmapImage, or Grab Result Smart Pointer object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method must be met.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The image contains a copy of the image data contained by the source image. </li>
<li>
Creates an invalid image if the source image is invalid. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when no buffer with the required size could be allocated. Throws an exception when the preconditions of the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="a3637eb34de9fb8db6fa327c49210a0fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::CopyImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newPaddingX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the image data from a different image and changes the padding while copying. </p>
<p>This method is used for making a full copy of an image except for changing the padding. Calls the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method to set the same image properties as the source image and copies the image data. This method is useful in combination with the <a class="el" href="class_pylon_1_1_c_pylon_image.html#ad2feef6107750688a12f3c396c21ca7d" title="Creates a new pylon image for an image area of interest (Image AOI) derived from the image...">GetAoi()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image, e.g. a <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a>, CPylonBitmapImage, or Grab Result Smart Pointer object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPaddingX</td><td>The number of extra data bytes at the end of each row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The preconditions of the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method must be met. </li>
<li>
The rows of the source image must be byte aligned. This may not be the case for packed pixel types. See <a class="el" href="group___pylon___image_handling_support.html#gaa34f72b29074831f40a685c3da18776c" title="Returns true if the pixels of the given pixel type are not byte aligned. ">Pylon::IsPacked()</a>. </li>
<li>
The rows of the newly created image must be byte aligned. This may not be the case for packed pixel types. See <a class="el" href="group___pylon___image_handling_support.html#gaa34f72b29074831f40a685c3da18776c" title="Returns true if the pixels of the given pixel type are not byte aligned. ">Pylon::IsPacked()</a>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The image contains a copy of the image data contained by the source image. </li>
<li>
The line padding is adjusted. </li>
<li>
The byte aligned row padding area is set to zero. </li>
<li>
Creates an invalid image if the source image is invalid. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when no buffer with the required size could be allocated. Throws an exception when the preconditions of the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e19a23d246c352a8213cca5c54fb8b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::CopyImage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>paddingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the image data from a provided buffer. </p>
<p>This method is used for making a full copy of an image. Calls the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method to set the same image properties as the source image and copies the image data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>The pointer to the buffer of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSizeBytes</td><td>The size of the buffer of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The number of rows in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paddingX</td><td>The number of extra data bytes at the end of each row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The vertical orientation of the image in the image buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The pixel type must be valid. </li>
<li>
The <code>width</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The <code>height</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The pointer to the source buffer must not be NULL. </li>
<li>
The source buffer must be large enough to hold the image described by the parameters. </li>
<li>
The preconditions of the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method must be met. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A copy of the image contained by the source image buffer is made.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when no buffer with the required size could be allocated. Throws an exception when the preconditions of the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset()</a> method are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7c78d9b78895cc86291fd8c7e4d0e6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a> Pylon::CPylonImage::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>paddingX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an image and allocates a buffer for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type of the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row in the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The number of rows in the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paddingX</td><td>The number of extra data bytes at the end of each row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The vertical orientation of the image in the image buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The pixel type must be valid. </li>
<li>
The <code>width</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The <code>height</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the parameters are invalid. Throws an exception when no buffer with the required size could be allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="af04ceb442ec929f4ec2c7a43e358bbf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Pylon::CPylonImage::GetAllocatedBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the used buffer. </p>
<p>This method is useful when working with so-called user buffers.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2feef6107750688a12f3c396c21ca7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a> Pylon::CPylonImage::GetAoi </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>topLeftX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>topLeftY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new pylon image for an image area of interest (Image AOI) derived from the image. </p>
<p>No image data is copied.</p>
<p>Use <a class="el" href="class_pylon_1_1_c_pylon_image.html#a3637eb34de9fb8db6fa327c49210a0fe" title="Copies the image data from a different image and changes the padding while copying. ">CopyImage( const IImage&amp; image, size_t newPaddingX)</a> to create a full copy and to remove the additional padding.</p>
<div class="fragment"><div class="line">copiedAoi.CopyImage( image.GetAoi( 80, 90, 100, 100), 0);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topLeftX</td><td>The x-coordinate of the top left corner of the image AOI in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topLeftY</td><td>The y-coordinate of the top left corner of the image AOI in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the image AOI in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the image AOI in pixels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pylon image referencing an image AOI of the image.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The image must be valid. </li>
<li>
The image AOI is located inside the image. </li>
<li>
The image is not in a planar format, see <a class="el" href="group___pylon___image_handling_support.html#ga708cb9771247c5093a3f96df67d5abb3" title="Returns true if images of the pixel type are divided into multiple planes. ">Pylon::IsPlanar()</a>. Use <a class="el" href="class_pylon_1_1_c_pylon_image.html#a750744d96585230d5bcab162a71404c1" title="Creates a new pylon image for a plane of the image. ">GetPlane()</a> first in this case. </li>
<li>
The rows of the image must be byte aligned. This may not be the case for packed pixel types. See <a class="el" href="group___pylon___image_handling_support.html#gaa34f72b29074831f40a685c3da18776c" title="Returns true if the pixels of the given pixel type are not byte aligned. ">Pylon::IsPacked()</a>. </li>
<li>
The x-coordinate must be byte aligned. This may not be the case for packed pixel types. See <a class="el" href="group___pylon___image_handling_support.html#gaa34f72b29074831f40a685c3da18776c" title="Returns true if the pixels of the given pixel type are not byte aligned. ">Pylon::IsPacked()</a>. </li>
<li>
The <code>topLeftX</code> parameter must be divisible by the return value of <a class="el" href="group___pylon___image_handling_support.html#gacb1f7b3c87b99ad5e92ef1ce6d7db0a2" title="Returns the minimum step size expressed in pixels for extracting an AOI. ">Pylon::GetPixelIncrementX()</a> for the image's pixel type. </li>
<li>
The <code>topLeftY</code> parameter must be divisible by the return value of <a class="el" href="group___pylon___image_handling_support.html#ga21ef2101cdd62450eadc7c08f21a5df2" title="Returns the minimum step size expressed in pixels for extracting an AOI. ">Pylon::GetPixelIncrementY()</a> for the image's pixel type. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
A reference to the same buffer is created. The image data is not copied. </li>
<li>
The returned image uses the paddingX property to skip over image content outside of the image AOI. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the preconditions are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="a5414d746b31c5b9b79d6fb61849f77ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* Pylon::CPylonImage::GetBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pointer to the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the used buffer or NULL if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#acaa38a434f7af02fa66152b1896a70e1">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="a145a35cd85f503dfce4051cc58bd4759"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* Pylon::CPylonImage::GetBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pointer to the buffer containing the image. </p>
<p>The buffer is at least as large as the value returned by <a class="el" href="class_pylon_1_1_c_pylon_image.html#af7288552affcf345c35be5cf5a507d50" title="Get the size of the image in bytes. ">GetImageSize()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the used buffer or NULL if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#af308e4b1acb73d82d66f73f4d7206cc4">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="a5a28c115bd785ef5a0914cd8bd349b38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t Pylon::CPylonImage::GetHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current number of rows. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current number of rows or 0 if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#ac9be055f4fc62ab9f77d5c7e46ddcfa5">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="af7288552affcf345c35be5cf5a507d50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Pylon::CPylonImage::GetImageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the image in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the image in bytes or 0 if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#adc15c54596375660034b4c1343964ee1">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="a59a53fa195f8de1f28cf31a518b9556c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> Pylon::CPylonImage::GetOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vertical orientation of the image in memory. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the orientation of the image or ImageOrientation_TopDown if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#a73921c22784b7fd151bad217abedf49f">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="aedcf4e0c0785af11e5a836d2be1fa4af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Pylon::CPylonImage::GetPaddingX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of extra data bytes at the end of each row. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of extra data bytes at the end of each row or 0 if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#a5d6eb51bfd0af8d0f3be350c48df6768">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="aff77baf6d580431c6c72097f679e58b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_pylon_1_1_s_pixel_data.html">SPixelData</a> Pylon::CPylonImageBase::GetPixelData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>posY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the data of a pixel. </p>
<dl class="section note"><dt>Note</dt><dd>This method is relativly slow. Do not use it for image processing tasks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">posX</td><td>Horizontal position of the pixel. The first column has position 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">posY</td><td>Vertical position of the pixel. The first row has position 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the data of a pixel for supported pixel types. For unsupported pixel types pixel data of the <a class="el" href="struct_pylon_1_1_s_pixel_data.html#a420afd607cef8a5eb5465614096115c9a0bb655358f25d2fa4a93970a17dbb2f3" title="Will be returned, if the pixel data cannot be determined. ">SPixelData::PixelDataType_Unknown</a> type is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The image must be valid. </li>
<li>
The pixel position defined by <code>posX</code> and <code>posY</code> must be located inside the image area. </li>
</ul>
</dd></dl>
<p>Supported pixel types: </p><ul>
<li>
PixelType_Mono1packed </li>
<li>
PixelType_Mono2packed </li>
<li>
PixelType_Mono4packed </li>
<li>
PixelType_Mono8 </li>
<li>
PixelType_Mono8signed </li>
<li>
PixelType_Mono10 </li>
<li>
PixelType_Mono10packed </li>
<li>
PixelType_Mono10p </li>
<li>
PixelType_Mono12 </li>
<li>
PixelType_Mono12packed </li>
<li>
PixelType_Mono12p </li>
<li>
PixelType_Mono16 </li>
</ul>
<ul>
<li>
PixelType_BayerGR8 </li>
<li>
PixelType_BayerRG8 </li>
<li>
PixelType_BayerGB8 </li>
<li>
PixelType_BayerBG8 </li>
<li>
PixelType_BayerGR10 </li>
<li>
PixelType_BayerRG10 </li>
<li>
PixelType_BayerGB10 </li>
<li>
PixelType_BayerBG10 </li>
<li>
PixelType_BayerGR12 </li>
<li>
PixelType_BayerRG12 </li>
<li>
PixelType_BayerGB12 </li>
<li>
PixelType_BayerBG12 </li>
<li>
PixelType_BayerGR12Packed </li>
<li>
PixelType_BayerRG12Packed </li>
<li>
PixelType_BayerGB12Packed </li>
<li>
PixelType_BayerBG12Packed </li>
<li>
PixelType_BayerGR10p </li>
<li>
PixelType_BayerRG10p </li>
<li>
PixelType_BayerGB10p </li>
<li>
PixelType_BayerBG10p </li>
<li>
PixelType_BayerGR12p </li>
<li>
PixelType_BayerRG12p </li>
<li>
PixelType_BayerGB12p </li>
<li>
PixelType_BayerBG12p </li>
<li>
PixelType_BayerGR16 </li>
<li>
PixelType_BayerRG16 </li>
<li>
PixelType_BayerGB16 </li>
<li>
PixelType_BayerBG16 </li>
</ul>
<ul>
<li>
PixelType_RGB8packed </li>
<li>
PixelType_BGR8packed </li>
<li>
PixelType_RGBA8packed </li>
<li>
PixelType_BGRA8packed </li>
<li>
PixelType_RGB10packed </li>
<li>
PixelType_BGR10packed </li>
<li>
PixelType_RGB12packed </li>
<li>
PixelType_BGR12packed </li>
<li>
PixelType_RGB12V1packed </li>
<li>
PixelType_RGB16packed </li>
<li>
PixelType_RGB8planar </li>
<li>
PixelType_RGB10planar </li>
<li>
PixelType_RGB12planar </li>
<li>
PixelType_RGB16planar </li>
</ul>
<ul>
<li>
PixelType_YUV422packed </li>
<li>
PixelType_YUV422_YUYV_Packed </li>
</ul>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception, if the preconditions are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="a654b22ae664ce9e0ab14c1854e1b5ae7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> Pylon::CPylonImage::GetPixelType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current pixel type. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pixel type or PixelType_Undefined if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#a853df54bfdda234ca8fd6ff17070e9fa">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="a750744d96585230d5bcab162a71404c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a> Pylon::CPylonImage::GetPlane </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>planeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new pylon image for a plane of the image. </p>
<p>No image data is copied.</p>
<p>Use <a class="el" href="class_pylon_1_1_c_pylon_image.html#a00a4cf91476cc2ea8046e7cd1166b916" title="Copies the image data from a different image. ">CopyImage( const IImage&amp; image)</a> to create a full copy.</p>
<div class="fragment"><div class="line">copiedPlane.CopyImage( planarImage.GetPlane( 2));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planeIndex</td><td>The zero based index of the plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pylon image referencing a plane of the image.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The value of planeIndex &lt; Pylon::PlaneCount( GetPixelType()).</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
A reference to the same buffer is created. No image data is copied. </li>
<li>
The returned image has the Pylon::GetPlanePixelType( GetPixelType()) pixel type. </li>
<li>
If the image is not planar only index 0 is allowed. A call passing index 0 returns a copy of the image. No image data is copied. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the plane index is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="af43d7fccd92d2e00d74eecef6a5c4af2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CPylonImage::GetStride </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>strideBytes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stride in bytes. </p>
<p>The stride in bytes can not be computed for packed image format when the stride is not byte aligned. See also <a class="el" href="group___pylon___image_handling_support.html#gaa34f72b29074831f40a685c3da18776c" title="Returns true if the pixels of the given pixel type are not byte aligned. ">Pylon::IsPacked()</a>. The stride in bytes can not be computed if the image is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">strideBytes</td><td>The stride in byte if it can be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the stride can be computed.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#a3bfa5e117e55d240c010924a54944bab">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="a2c91921b4502697206c877ded8cd42cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t Pylon::CPylonImage::GetWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current number of columns in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current number of columns in pixels or 0 if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#a22fbbcca00d1a61937c993c08f39fe2f">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="a3de7573649c0a382a4040a4947e51dc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CPylonImage::IsAdditionalPaddingSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to check whether the value of PaddingX can be defined by the user. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the value of PaddingX can be defined by the user.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_reusable_image.html#ab168b1c119ddc278b2a4a37e63fc29bf">Pylon::IReusableImage</a>.</p>

</div>
</div>
<a class="anchor" id="addc4a78afd065c613a5c7b1d84274b8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CPylonImage::IsSupportedPixelType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to check whether the pixel type is supported. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the pixel type is supported.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_reusable_image.html#a185fef62406bb39a94c048b9a9d967b9">Pylon::IReusableImage</a>.</p>

</div>
</div>
<a class="anchor" id="a58ad712f2d0dfd4c1d28d78409135ef6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CPylonImage::IsUnique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that the referenced buffer is only referenced by this image. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the referenced buffer is only referenced by this image. Returns false if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#a62ecccd30065657a1ae1f1eb237d4122">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab40430c31d24af39e49587eab4bab0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CPylonImage::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to check whether an image is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns false if the image is invalid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_image.html#a72b89a2c4cc21527acbea2b0e04b0563">Pylon::IImage</a>.</p>

</div>
</div>
<a class="anchor" id="a4c95aae72ac9ff4bf54dc8d5be8e7daf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImageBase::Load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9">String_t</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads an image from a disk. </p>
<p>This is a convenience method that calls <a class="el" href="class_pylon_1_1_c_image_persistence.html#a788383f8c5747eb4c85c8259dfe6ad99" title="Loads an image from disk. ">CImagePersistence::Load()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name and path of the image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The image object must be able to hold the image format of the loaded image.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the image cannot be loaded. The image buffer content is undefined when the loading of the image fails. </dd></dl>

</div>
</div>
<a class="anchor" id="acccbc10251918387c31fb04f8500f48a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a>&amp; Pylon::CPylonImage::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pylon_1_1_c_pylon_image.html">CPylonImage</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the image properties and creates a reference to the buffer of the source image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The source image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
Another reference to the source image buffer is created. </li>
<li>
Creates an invalid image if the source image is invalid. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e80bb3083a3a62aa6e522b7e1cda4d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::Release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the image buffer and resets to an invalid image. </p>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
PixelType = PixelType_Undefined. </li>
<li>
Width = 0. </li>
<li>
Height = 0. </li>
<li>
PaddingX = 0. </li>
<li>
No buffer is allocated. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_reusable_image.html#ac31abfb75e1726dc0ab6a15703edb248">Pylon::IReusableImage</a>.</p>

</div>
</div>
<a class="anchor" id="a7ebc34f672632902d160250baad044c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the image properties and allocates a new buffer if required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type of the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row in the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The number of rows in the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The vertical orientation of the image in the image buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The <code>width</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The <code>height</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
If a user buffer is referenced then this buffer must not be referenced by another pylon image. See the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a58ad712f2d0dfd4c1d28d78409135ef6" title="Indicates that the referenced buffer is only referenced by this image. ">IsUnique()</a> and <a class="el" href="class_pylon_1_1_c_pylon_image.html#acc93a7c60b41df13d3c131a72eefc519" title="Returns true if the referenced buffer has been provided by the user. ">IsUserBufferAttached()</a> methods. </li>
<li>
If a user buffer is referenced then this buffer must be large enough to hold the destination image. See the <a class="el" href="class_pylon_1_1_c_pylon_image.html#af04ceb442ec929f4ec2c7a43e358bbf3" title="Returns the size of the used buffer. ">GetAllocatedBufferSize()</a> and <a class="el" href="class_pylon_1_1_c_pylon_image.html#acc93a7c60b41df13d3c131a72eefc519" title="Returns true if the referenced buffer has been provided by the user. ">IsUserBufferAttached()</a> methods. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If the previously referenced buffer is a grab result buffer, a new buffer has been allocated. </li>
<li>
If the previously referenced buffer is also referenced by another pylon image, a new buffer has been allocated. </li>
<li>
If the previously referenced buffer is not large enough to hold an image with the given properties, a new buffer has been allocated. </li>
<li>
If no buffer has been allocated before, a buffer has been allocated. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the preconditions are not met. Throws an exception when no buffer with the required size could be allocated. </dd></dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_reusable_image.html#a2c7c0b9af92bf529e352e745b91ba2da">Pylon::IReusableImage</a>.</p>

</div>
</div>
<a class="anchor" id="a330605847833bb8c023222c8b65305f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImage::Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>paddingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="group___pylon___image_handling_support.html#gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95">ImageOrientation_TopDown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a7ebc34f672632902d160250baad044c9" title="Resets the image properties and allocates a new buffer if required. ">Reset( EPixelType, uint32_t, uint32_t, EImageOrientation)</a> method by settable paddingX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type of the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row in the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The number of rows in the new image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The vertical orientation of the image in the image buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The <code>width</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The <code>height</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
If a user buffer is referenced then this buffer must not be referenced by another pylon image. See the <a class="el" href="class_pylon_1_1_c_pylon_image.html#a58ad712f2d0dfd4c1d28d78409135ef6" title="Indicates that the referenced buffer is only referenced by this image. ">IsUnique()</a> and <a class="el" href="class_pylon_1_1_c_pylon_image.html#acc93a7c60b41df13d3c131a72eefc519" title="Returns true if the referenced buffer has been provided by the user. ">IsUserBufferAttached()</a> methods. </li>
<li>
If a user buffer is referenced then this buffer must be large enough to hold the destination image. See the <a class="el" href="class_pylon_1_1_c_pylon_image.html#af04ceb442ec929f4ec2c7a43e358bbf3" title="Returns the size of the used buffer. ">GetAllocatedBufferSize()</a> and <a class="el" href="class_pylon_1_1_c_pylon_image.html#acc93a7c60b41df13d3c131a72eefc519" title="Returns true if the referenced buffer has been provided by the user. ">IsUserBufferAttached()</a> methods. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If the previously referenced buffer is a grab result buffer, a new buffer has been allocated. </li>
<li>
If the previously referenced buffer is also referenced by another pylon image, a new buffer has been allocated. </li>
<li>
If the previously referenced buffer is not large enough to hold an image with the given properties, a new buffer has been allocated. </li>
<li>
If no buffer has been allocated before, a buffer has been allocated. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the preconditions are not met. Throws an exception when no buffer with the required size could be allocated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paddingX</td><td>The number of extra data bytes at the end of each row. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="struct_pylon_1_1_i_reusable_image.html#a9cade97c710044c018977d13b774b6ff">Pylon::IReusableImage</a>.</p>

</div>
</div>
<a class="anchor" id="ae1ea36e435611e22913d822dd31adf26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CPylonImageBase::Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga8bf3ed15161132846cd68070762ba2bd">EImageFileFormat</a>&#160;</td>
          <td class="paramname"><em>imageFileFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9">String_t</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_image_persistence_options.html">CImagePersistenceOptions</a> *&#160;</td>
          <td class="paramname"><em>pOptions</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the image to disk. </p>
<p>Converts the image to a format that can be saved if required.</p>
<p>This is a convenience method that calls <a class="el" href="class_pylon_1_1_c_image_persistence.html#a7d3176eb5beed8ed333495615d4a4974" title="Saves the image to disk. ">CImagePersistence::Save()</a>.</p>
<p>If required, the image is automatically converted into a new image and saved afterwards. See <a class="el" href="class_pylon_1_1_c_image_persistence.html#a01a7ee0507d68216cd97db758e933a51" title="Can be used to check whether the given image can be saved without prior conversion. ">CImagePersistence::CanSaveWithoutConversion()</a> for more information. An image with a bit depth higher than 8 bit is stored with 16 bit bit depth, if supported by the image file format. In this case the pixel data is MSB aligned.</p>
<p>If more control over the conversion is required, the <a class="el" href="class_pylon_1_1_c_image_format_converter.html" title="Creates new images by converting a source image to another format. ">CImageFormatConverter</a> class can be used to convert the input image before saving it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imageFileFormat</td><td>File format to save the image in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name and path of the image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pOptions</td><td>Additional options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The pixel type of the image to be saved must be a supported input format of the <a class="el" href="class_pylon_1_1_c_image_format_converter.html" title="Creates new images by converting a source image to another format. ">Pylon::CImageFormatConverter</a>.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the saving of the image fails. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pylon/<a class="el" href="_pylon_image_8h.html">PylonImage.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="projectname">pylon <span id="projectnumber">6.1.0</span></div>
<address><small>Copyright (c) 2006-2020 <a href="http://www.baslerweb.com/">Basler AG</a>   (Mon Mar 16 2020 10:57:00)</small></address>
</body>
</html>
