<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_pylon.html">Pylon</a></li><li class="navelem"><a class="el" href="class_pylon_1_1_c_instant_camera.html">CInstantCamera</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_pylon_1_1_c_instant_camera-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pylon::CInstantCamera Class Reference<div class="ingroups"><a class="el" href="group___pylon___instant_camera_api_generic.html">Instant Camera</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides convenient access to a camera device.  
 <a href="class_pylon_1_1_c_instant_camera.html#details">More...</a></p>

<p><code>#include &lt;pylon/InstantCamera.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Pylon::CInstantCamera:</div>
<div class="dyncontent">
<div class="center"><img src="class_pylon_1_1_c_instant_camera__inherit__graph.png" border="0" usemap="#_pylon_1_1_c_instant_camera_inherit__map" alt="Inheritance graph"/></div>
<map name="_pylon_1_1_c_instant_camera_inherit__map" id="_pylon_1_1_c_instant_camera_inherit__map">
<area shape="rect" id="node4" href="class_pylon_1_1_c_device_specific_instant_camera_t.html" title="Pylon::CDeviceSpecificInstant\lCameraT\&lt; CBaslerUniversalInstant\lCameraTraits \&gt;" alt="" coords="803,5,1033,61"/>
<area shape="rect" id="node6" href="class_pylon_1_1_c_device_specific_instant_camera_t.html" title="Implementation Detail: Header only implementation class for creating device specific Instant Camera c..." alt="" coords="817,85,1019,126"/>
<area shape="rect" id="node2" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params.html" title="A parameter class containing all parameters as members that are available for Instant Camera..." alt="" coords="325,49,548,90"/>
<area shape="rect" id="node3" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html" title="A parameter class containing all parameters as members that are available for Instant Camera..." alt="" coords="5,49,277,90"/>
<area shape="rect" id="node5" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types..." alt="" coords="1081,13,1287,54"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2a00877001a19ced2ba4b44ae3cca755"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a00877001a19ced2ba4b44ae3cca755"></a>
typedef <a class="el" href="class_pylon_1_1_c_instant_camera.html">CInstantCamera</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a2a00877001a19ced2ba4b44ae3cca755">InstantCamera_t</a></td></tr>
<tr class="memdesc:a2a00877001a19ced2ba4b44ae3cca755"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the camera class. <br /></td></tr>
<tr class="separator:a2a00877001a19ced2ba4b44ae3cca755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e84dd2728e99840062c68d6d9d388d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e84dd2728e99840062c68d6d9d388d8"></a>
typedef <a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a8e84dd2728e99840062c68d6d9d388d8">IPylonDevice_t</a></td></tr>
<tr class="memdesc:a8e84dd2728e99840062c68d6d9d388d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low Level API: Interface for camera objects. <br /></td></tr>
<tr class="separator:a8e84dd2728e99840062c68d6d9d388d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771a7421194ac77f6a7bb4f454dae9b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a771a7421194ac77f6a7bb4f454dae9b6"></a>
typedef <a class="el" href="class_pylon_1_1_c_device_info.html">Pylon::CDeviceInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a771a7421194ac77f6a7bb4f454dae9b6">DeviceInfo_t</a></td></tr>
<tr class="memdesc:a771a7421194ac77f6a7bb4f454dae9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds information about an enumerated device. <br /></td></tr>
<tr class="separator:a771a7421194ac77f6a7bb4f454dae9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154a6adf5c14dd0745d1c79499efbfe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a154a6adf5c14dd0745d1c79499efbfe8"></a>
typedef <a class="el" href="class_pylon_1_1_c_configuration_event_handler.html">CConfigurationEventHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a154a6adf5c14dd0745d1c79499efbfe8">ConfigurationEventHandler_t</a></td></tr>
<tr class="memdesc:a154a6adf5c14dd0745d1c79499efbfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic configuration event handler class. <br /></td></tr>
<tr class="separator:a154a6adf5c14dd0745d1c79499efbfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae516857330f1d76c65d9d074b7a4ce3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae516857330f1d76c65d9d074b7a4ce3f"></a>
typedef <a class="el" href="class_pylon_1_1_c_image_event_handler.html">CImageEventHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#ae516857330f1d76c65d9d074b7a4ce3f">ImageEventHandler_t</a></td></tr>
<tr class="memdesc:ae516857330f1d76c65d9d074b7a4ce3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic image event handler class. <br /></td></tr>
<tr class="separator:ae516857330f1d76c65d9d074b7a4ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920360ed320e047ed95c6506580f6448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a920360ed320e047ed95c6506580f6448"></a>
typedef <a class="el" href="class_pylon_1_1_c_camera_event_handler.html">CCameraEventHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a920360ed320e047ed95c6506580f6448">CameraEventHandler_t</a></td></tr>
<tr class="memdesc:a920360ed320e047ed95c6506580f6448"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic image event handler class. <br /></td></tr>
<tr class="separator:a920360ed320e047ed95c6506580f6448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab6de0d66612dabf1fc403da843c0e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ab6de0d66612dabf1fc403da843c0e4"></a>
typedef <a class="el" href="class_pylon_1_1_c_grab_result_data.html">CGrabResultData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a4ab6de0d66612dabf1fc403da843c0e4">GrabResultData_t</a></td></tr>
<tr class="memdesc:a4ab6de0d66612dabf1fc403da843c0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic grab result data. <br /></td></tr>
<tr class="separator:a4ab6de0d66612dabf1fc403da843c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe35ad5e4d2dd6767f1e1a3626ca2dfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe35ad5e4d2dd6767f1e1a3626ca2dfa"></a>
typedef <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#afe35ad5e4d2dd6767f1e1a3626ca2dfa">GrabResultPtr_t</a></td></tr>
<tr class="memdesc:afe35ad5e4d2dd6767f1e1a3626ca2dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic grab result smart pointer. <br /></td></tr>
<tr class="separator:afe35ad5e4d2dd6767f1e1a3626ca2dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7049f927ffeb878aa532abfa3f9807d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#ae7049f927ffeb878aa532abfa3f9807d">CInstantCamera</a> ()</td></tr>
<tr class="memdesc:ae7049f927ffeb878aa532abfa3f9807d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an Instant Camera object with no attached Pylon device.  <a href="#ae7049f927ffeb878aa532abfa3f9807d">More...</a><br /></td></tr>
<tr class="separator:ae7049f927ffeb878aa532abfa3f9807d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaf7efc69ecde02db4acfd20c6b4d31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a7aaf7efc69ecde02db4acfd20c6b4d31">CInstantCamera</a> (<a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a> *pDevice, <a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a> cleanupProcedure=<a class="el" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>)</td></tr>
<tr class="memdesc:a7aaf7efc69ecde02db4acfd20c6b4d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an Instant Camera object and calls <a class="el" href="class_pylon_1_1_c_instant_camera.html#a9e04a31ff55e3c570e05a249edefb7c0" title="Attaches a Pylon device to the Instant Camera. ">Attach()</a>.  <a href="#a7aaf7efc69ecde02db4acfd20c6b4d31">More...</a><br /></td></tr>
<tr class="separator:a7aaf7efc69ecde02db4acfd20c6b4d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae882d12caec5f74b22b81fe5a73a1c81"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#ae882d12caec5f74b22b81fe5a73a1c81">~CInstantCamera</a> ()</td></tr>
<tr class="memdesc:ae882d12caec5f74b22b81fe5a73a1c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an Instant Camera object.  <a href="#ae882d12caec5f74b22b81fe5a73a1c81">More...</a><br /></td></tr>
<tr class="separator:ae882d12caec5f74b22b81fe5a73a1c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e04a31ff55e3c570e05a249edefb7c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a9e04a31ff55e3c570e05a249edefb7c0">Attach</a> (<a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a> *pDevice, <a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a> cleanupProcedure=<a class="el" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>)</td></tr>
<tr class="memdesc:a9e04a31ff55e3c570e05a249edefb7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a Pylon device to the Instant Camera.  <a href="#a9e04a31ff55e3c570e05a249edefb7c0">More...</a><br /></td></tr>
<tr class="separator:a9e04a31ff55e3c570e05a249edefb7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0088d6161a718272d54ba7d214919a27"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a0088d6161a718272d54ba7d214919a27">IsPylonDeviceAttached</a> () const </td></tr>
<tr class="memdesc:a0088d6161a718272d54ba7d214919a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Pylon device attached state of the Instant Camera object.  <a href="#a0088d6161a718272d54ba7d214919a27">More...</a><br /></td></tr>
<tr class="separator:a0088d6161a718272d54ba7d214919a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc410c61618d7565455751991ce2791"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a3bc410c61618d7565455751991ce2791">IsCameraDeviceRemoved</a> () const </td></tr>
<tr class="memdesc:a3bc410c61618d7565455751991ce2791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connection state of the camera device.  <a href="#a3bc410c61618d7565455751991ce2791">More...</a><br /></td></tr>
<tr class="separator:a3bc410c61618d7565455751991ce2791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b791f1b2258663e6b3bc7f000f8a14"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a81b791f1b2258663e6b3bc7f000f8a14">HasOwnership</a> () const </td></tr>
<tr class="memdesc:a81b791f1b2258663e6b3bc7f000f8a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ownership of the attached Pylon device.  <a href="#a81b791f1b2258663e6b3bc7f000f8a14">More...</a><br /></td></tr>
<tr class="separator:a81b791f1b2258663e6b3bc7f000f8a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d30e0748815f30d3ef4836facb8795a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d30e0748815f30d3ef4836facb8795a">DestroyDevice</a> ()</td></tr>
<tr class="memdesc:a5d30e0748815f30d3ef4836facb8795a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the attached Pylon device.  <a href="#a5d30e0748815f30d3ef4836facb8795a">More...</a><br /></td></tr>
<tr class="separator:a5d30e0748815f30d3ef4836facb8795a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6973312bbf2230257d243398b7b323dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a6973312bbf2230257d243398b7b323dd">DetachDevice</a> ()</td></tr>
<tr class="memdesc:a6973312bbf2230257d243398b7b323dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches an attached Pylon device.  <a href="#a6973312bbf2230257d243398b7b323dd">More...</a><br /></td></tr>
<tr class="separator:a6973312bbf2230257d243398b7b323dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d55354035ee749bc587b4d923a22c5f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d55354035ee749bc587b4d923a22c5f">Open</a> ()</td></tr>
<tr class="memdesc:a5d55354035ee749bc587b4d923a22c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the attached Pylon device.  <a href="#a5d55354035ee749bc587b4d923a22c5f">More...</a><br /></td></tr>
<tr class="separator:a5d55354035ee749bc587b4d923a22c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0c0cff3ffcc15443884a8c9a8727a2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a1a0c0cff3ffcc15443884a8c9a8727a2">IsOpen</a> () const </td></tr>
<tr class="memdesc:a1a0c0cff3ffcc15443884a8c9a8727a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the open state of the attached Pylon device object.  <a href="#a1a0c0cff3ffcc15443884a8c9a8727a2">More...</a><br /></td></tr>
<tr class="separator:a1a0c0cff3ffcc15443884a8c9a8727a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fd8d061c6762f8f60e14a0e1345738"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a56fd8d061c6762f8f60e14a0e1345738">Close</a> ()</td></tr>
<tr class="memdesc:a56fd8d061c6762f8f60e14a0e1345738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the attached Pylon device.  <a href="#a56fd8d061c6762f8f60e14a0e1345738">More...</a><br /></td></tr>
<tr class="separator:a56fd8d061c6762f8f60e14a0e1345738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386b84c29f9ee7ec3646fbfbf70236ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed">StartGrabbing</a> (<a class="el" href="group___pylon___instant_camera_api_generic.html#ga56a922b1bd37848234153b9e12f7fecb">EGrabStrategy</a> strategy=<a class="el" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a>, <a class="el" href="group___pylon___instant_camera_api_generic.html#gaf582b0a1fa8604d4e18857bd525291e6">EGrabLoop</a> grabLoopType=<a class="el" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a1006c968199ded056843b9c42854b206">GrabLoop_ProvidedByUser</a>)</td></tr>
<tr class="memdesc:a386b84c29f9ee7ec3646fbfbf70236ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the grabbing of images.  <a href="#a386b84c29f9ee7ec3646fbfbf70236ed">More...</a><br /></td></tr>
<tr class="separator:a386b84c29f9ee7ec3646fbfbf70236ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048529e40bbcbb7f30bd7b03ac2d72e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a048529e40bbcbb7f30bd7b03ac2d72e9">StartGrabbing</a> (size_t maxImages, <a class="el" href="group___pylon___instant_camera_api_generic.html#ga56a922b1bd37848234153b9e12f7fecb">EGrabStrategy</a> strategy=<a class="el" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a>, <a class="el" href="group___pylon___instant_camera_api_generic.html#gaf582b0a1fa8604d4e18857bd525291e6">EGrabLoop</a> grabLoopType=<a class="el" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a1006c968199ded056843b9c42854b206">GrabLoop_ProvidedByUser</a>)</td></tr>
<tr class="memdesc:a048529e40bbcbb7f30bd7b03ac2d72e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the grabbing for a maximum number of images.  <a href="#a048529e40bbcbb7f30bd7b03ac2d72e9">More...</a><br /></td></tr>
<tr class="separator:a048529e40bbcbb7f30bd7b03ac2d72e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8">RetrieveResult</a> (unsigned int timeoutMs, <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a> &amp;grabResult, <a class="el" href="group___pylon___instant_camera_api_generic.html#ga038e4dd8fbd49dd4e7ec17cc605d1344">ETimeoutHandling</a> timeoutHandling=<a class="el" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>)</td></tr>
<tr class="memdesc:a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a grab result according to the strategy, waits if it is not yet available.  <a href="#a3af3b05b85ea0aeb68eb5fb1b6dba0c8">More...</a><br /></td></tr>
<tr class="separator:a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f">StopGrabbing</a> ()</td></tr>
<tr class="memdesc:a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the grabbing of images.  <a href="#a5ef34cbfa61d4f0c2c1739bea5e5ee4f">More...</a><br /></td></tr>
<tr class="separator:a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2155d0c74753808af267c34291858c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a1d2155d0c74753808af267c34291858c">IsGrabbing</a> () const </td></tr>
<tr class="memdesc:a1d2155d0c74753808af267c34291858c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns state of grabbing.  <a href="#a1d2155d0c74753808af267c34291858c">More...</a><br /></td></tr>
<tr class="separator:a1d2155d0c74753808af267c34291858c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b74eca17e24b3ee7c7517fc223f6e3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a17b74eca17e24b3ee7c7517fc223f6e3">GrabOne</a> (unsigned int timeoutMs, <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a> &amp;grabResult, <a class="el" href="group___pylon___instant_camera_api_generic.html#ga038e4dd8fbd49dd4e7ec17cc605d1344">ETimeoutHandling</a> timeoutHandling=<a class="el" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>)</td></tr>
<tr class="memdesc:a17b74eca17e24b3ee7c7517fc223f6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs one image.  <a href="#a17b74eca17e24b3ee7c7517fc223f6e3">More...</a><br /></td></tr>
<tr class="separator:a17b74eca17e24b3ee7c7517fc223f6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786623137460a480c649520ec9f72b91"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a786623137460a480c649520ec9f72b91">GetQueuedBufferCount</a> ()</td></tr>
<tr class="memdesc:a786623137460a480c649520ec9f72b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated: This method has been deprecated.  <a href="#a786623137460a480c649520ec9f72b91">More...</a><br /></td></tr>
<tr class="separator:a786623137460a480c649520ec9f72b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d7d8a0070b94ff77e5760ee93c368f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a45d7d8a0070b94ff77e5760ee93c368f">GetGrabResultWaitObject</a> ()</td></tr>
<tr class="memdesc:a45d7d8a0070b94ff77e5760ee93c368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to a wait object indicating available grab results.  <a href="#a45d7d8a0070b94ff77e5760ee93c368f">More...</a><br /></td></tr>
<tr class="separator:a45d7d8a0070b94ff77e5760ee93c368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2210b741916d5e04d1a2b6606a029bb1"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a2210b741916d5e04d1a2b6606a029bb1">GetGrabStopWaitObject</a> ()</td></tr>
<tr class="memdesc:a2210b741916d5e04d1a2b6606a029bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to a wait object indicating that the grabbing has stopped.  <a href="#a2210b741916d5e04d1a2b6606a029bb1">More...</a><br /></td></tr>
<tr class="separator:a2210b741916d5e04d1a2b6606a029bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9c37e030215c011140ac9c940a5d34"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#abc9c37e030215c011140ac9c940a5d34">GetCameraEventWaitObject</a> ()</td></tr>
<tr class="memdesc:abc9c37e030215c011140ac9c940a5d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to a wait object indicating available camera events.  <a href="#abc9c37e030215c011140ac9c940a5d34">More...</a><br /></td></tr>
<tr class="separator:abc9c37e030215c011140ac9c940a5d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc4e8480ceec5fe3991f059e1c4d8d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#aefc4e8480ceec5fe3991f059e1c4d8d4">RegisterConfiguration</a> (<a class="el" href="class_pylon_1_1_c_configuration_event_handler.html">CConfigurationEventHandler</a> *pConfigurator, <a class="el" href="group___pylon___instant_camera_api_generic.html#ga6ad39f74e5f882a64461ad02c70567ed">ERegistrationMode</a> mode, <a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a> cleanupProcedure)</td></tr>
<tr class="memdesc:aefc4e8480ceec5fe3991f059e1c4d8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a configurator to the list of registered configurator objects.  <a href="#aefc4e8480ceec5fe3991f059e1c4d8d4">More...</a><br /></td></tr>
<tr class="separator:aefc4e8480ceec5fe3991f059e1c4d8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06beeb99e76fb10758eb0c41776e9aaa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a06beeb99e76fb10758eb0c41776e9aaa">DeregisterConfiguration</a> (<a class="el" href="class_pylon_1_1_c_configuration_event_handler.html">CConfigurationEventHandler</a> *configurator)</td></tr>
<tr class="memdesc:a06beeb99e76fb10758eb0c41776e9aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a configurator from the list of registered configurator objects.  <a href="#a06beeb99e76fb10758eb0c41776e9aaa">More...</a><br /></td></tr>
<tr class="separator:a06beeb99e76fb10758eb0c41776e9aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514f71e6302ab4f74f315ef778e5eaa7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a514f71e6302ab4f74f315ef778e5eaa7">RegisterImageEventHandler</a> (<a class="el" href="class_pylon_1_1_c_image_event_handler.html">CImageEventHandler</a> *pImageEventHandler, <a class="el" href="group___pylon___instant_camera_api_generic.html#ga6ad39f74e5f882a64461ad02c70567ed">ERegistrationMode</a> mode, <a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a> cleanupProcedure)</td></tr>
<tr class="memdesc:a514f71e6302ab4f74f315ef778e5eaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an image event handler to the list of registered image event handler objects.  <a href="#a514f71e6302ab4f74f315ef778e5eaa7">More...</a><br /></td></tr>
<tr class="separator:a514f71e6302ab4f74f315ef778e5eaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e0a03c3981115ba4aeafb50c0a2963"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a04e0a03c3981115ba4aeafb50c0a2963">DeregisterImageEventHandler</a> (<a class="el" href="class_pylon_1_1_c_image_event_handler.html">CImageEventHandler</a> *imageEventHandler)</td></tr>
<tr class="memdesc:a04e0a03c3981115ba4aeafb50c0a2963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an image event handler from the list of registered image event handler objects.  <a href="#a04e0a03c3981115ba4aeafb50c0a2963">More...</a><br /></td></tr>
<tr class="separator:a04e0a03c3981115ba4aeafb50c0a2963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c99761ba31e7ecd256d344e5ad1eb7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a87c99761ba31e7ecd256d344e5ad1eb7">RegisterCameraEventHandler</a> (<a class="el" href="class_pylon_1_1_c_camera_event_handler.html">CCameraEventHandler</a> *pCameraEventHandler, const <a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9">String_t</a> &amp;nodeName, intptr_t userProvidedId, <a class="el" href="group___pylon___instant_camera_api_generic.html#ga6ad39f74e5f882a64461ad02c70567ed">ERegistrationMode</a> mode, <a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a> cleanupProcedure, <a class="el" href="group___pylon___instant_camera_api_generic.html#ga9a7a8dfdc280fbb3ae8cc4cb3af55d9c">ECameraEventAvailability</a> availability=<a class="el" href="group___pylon___instant_camera_api_generic.html#gga9a7a8dfdc280fbb3ae8cc4cb3af55d9ca8bce3aba4fcbd4b5e2a49e851026b4d8">CameraEventAvailability_Mandatory</a>)</td></tr>
<tr class="memdesc:a87c99761ba31e7ecd256d344e5ad1eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an camera event handler to the list of registered camera event handler objects.  <a href="#a87c99761ba31e7ecd256d344e5ad1eb7">More...</a><br /></td></tr>
<tr class="separator:a87c99761ba31e7ecd256d344e5ad1eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b9470d2f17a42d8ef2d28274094588"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a30b9470d2f17a42d8ef2d28274094588">DeregisterCameraEventHandler</a> (<a class="el" href="class_pylon_1_1_c_camera_event_handler.html">CCameraEventHandler</a> *cameraEventHandler, const <a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9">String_t</a> &amp;nodeName)</td></tr>
<tr class="memdesc:a30b9470d2f17a42d8ef2d28274094588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a camera event handler from the list of registered camera event handler objects.  <a href="#a30b9470d2f17a42d8ef2d28274094588">More...</a><br /></td></tr>
<tr class="separator:a30b9470d2f17a42d8ef2d28274094588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7506b5b38079ba4583a088a620187b29"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a7506b5b38079ba4583a088a620187b29">WaitForFrameTriggerReady</a> (unsigned int timeoutMs, <a class="el" href="group___pylon___instant_camera_api_generic.html#ga038e4dd8fbd49dd4e7ec17cc605d1344">ETimeoutHandling</a> timeoutHandling=<a class="el" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>)</td></tr>
<tr class="memdesc:a7506b5b38079ba4583a088a620187b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actively waits until the the camera is ready to accept a frame trigger.  <a href="#a7506b5b38079ba4583a088a620187b29">More...</a><br /></td></tr>
<tr class="separator:a7506b5b38079ba4583a088a620187b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302f77b8a97ab622ca7b6ca0dce2c512"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a302f77b8a97ab622ca7b6ca0dce2c512">CanWaitForFrameTriggerReady</a> () const </td></tr>
<tr class="memdesc:a302f77b8a97ab622ca7b6ca0dce2c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether the camera device can be queried whether it is ready to accept the next frame trigger.  <a href="#a302f77b8a97ab622ca7b6ca0dce2c512">More...</a><br /></td></tr>
<tr class="separator:a302f77b8a97ab622ca7b6ca0dce2c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a4e166d9198dd4706a1c72c0bc2bc6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#ae5a4e166d9198dd4706a1c72c0bc2bc6">ExecuteSoftwareTrigger</a> ()</td></tr>
<tr class="memdesc:ae5a4e166d9198dd4706a1c72c0bc2bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the software trigger command.  <a href="#ae5a4e166d9198dd4706a1c72c0bc2bc6">More...</a><br /></td></tr>
<tr class="separator:ae5a4e166d9198dd4706a1c72c0bc2bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8a80a19165e6e7403eda22de3d9064"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#add8a80a19165e6e7403eda22de3d9064">SetCameraContext</a> (intptr_t context)</td></tr>
<tr class="memdesc:add8a80a19165e6e7403eda22de3d9064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a context that is attached to each grab result of the camera object on <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8" title="Retrieves a grab result according to the strategy, waits if it is not yet available. ">RetrieveResult()</a>.  <a href="#add8a80a19165e6e7403eda22de3d9064">More...</a><br /></td></tr>
<tr class="separator:add8a80a19165e6e7403eda22de3d9064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7753717e2a389c00d68dc694715b31c7"><td class="memItemLeft" align="right" valign="top">virtual intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a7753717e2a389c00d68dc694715b31c7">GetCameraContext</a> () const </td></tr>
<tr class="memdesc:a7753717e2a389c00d68dc694715b31c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the context that is attached to each grab result of the camera object.  <a href="#a7753717e2a389c00d68dc694715b31c7">More...</a><br /></td></tr>
<tr class="separator:a7753717e2a389c00d68dc694715b31c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f05e5a21b43e6f520c0c913276c4d2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_pylon_1_1_c_device_info.html">CDeviceInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a60f05e5a21b43e6f520c0c913276c4d2">GetDeviceInfo</a> () const </td></tr>
<tr class="memdesc:a60f05e5a21b43e6f520c0c913276c4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the device info object of the attached Pylon device or an empty one.  <a href="#a60f05e5a21b43e6f520c0c913276c4d2">More...</a><br /></td></tr>
<tr class="separator:a60f05e5a21b43e6f520c0c913276c4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3227195969200a52200364bf31e9c586"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a3227195969200a52200364bf31e9c586">GetNodeMap</a> ()</td></tr>
<tr class="memdesc:a3227195969200a52200364bf31e9c586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the node map of the camera device.  <a href="#a3227195969200a52200364bf31e9c586">More...</a><br /></td></tr>
<tr class="separator:a3227195969200a52200364bf31e9c586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2dbf4899cf227e4688d10bd65d0720"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#aab2dbf4899cf227e4688d10bd65d0720">GetTLNodeMap</a> ()</td></tr>
<tr class="memdesc:aab2dbf4899cf227e4688d10bd65d0720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the transport layer node map of the attached Pylon device.  <a href="#aab2dbf4899cf227e4688d10bd65d0720">More...</a><br /></td></tr>
<tr class="separator:aab2dbf4899cf227e4688d10bd65d0720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edebbf2df78abf470d225e64975a180"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a5edebbf2df78abf470d225e64975a180">GetStreamGrabberNodeMap</a> ()</td></tr>
<tr class="memdesc:a5edebbf2df78abf470d225e64975a180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the stream grabber node map of the attached Pylon device.  <a href="#a5edebbf2df78abf470d225e64975a180">More...</a><br /></td></tr>
<tr class="separator:a5edebbf2df78abf470d225e64975a180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cdcd82a941aeac03d7b04f5487e1e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#ac3cdcd82a941aeac03d7b04f5487e1e9">GetEventGrabberNodeMap</a> ()</td></tr>
<tr class="memdesc:ac3cdcd82a941aeac03d7b04f5487e1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the event grabber node map of the attached Pylon device.  <a href="#ac3cdcd82a941aeac03d7b04f5487e1e9">More...</a><br /></td></tr>
<tr class="separator:ac3cdcd82a941aeac03d7b04f5487e1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27426ed8e4192d7af0be66860f7ff65a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a27426ed8e4192d7af0be66860f7ff65a">GetInstantCameraNodeMap</a> ()</td></tr>
<tr class="memdesc:a27426ed8e4192d7af0be66860f7ff65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the node map of the Instant Camera object.  <a href="#a27426ed8e4192d7af0be66860f7ff65a">More...</a><br /></td></tr>
<tr class="separator:a27426ed8e4192d7af0be66860f7ff65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b201d21860f4f8ba11cda277af957"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a241b201d21860f4f8ba11cda277af957">SetBufferFactory</a> (<a class="el" href="struct_pylon_1_1_i_buffer_factory.html">IBufferFactory</a> *pFactory, <a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a> cleanupProcedure=<a class="el" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>)</td></tr>
<tr class="memdesc:a241b201d21860f4f8ba11cda277af957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an alternative buffer factory that is used for buffer allocation.  <a href="#a241b201d21860f4f8ba11cda277af957">More...</a><br /></td></tr>
<tr class="separator:a241b201d21860f4f8ba11cda277af957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a06161d54cb6a6dee7958be0902f38"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#ab0a06161d54cb6a6dee7958be0902f38">Is1394</a> () const </td></tr>
<tr class="memdesc:ab0a06161d54cb6a6dee7958be0902f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an IEEE 1394 Pylon device is attached to the Instant Camera object.  <a href="#ab0a06161d54cb6a6dee7958be0902f38">More...</a><br /></td></tr>
<tr class="separator:ab0a06161d54cb6a6dee7958be0902f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d21834ee84f91052302ebc92c44922"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a50d21834ee84f91052302ebc92c44922">IsGigE</a> () const </td></tr>
<tr class="memdesc:a50d21834ee84f91052302ebc92c44922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a GigE Pylon device is attached to the Instant Camera object.  <a href="#a50d21834ee84f91052302ebc92c44922">More...</a><br /></td></tr>
<tr class="separator:a50d21834ee84f91052302ebc92c44922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3fd5e7e9f079ca304ca30d9e4860d4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a1d3fd5e7e9f079ca304ca30d9e4860d4">IsUsb</a> () const </td></tr>
<tr class="memdesc:a1d3fd5e7e9f079ca304ca30d9e4860d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a USB Pylon device is attached to the Instant Camera object.  <a href="#a1d3fd5e7e9f079ca304ca30d9e4860d4">More...</a><br /></td></tr>
<tr class="separator:a1d3fd5e7e9f079ca304ca30d9e4860d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479697100a74a871558a3b503b1e4fec"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a479697100a74a871558a3b503b1e4fec">IsCameraLink</a> () const </td></tr>
<tr class="memdesc:a479697100a74a871558a3b503b1e4fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a Camera Link Pylon device is attached to the Instant Camera object.  <a href="#a479697100a74a871558a3b503b1e4fec">More...</a><br /></td></tr>
<tr class="separator:a479697100a74a871558a3b503b1e4fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc423f34cccc79fa89a4e71344aa89e6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#abc423f34cccc79fa89a4e71344aa89e6">IsCxp</a> () const </td></tr>
<tr class="memdesc:abc423f34cccc79fa89a4e71344aa89e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a CoaXPress GenTL device is attached to the Instant Camera object.  <a href="#abc423f34cccc79fa89a4e71344aa89e6">More...</a><br /></td></tr>
<tr class="separator:abc423f34cccc79fa89a4e71344aa89e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d2817d90e2a6b0a2fa120666bc702a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pylon_1_1_version_info.html">VersionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a90d2817d90e2a6b0a2fa120666bc702a">GetSfncVersion</a> () const </td></tr>
<tr class="memdesc:a90d2817d90e2a6b0a2fa120666bc702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SFNC version read from the camera node map.  <a href="#a90d2817d90e2a6b0a2fa120666bc702a">More...</a><br /></td></tr>
<tr class="separator:a90d2817d90e2a6b0a2fa120666bc702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454846d3efa5cd5838505017289019a1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a454846d3efa5cd5838505017289019a1">IsBcon</a> () const </td></tr>
<tr class="memdesc:a454846d3efa5cd5838505017289019a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a BCON Pylon device is attached to the Instant Camera object.  <a href="#a454846d3efa5cd5838505017289019a1">More...</a><br /></td></tr>
<tr class="separator:a454846d3efa5cd5838505017289019a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Categories: Root</div></td></tr>
<tr class="memitem:a6146e8376cf959658ebe363c6af76b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a6146e8376cf959658ebe363c6af76b8b">AcquisitionStartStopExecutionEnable</a></td></tr>
<tr class="memdesc:a6146e8376cf959658ebe363c6af76b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set, this will automatically execute AcquisitionStart when calling StartGrabbing and AcquisitionStop when calling StopGrabbing This option is enabled by default - Applies to: InstantCamera.  <a href="#a6146e8376cf959658ebe363c6af76b8b">More...</a><br /></td></tr>
<tr class="separator:a6146e8376cf959658ebe363c6af76b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ea97177f145126ea04cad43c7f1a32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#aa9ea97177f145126ea04cad43c7f1a32">ChunkNodeMapsEnable</a></td></tr>
<tr class="memdesc:aa9ea97177f145126ea04cad43c7f1a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables the use of a chunk node map for each grab result Grab result chunk node maps can be disabled to save resources - Applies to: InstantCamera.  <a href="#aa9ea97177f145126ea04cad43c7f1a32">More...</a><br /></td></tr>
<tr class="separator:aa9ea97177f145126ea04cad43c7f1a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1536831bf959461851a860bde593e413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a1536831bf959461851a860bde593e413">ClearBufferModeEnable</a></td></tr>
<tr class="memdesc:a1536831bf959461851a860bde593e413"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set, all buffers will be cleared (set to 0) before grabbing an image Note that this requires additional processing time per frame - Applies to: InstantCamera.  <a href="#a1536831bf959461851a860bde593e413">More...</a><br /></td></tr>
<tr class="separator:a1536831bf959461851a860bde593e413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e369783a9a6389ea22366e0ff6ce75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a13e369783a9a6389ea22366e0ff6ce75">GrabCameraEvents</a></td></tr>
<tr class="memdesc:a13e369783a9a6389ea22366e0ff6ce75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables the grabbing of camera events while images are grabbed Is writable when the camera object is closed - Applies to: InstantCamera.  <a href="#a13e369783a9a6389ea22366e0ff6ce75">More...</a><br /></td></tr>
<tr class="separator:a13e369783a9a6389ea22366e0ff6ce75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9205abb1850ef7e5f1a79fe2ccd377f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a9205abb1850ef7e5f1a79fe2ccd377f9">MaxNumBuffer</a></td></tr>
<tr class="memdesc:a9205abb1850ef7e5f1a79fe2ccd377f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of buffers that are allocated and used for grabbing - Applies to: InstantCamera.  <a href="#a9205abb1850ef7e5f1a79fe2ccd377f9">More...</a><br /></td></tr>
<tr class="separator:a9205abb1850ef7e5f1a79fe2ccd377f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddce05d310e007cba7498ecfb1a50bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a7ddce05d310e007cba7498ecfb1a50bd">MaxNumGrabResults</a></td></tr>
<tr class="memdesc:a7ddce05d310e007cba7498ecfb1a50bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of grab results available at any time during a grab session This value can be limited to save resources Furthermore, it can be used to check that the grab results are returned correctly - Applies to: InstantCamera.  <a href="#a7ddce05d310e007cba7498ecfb1a50bd">More...</a><br /></td></tr>
<tr class="separator:a7ddce05d310e007cba7498ecfb1a50bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91a278d159ff95e0c78c772a7259d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#ab91a278d159ff95e0c78c772a7259d67">MaxNumQueuedBuffer</a></td></tr>
<tr class="memdesc:ab91a278d159ff95e0c78c772a7259d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of buffers that are queued in the stream grabber input queue - Applies to: InstantCamera.  <a href="#ab91a278d159ff95e0c78c772a7259d67">More...</a><br /></td></tr>
<tr class="separator:ab91a278d159ff95e0c78c772a7259d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f502f113f04f3bda3fdb8d8bc502ac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a1f502f113f04f3bda3fdb8d8bc502ac9">MigrationModeActive</a></td></tr>
<tr class="memdesc:a1f502f113f04f3bda3fdb8d8bc502ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The migration mode is set up according to this setting at defined points e g , when the camera is opened - Applies to: InstantCamera.  <a href="#a1f502f113f04f3bda3fdb8d8bc502ac9">More...</a><br /></td></tr>
<tr class="separator:a1f502f113f04f3bda3fdb8d8bc502ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49c0a2eba56fc913af574e602e57aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#ae49c0a2eba56fc913af574e602e57aae">MonitorModeActive</a></td></tr>
<tr class="memdesc:ae49c0a2eba56fc913af574e602e57aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The camera object is set to monitor mode when enabled, e g when using the GigE multicast feature Is writable when the camera object is closed - Applies to: InstantCamera.  <a href="#ae49c0a2eba56fc913af574e602e57aae">More...</a><br /></td></tr>
<tr class="separator:ae49c0a2eba56fc913af574e602e57aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4387e9f5f5556892f3b8ebcc12d9357a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a4387e9f5f5556892f3b8ebcc12d9357a">NumEmptyBuffers</a></td></tr>
<tr class="memdesc:a4387e9f5f5556892f3b8ebcc12d9357a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of empty buffers that are not used for grabbing yet - Applies to: InstantCamera.  <a href="#a4387e9f5f5556892f3b8ebcc12d9357a">More...</a><br /></td></tr>
<tr class="separator:a4387e9f5f5556892f3b8ebcc12d9357a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b3ae8b812c2c188f3382eea529a1af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#af6b3ae8b812c2c188f3382eea529a1af">NumQueuedBuffers</a></td></tr>
<tr class="memdesc:af6b3ae8b812c2c188f3382eea529a1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of buffers queued at Low Level API stream grabber - Applies to: InstantCamera.  <a href="#af6b3ae8b812c2c188f3382eea529a1af">More...</a><br /></td></tr>
<tr class="separator:af6b3ae8b812c2c188f3382eea529a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c203b097f07da79cc35b3839451a410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a7c203b097f07da79cc35b3839451a410">NumReadyBuffers</a></td></tr>
<tr class="memdesc:a7c203b097f07da79cc35b3839451a410"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of grab result buffers in the output queue that are ready for retrieval - Applies to: InstantCamera.  <a href="#a7c203b097f07da79cc35b3839451a410">More...</a><br /></td></tr>
<tr class="separator:a7c203b097f07da79cc35b3839451a410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d1fe2d22ff3a2f21fda6e568049e07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a36d1fe2d22ff3a2f21fda6e568049e07">OutputQueueSize</a></td></tr>
<tr class="memdesc:a36d1fe2d22ff3a2f21fda6e568049e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the grab result buffer output queue - Applies to: InstantCamera.  <a href="#a36d1fe2d22ff3a2f21fda6e568049e07">More...</a><br /></td></tr>
<tr class="separator:a36d1fe2d22ff3a2f21fda6e568049e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745513e6c84f8c4e6bb7c1f725ee2e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a745513e6c84f8c4e6bb7c1f725ee2e3c">StaticChunkNodeMapPoolSize</a></td></tr>
<tr class="memdesc:a745513e6c84f8c4e6bb7c1f725ee2e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If larger than 0, a static chunk node map pool is used instead of dynamic chunk node map creation - Applies to: InstantCamera.  <a href="#a745513e6c84f8c4e6bb7c1f725ee2e3c">More...</a><br /></td></tr>
<tr class="separator:a745513e6c84f8c4e6bb7c1f725ee2e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Categories: GrabLoopThread</div></td></tr>
<tr class="memitem:a234277cb10664ba17c0fb28d1e5a5b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a234277cb10664ba17c0fb28d1e5a5b99">GrabLoopThreadPriority</a></td></tr>
<tr class="memdesc:a234277cb10664ba17c0fb28d1e5a5b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The grab loop thread priority - Applies to: InstantCamera.  <a href="#a234277cb10664ba17c0fb28d1e5a5b99">More...</a><br /></td></tr>
<tr class="separator:a234277cb10664ba17c0fb28d1e5a5b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde4984a24386f79f184df8a22025c8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#afde4984a24386f79f184df8a22025c8c">GrabLoopThreadPriorityOverride</a></td></tr>
<tr class="memdesc:afde4984a24386f79f184df8a22025c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If enabled, the user can set a custom priority for the grab loop thread Otherwise, the priority of the newly created thread is not changed - Applies to: InstantCamera.  <a href="#afde4984a24386f79f184df8a22025c8c">More...</a><br /></td></tr>
<tr class="separator:afde4984a24386f79f184df8a22025c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad172893d678d609e7a42ec47cde296ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#ad172893d678d609e7a42ec47cde296ad">GrabLoopThreadTimeout</a></td></tr>
<tr class="memdesc:ad172893d678d609e7a42ec47cde296ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom timeout for the grab loop thread's call to RetrieveResult RetrieveResult is configured to throw an exception on timeout, which will stop the grab session - Applies to: InstantCamera.  <a href="#ad172893d678d609e7a42ec47cde296ad">More...</a><br /></td></tr>
<tr class="separator:ad172893d678d609e7a42ec47cde296ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0fd49592b32fa6536fecc088d6738e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a3d0fd49592b32fa6536fecc088d6738e">GrabLoopThreadUseTimeout</a></td></tr>
<tr class="memdesc:a3d0fd49592b32fa6536fecc088d6738e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If enabled, the user can set a custom timeout for the grab loop thread's call to RetrieveResult RetrieveResult is configured to throw an exception on timeout, which will stop the grab session - Applies to: InstantCamera.  <a href="#a3d0fd49592b32fa6536fecc088d6738e">More...</a><br /></td></tr>
<tr class="separator:a3d0fd49592b32fa6536fecc088d6738e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Categories: InternalGrabEngineThread</div></td></tr>
<tr class="memitem:a635956dab71ee9e7b3773dc2592081e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a635956dab71ee9e7b3773dc2592081e7">InternalGrabEngineThreadPriority</a></td></tr>
<tr class="memdesc:a635956dab71ee9e7b3773dc2592081e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal grab engine thread priority - Applies to: InstantCamera.  <a href="#a635956dab71ee9e7b3773dc2592081e7">More...</a><br /></td></tr>
<tr class="separator:a635956dab71ee9e7b3773dc2592081e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9e713a5af6d9170957c051650e01fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#adb9e713a5af6d9170957c051650e01fb">InternalGrabEngineThreadPriorityOverride</a></td></tr>
<tr class="memdesc:adb9e713a5af6d9170957c051650e01fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If enabled, the user can set a custom priority for the internal grab engine thread operating the stream grabber Otherwise the priority defaults to 25 - Applies to: InstantCamera.  <a href="#adb9e713a5af6d9170957c051650e01fb">More...</a><br /></td></tr>
<tr class="separator:adb9e713a5af6d9170957c051650e01fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a97768a8edadb26c709c94f6cf95b4daa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#a97768a8edadb26c709c94f6cf95b4daa">GetDevice</a> ()</td></tr>
<tr class="memdesc:a97768a8edadb26c709c94f6cf95b4daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the attached Pylon device.  <a href="#a97768a8edadb26c709c94f6cf95b4daa">More...</a><br /></td></tr>
<tr class="separator:a97768a8edadb26c709c94f6cf95b4daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9d596c6ad821ff7d36945535684da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pylon_1_1_c_lock.html">CLock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3">GetLock</a> ()</td></tr>
<tr class="memdesc:abe9d596c6ad821ff7d36945535684da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the lock used for synchronizing the access to the camera.  <a href="#abe9d596c6ad821ff7d36945535684da3">More...</a><br /></td></tr>
<tr class="separator:abe9d596c6ad821ff7d36945535684da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides convenient access to a camera device. </p>
<ul>
<li>
Establishes a single access point for accessing camera functionality. </li>
<li>
The class can be used off the shelf without any parameters. The camera uses a default configuration for the camera device. This can be overridden. </li>
<li>
Handles Pylon device lifetime. This can be overridden. </li>
<li>
Handles opening and closing of a Pylon device automatically. </li>
<li>
Handles chunk data parsing automatically returning the chunk data in the grab result. </li>
<li>
Handles event grabbing automatically providing a convenient interface for event callbacks. This can be overridden. </li>
<li>
Handles physical camera device removal. </li>
<li>
Handles the creation, reuse, and destruction of buffers. </li>
<li>
The grabbing can be done in the context of the caller or by using an additional grab loop thread. </li>
<li>
The Instant Camera class is extensible using derivation or by registering event handler objects. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae7049f927ffeb878aa532abfa3f9807d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pylon::CInstantCamera::CInstantCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an Instant Camera object with no attached Pylon device. </p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a7aaf7efc69ecde02db4acfd20c6b4d31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pylon::CInstantCamera::CInstantCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a>&#160;</td>
          <td class="paramname"><em>cleanupProcedure</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an Instant Camera object and calls <a class="el" href="class_pylon_1_1_c_instant_camera.html#a9e04a31ff55e3c570e05a249edefb7c0" title="Attaches a Pylon device to the Instant Camera. ">Attach()</a>. </p>
<p>See <a class="el" href="class_pylon_1_1_c_instant_camera.html#a9e04a31ff55e3c570e05a249edefb7c0" title="Attaches a Pylon device to the Instant Camera. ">Attach()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>The Pylon device to attach. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cleanupProcedure</td><td>If cleanupProcedure equals Cleanup_Delete, the Pylon device is destroyed when the Instant Camera object is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Safety:</dt><dd>May throw an exception if the passed Pylon device is open. Does not throw C++ exceptions if the passed Pylon device is closed or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ae882d12caec5f74b22b81fe5a73a1c81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Pylon::CInstantCamera::~CInstantCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys an Instant Camera object. </p>
<p>Calls Attach( NULL) for destroying or removing a Pylon device depending on the passed cleanup procedure.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9e04a31ff55e3c570e05a249edefb7c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::Attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a>&#160;</td>
          <td class="paramname"><em>cleanupProcedure</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a Pylon device to the Instant Camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>The Pylon device to attach. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cleanupProcedure</td><td>If cleanupProcedure equals Cleanup_Delete, the Pylon device is destroyed when the Instant Camera object is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>
If a Pylon device is currently attached, it is destroyed (<a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d30e0748815f30d3ef4836facb8795a" title="Destroys the attached Pylon device. ">DestroyDevice()</a>) or removed (<a class="el" href="class_pylon_1_1_c_instant_camera.html#a6973312bbf2230257d243398b7b323dd" title="Detaches an attached Pylon device. ">DetachDevice()</a>) depending on the previously set cleanup procedure value. </li>
<li>
If the pDevice parameter is NULL, nothing more is done. </li>
<li>
The OnAttach configuration event is fired. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
<li>
The new Pylon device is attached. </li>
<li>
The instant camera migration mode setting is applied to the Pylon device transport layer node map. </li>
<li>
If the passed Pylon device is open, callbacks for camera events are registered at the camera node map. (This may fail) </li>
<li>
If the passed Pylon device is open, a device removal call back is registered. (This may fail) </li>
<li>
If the passed Pylon device is open, access modifiers (see <a class="el" href="struct_pylon_1_1_i_device.html#a416ff56935bd159fef72dc9318a27d89" title="Opens a device. ">IPylonDevice::Open()</a>) are carried over as camera parameters. </li>
<li>
The OnAttached configuration event is fired. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
</ul>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If the passed pointer to the Pylon device is NULL, the Instant Camera object is in the "no device attached" state. </li>
<li>
If the passed pointer to the Pylon device is not NULL, the passed Pylon device is attached. </li>
<li>
If the set cleanup procedure equals Cleanup_Delete, the Pylon device is destroyed when the Instant Camera object is destroyed or a new device is attached. </li>
<li>
If the passed Pylon device is open and the registration of callbacks fails, the Instant Camera object is in the "no device attached" state. </li>
<li>
The opened-by-user flag is set, preventing closing of the Pylon device on <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a> when the attached Pylon device is already open. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>May throw an exception if the passed Pylon device is open. Does not throw C++ exceptions if the passed Pylon device is closed or NULL.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#ae93cdc7db01bd780024e604fe867de39">Pylon::CDeviceSpecificInstantCameraT&lt; CameraTraitsT &gt;</a>, and <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#ae93cdc7db01bd780024e604fe867de39">Pylon::CDeviceSpecificInstantCameraT&lt; CBaslerUniversalInstantCameraTraits &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a302f77b8a97ab622ca7b6ca0dce2c512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::CanWaitForFrameTriggerReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see whether the camera device can be queried whether it is ready to accept the next frame trigger. </p>
<p>If 'FrameTriggerWait' can be selected for 'AcquisitionStatusSelector' and 'AcquisitionStatus' is readable, the camera device can be queried whether it is ready to accept the next frame trigger.</p>
<p>If the nodes mentioned above are not available and the 'SoftwareTrigger' node is readable, the camera device can be queried whether it is ready to accept the next frame trigger.</p>
<dl class="section note"><dt>Note</dt><dd>If a camera device can't be queried whether it is ready to accept the next frame trigger, the camera device is ready to accept the next trigger after the last image triggered has been grabbed, e.g. after you have retrieved the last image triggered using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8" title="Retrieves a grab result according to the strategy, waits if it is not yet available. ">RetrieveResult()</a>. Camera devices that can be queried whether they are ready to accept the next frame trigger, may not be ready for the next frame trigger after the last image triggered has been grabbed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the camera is open and the camera device can be queried whether it is ready to accept the next frame trigger.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The 'AcquisitionStatusSelector' is set to 'FrameTriggerWait' if writable.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Accessing the camera registers may fail.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a56fd8d061c6762f8f60e14a0e1345738"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the attached Pylon device. </p>
<ul>
<li>
If no Pylon device is attached, nothing is done. </li>
<li>
If the Pylon device is already closed, nothing is done. </li>
<li>
If a grab is in progress, it is stopped by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a>. </li>
<li>
The configuration event OnClose is fired. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
<li>
The connection to the camera device is closed and the Pylon device is closed. </li>
<li>
The configuration event OnClosed is fired if the Pylon device has been closed successfully. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
</ul>
<dl class="section post"><dt>Postcondition</dt><dd>The connection to the camera device is closed and the Pylon device is closed.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. Possible C++ exceptions are caught and ignored.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#aa0888df5faf71045686ebcaf65ab4dda">Pylon::CDeviceSpecificInstantCameraT&lt; CameraTraitsT &gt;</a>, and <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#aa0888df5faf71045686ebcaf65ab4dda">Pylon::CDeviceSpecificInstantCameraT&lt; CBaslerUniversalInstantCameraTraits &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a30b9470d2f17a42d8ef2d28274094588"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::DeregisterCameraEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_camera_event_handler.html">CCameraEventHandler</a> *&#160;</td>
          <td class="paramname"><em>cameraEventHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9">String_t</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a camera event handler from the list of registered camera event handler objects. </p>
<p>If the camera event handler is not found, nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraEventHandler</td><td>The registered receiver of camera events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeName</td><td>The name of the event data node updated on camera event, e.g. "ExposureEndEventTimestamp" for exposure end event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The cameraEventHandler is deregistered. </li>
<li>
If the camera event handler has been registered by passing a pointer and the cleanup procedure is Cleanup_Delete, the event handler is deleted. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the camera event handler lock. If the camera is open, the camera node map lock is also used for synchronization. </dd></dl>

</div>
</div>
<a class="anchor" id="a06beeb99e76fb10758eb0c41776e9aaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::DeregisterConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_configuration_event_handler.html">CConfigurationEventHandler</a> *&#160;</td>
          <td class="paramname"><em>configurator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a configurator from the list of registered configurator objects. </p>
<p>If the configurator is not found, nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configurator</td><td>The registered receiver of configuration events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The configurator is deregistered. </li>
<li>
If the configuration has been registered by passing a pointer and the cleanup procedure is Cleanup_Delete, the event handler is deleted. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a04e0a03c3981115ba4aeafb50c0a2963"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::DeregisterImageEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_image_event_handler.html">CImageEventHandler</a> *&#160;</td>
          <td class="paramname"><em>imageEventHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an image event handler from the list of registered image event handler objects. </p>
<p>If the image event handler is not found, nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imageEventHandler</td><td>The registered receiver of configuration events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The imageEventHandler is deregistered. </li>
<li>
If the image event handler has been registered by passing a pointer and the cleanup procedure is Cleanup_Delete, the event handler is deleted. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the internal image event handler registry lock. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d30e0748815f30d3ef4836facb8795a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::DestroyDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the attached Pylon device. </p>
<dl class="section attention"><dt>Attention</dt><dd>The node maps, e.g. the camera node map, of the attached Pylon device must not be accessed anymore while destroying the Pylon device.</dd></dl>
<ul>
<li>
If no Pylon device is attached, nothing is done. </li>
<li>
If the Pylon device is open, it is closed by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a56fd8d061c6762f8f60e14a0e1345738" title="Closes the attached Pylon device. ">Close()</a>. </li>
<li>
The configuration event OnDestroy is fired. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
<li>
The Pylon device is destroyed even if the cleanup procedure Cleanup_None has been passed when calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a9e04a31ff55e3c570e05a249edefb7c0" title="Attaches a Pylon device to the Instant Camera. ">Attach()</a> before. </li>
<li>
The configuration event OnDestroyed is fired. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
</ul>
<dl class="section post"><dt>Postcondition</dt><dd>No Pylon device is attached.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. Possible C++ exceptions are caught and ignored.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#ac9fc839ff966ff11b2b5eefd563d1853">Pylon::CDeviceSpecificInstantCameraT&lt; CameraTraitsT &gt;</a>, and <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#ac9fc839ff966ff11b2b5eefd563d1853">Pylon::CDeviceSpecificInstantCameraT&lt; CBaslerUniversalInstantCameraTraits &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6973312bbf2230257d243398b7b323dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a>* Pylon::CInstantCamera::DetachDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches an attached Pylon device. </p>
<ul>
<li>
If no Pylon device is attached, nothing is done. </li>
<li>
If a grab is in progress, it is stopped by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a>. </li>
<li>
The configuration event OnDetach is fired. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
<li>
The Pylon device is detached. </li>
<li>
The configuration event OnDetached is fired. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The attached Pylon device or NULL if nothing has been attached before.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
No Pylon device is attached. </li>
<li>
The ownership of the Pylon device goes to the caller who is responsible for destroying the Pylon device. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. Possible C++ exceptions are caught and ignored.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#a7d18fd27b047235bbe3b8ed11ea0339d">Pylon::CDeviceSpecificInstantCameraT&lt; CameraTraitsT &gt;</a>, and <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#a7d18fd27b047235bbe3b8ed11ea0339d">Pylon::CDeviceSpecificInstantCameraT&lt; CBaslerUniversalInstantCameraTraits &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae5a4e166d9198dd4706a1c72c0bc2bc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::ExecuteSoftwareTrigger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the software trigger command. </p>
<p>The camera needs to be configured for software trigger mode. Additionally, the camera needs to be ready to accept triggers. When triggering a frame this can be checked using the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a7506b5b38079ba4583a088a620187b29" title="Actively waits until the the camera is ready to accept a frame trigger. ">WaitForFrameTriggerReady()</a> method;</p>
<dl class="section note"><dt>Note</dt><dd>The application has to make sure that the correct trigger is selected before calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#ae5a4e166d9198dd4706a1c72c0bc2bc6" title="Executes the software trigger command. ">ExecuteSoftwareTrigger()</a>. This can be done via the camera's TriggerSelector node. The <code><a class="el" href="class_pylon_1_1_c_software_trigger_configuration.html" title="Changes the configuration of the camera so that the acquisition of frames is triggered by software tr...">Pylon::CSoftwareTriggerConfiguration</a></code> selects the correct trigger when the Instant Camera is opened.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The grabbing is started. </li>
<li>
The camera device supports software trigger. </li>
<li>
The software trigger is available. This depends on the configuration of the camera device. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Accessing the camera registers may fail. Throws an exception on timeout if <code>timeoutHandling</code> is TimeoutHandling_ThrowException.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7753717e2a389c00d68dc694715b31c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual intptr_t Pylon::CInstantCamera::GetCameraContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the context that is attached to each grab result of the camera object. </p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abc9c37e030215c011140ac9c940a5d34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a>&amp; Pylon::CInstantCamera::GetCameraEventWaitObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to a wait object indicating available camera events. </p>
<p>This wait object is Pylon device specific and changes when a new Pylon device is attached to the camera.</p>
<dl class="section return"><dt>Returns</dt><dd>A wait object indicating available camera events.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A Pylon device is attached. </li>
<li>
The Pylon device is open. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a97768a8edadb26c709c94f6cf95b4daa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_pylon_1_1_i_pylon_device.html">IPylonDevice</a>* Pylon::CInstantCamera::GetDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the attached Pylon device. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the attached Pylon device.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A Pylon device is attached.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a60f05e5a21b43e6f520c0c913276c4d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_pylon_1_1_c_device_info.html">CDeviceInfo</a>&amp; Pylon::CInstantCamera::GetDeviceInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the device info object of the attached Pylon device or an empty one. </p>
<dl class="section return"><dt>Returns</dt><dd>The info object of the attached Pylon device or an empty one.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#a958720228a24033bac2d536010e493c3">Pylon::CDeviceSpecificInstantCameraT&lt; CameraTraitsT &gt;</a>, and <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#a958720228a24033bac2d536010e493c3">Pylon::CDeviceSpecificInstantCameraT&lt; CBaslerUniversalInstantCameraTraits &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac3cdcd82a941aeac03d7b04f5487e1e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>&amp; Pylon::CInstantCamera::GetEventGrabberNodeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the event grabber node map of the attached Pylon device. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the event grabber node map of the attached Pylon device or a reference to the empty node map if event grabbing is not supported. The GENAPI_NAMESPACE::INodeMap::GetNumNodes() method can be used to check whether the node map is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A Pylon device is attached. </li>
<li>
The Pylon device is open. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a45d7d8a0070b94ff77e5760ee93c368f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a>&amp; Pylon::CInstantCamera::GetGrabResultWaitObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to a wait object indicating available grab results. </p>
<dl class="section return"><dt>Returns</dt><dd>A wait object indicating available grab results.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2210b741916d5e04d1a2b6606a029bb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a>&amp; Pylon::CInstantCamera::GetGrabStopWaitObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to a wait object indicating that the grabbing has stopped. </p>
<dl class="section return"><dt>Returns</dt><dd>A wait object indicating that the grabbing has stopped.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a27426ed8e4192d7af0be66860f7ff65a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>&amp; Pylon::CInstantCamera::GetInstantCameraNodeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the node map of the Instant Camera object. </p>
<p>The node map of the camera device is made available by the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3227195969200a52200364bf31e9c586" title="Provides access to the node map of the camera device. ">GetNodeMap()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the node map of the Instant Camera object.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abe9d596c6ad821ff7d36945535684da3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pylon_1_1_c_lock.html">CLock</a>&amp; Pylon::CInstantCamera::GetLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the lock used for synchronizing the access to the camera. </p>
<p>This lock can be used when extending the Instant Camera class.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>CMyInstantCamera : <span class="keyword">public</span> <a class="code" href="class_pylon_1_1_c_instant_camera.html#ae7049f927ffeb878aa532abfa3f9807d">CInstantCamera</a></div><div class="line">{</div><div class="line">    <span class="comment">// Method extending the Instant Camera class</span></div><div class="line">    <span class="keywordtype">void</span> Foo()</div><div class="line">    {</div><div class="line">        <span class="comment">// Scoped Lock.</span></div><div class="line">        AutoLock lock( <a class="code" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3">CInstantCamera::GetLock</a>());</div><div class="line"></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line"> };</div></div><!-- fragment --><dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a3227195969200a52200364bf31e9c586"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>&amp; Pylon::CInstantCamera::GetNodeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the node map of the camera device. </p>
<p>The Pylon device must be opened before reading ore writing any parameters of the camera device. This can be done using the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d55354035ee749bc587b4d923a22c5f" title="Opens the attached Pylon device. ">Open()</a> method of the Instant Camera class.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the node map of the camera device.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A Pylon device is attached.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a786623137460a480c649520ec9f72b91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Pylon::CInstantCamera::GetQueuedBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated: This method has been deprecated. </p>
<p>Use the NumQueuedBuffers parameter instead. </p><dl class="section return"><dt>Returns</dt><dd>The number of buffers that are queued for grabbing. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d2817d90e2a6b0a2fa120666bc702a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pylon_1_1_version_info.html">VersionInfo</a> Pylon::CInstantCamera::GetSfncVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the SFNC version read from the camera node map. </p>
<p>The SFNC version is read from the camera node map using the integer nodes DeviceSFNCVersionMajor, DeviceSFNCVersionMinor, and DeviceSFNCVersionSubMinor.</p>
<dl class="section return"><dt>Returns</dt><dd>The SFNC version used by the camera device. The returned SFNC version is 0.0.0 (Pylon::Sfnc_VersionUndefined) if no SFNC version information is provided by the camera device.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A Pylon device is attached.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5edebbf2df78abf470d225e64975a180"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>&amp; Pylon::CInstantCamera::GetStreamGrabberNodeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the stream grabber node map of the attached Pylon device. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the stream grabber node map of the attached Pylon device or the reference to the empty node map if grabbing is not supported. The GENAPI_NAMESPACE::INodeMap::GetNumNodes() method can be used to check whether the node map is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A Pylon device is attached. </li>
<li>
The Pylon device is open. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aab2dbf4899cf227e4688d10bd65d0720"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>&amp; Pylon::CInstantCamera::GetTLNodeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the transport layer node map of the attached Pylon device. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transport layer node map of the attached Pylon device or the reference to the empty node map if a transport layer node map is not supported. The GENAPI_NAMESPACE::INodeMap::GetNumNodes() method can be used to check whether the node map is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A Pylon device is attached.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a17b74eca17e24b3ee7c7517fc223f6e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::GrabOne </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>grabResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga038e4dd8fbd49dd4e7ec17cc605d1344">ETimeoutHandling</a>&#160;</td>
          <td class="paramname"><em>timeoutHandling</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grabs one image. </p>
<p>The following code shows a simplified version of what is done (happy path):</p>
<div class="fragment"><div class="line"><span class="comment">//grab one image</span></div><div class="line"><a class="code" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed">StartGrabbing</a>( 1, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a1006c968199ded056843b9c42854b206">GrabLoop_ProvidedByUser</a>);</div><div class="line"></div><div class="line"><span class="comment">//grab is stopped automatically due to maxImages = 1</span></div><div class="line"><span class="keywordflow">return</span> <a class="code" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8">RetrieveResult</a>( timeoutMs, grabResult, timeoutHandling) &amp;&amp; grabResult-&gt;GrabSucceeded();</div></div><!-- fragment --><p><a class="el" href="class_pylon_1_1_c_instant_camera.html#a17b74eca17e24b3ee7c7517fc223f6e3" title="Grabs one image. ">GrabOne()</a> can be used to together with the <a class="el" href="class_pylon_1_1_c_acquire_single_frame_configuration.html" title="An instant camera configuration for single frame acquisition, Use together with CInstantCamera::GrabO...">CAcquireSingleFrameConfiguration</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Using GrabOne is more efficient if the Pylon device is already open, otherwise the Pylon device is opened and closed for each call.</dd>
<dd>
Grabbing single images using Software Trigger (<a class="el" href="class_pylon_1_1_c_software_trigger_configuration.html" title="Changes the configuration of the camera so that the acquisition of frames is triggered by software tr...">CSoftwareTriggerConfiguration</a>) is recommended if you want to maximize frame rate. This is because the overhead per grabbed image is reduced compared to Single Frame Acquisition. The grabbing can be started using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed" title="Starts the grabbing of images. ">StartGrabbing()</a>. Images are grabbed using the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a7506b5b38079ba4583a088a620187b29" title="Actively waits until the the camera is ready to accept a frame trigger. ">WaitForFrameTriggerReady()</a>, <a class="el" href="class_pylon_1_1_c_instant_camera.html#ae5a4e166d9198dd4706a1c72c0bc2bc6" title="Executes the software trigger command. ">ExecuteSoftwareTrigger()</a> and <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8" title="Retrieves a grab result according to the strategy, waits if it is not yet available. ">RetrieveResult()</a> methods instead of using GrabOne. The grab can be stopped using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a> when done.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMs</td><td>A timeout value in ms for waiting for a grab result, or the INFINITE value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grabResult</td><td>Receives the grab result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutHandling</td><td>If timeoutHandling equals TimeoutHandling_ThrowException, a timeout exception is thrown on timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the call successfully retrieved a grab result and the grab succeeded (<a class="el" href="class_pylon_1_1_c_grab_result_data.html#a57fbc04cd2abf3bf6307e07131dd0503" title="Returns true if an image has been grabbed successfully and false in the case of an error...">CGrabResultData::GrabSucceeded()</a>).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must meet the preconditions of start grabbing. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Meets the postconditions of stop grabbing.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error. See <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed" title="Starts the grabbing of images. ">StartGrabbing()</a>, <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8" title="Retrieves a grab result according to the strategy, waits if it is not yet available. ">RetrieveResult()</a>, and <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a> . In the case of exceptions after <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed" title="Starts the grabbing of images. ">StartGrabbing()</a> the grabbing is stopped using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a81b791f1b2258663e6b3bc7f000f8a14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::HasOwnership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ownership of the attached Pylon device. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a Pylon device is attached and the Instant Camera object has been given the ownership by passing the cleanup procedure Cleanup_Delete when calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a9e04a31ff55e3c570e05a249edefb7c0" title="Attaches a Pylon device to the Instant Camera. ">Attach()</a>.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a06161d54cb6a6dee7958be0902f38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::Is1394 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if an IEEE 1394 Pylon device is attached to the Instant Camera object. </p>
<p>This method is provided for convenience only. The device type can also be determined as shown in the following example.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_device_class_8h.html">pylon/DeviceClass.h</a>&gt;</span></div><div class="line">...</div><div class="line">if (camera.GetDeviceInfo().GetDeviceClass() == <a class="code" href="group___pylon___transport_layer.html#ga040ff4ac8b3ab081eeb6516a82b21ddc">Basler1394DeviceClass</a>)</div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a454846d3efa5cd5838505017289019a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsBcon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a BCON Pylon device is attached to the Instant Camera object. </p>
<p>This method is provided for convenience only. The device type can also be determined as shown in the following example.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_device_class_8h.html">pylon/DeviceClass.h</a>&gt;</span></div><div class="line">...</div><div class="line">if (camera.GetDeviceInfo().GetDeviceClass() == <a class="code" href="group___pylon___transport_layer.html#gab51ba842cd587b522c180c2537151d07">BaslerBconDeviceClass</a>)</div><div class="line">{</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bc410c61618d7565455751991ce2791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsCameraDeviceRemoved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the connection state of the camera device. </p>
<dl class="section attention"><dt>Attention</dt><dd>Due to technical reasons, the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3bc410c61618d7565455751991ce2791" title="Returns the connection state of the camera device. ">IsCameraDeviceRemoved()</a> property may not be updated immediately after the first error caused by a device removal occurs.</dd></dl>
<p>The device removal is only detected while the Instant Camera and therefore the attached Pylon device are open.</p>
<p>The attached Pylon device is not operable anymore if the camera device has been removed from the PC. After it is made sure that no access to the Pylon device or any of its node maps is made anymore the Pylon device should be destroyed using CInstantCamera::DeviceDestroy(). The access to the Pylon device can be protected using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>, e.g. when accessing parameters.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the camera device removal from the PC has been detected.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a479697100a74a871558a3b503b1e4fec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsCameraLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a Camera Link Pylon device is attached to the Instant Camera object. </p>
<p>This method is provided for convenience only. The device type can also be determined as shown in the following example.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_device_class_8h.html">pylon/DeviceClass.h</a>&gt;</span></div><div class="line">...</div><div class="line">if (camera.GetDeviceInfo().GetDeviceClass() == <a class="code" href="group___pylon___transport_layer.html#ga374b96a1cb7b9929f3c987c55d116817">BaslerCameraLinkDeviceClass</a>)</div><div class="line">{</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abc423f34cccc79fa89a4e71344aa89e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsCxp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a CoaXPress GenTL device is attached to the Instant Camera object. </p>
<p>This method is provided for convenience only.</p>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a50d21834ee84f91052302ebc92c44922"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsGigE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a GigE Pylon device is attached to the Instant Camera object. </p>
<p>This method is provided for convenience only. The device type can also be determined as shown in the following example.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_device_class_8h.html">pylon/DeviceClass.h</a>&gt;</span></div><div class="line">...</div><div class="line">if (camera.GetDeviceInfo().GetDeviceClass() == <a class="code" href="group___pylon___transport_layer.html#gade01a67e2f6bac8ba92b2d430efbc026">BaslerGigEDeviceClass</a>)</div><div class="line">{</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d2155d0c74753808af267c34291858c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsGrabbing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns state of grabbing. </p>
<p>The camera object is grabbing after a successful call to <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed" title="Starts the grabbing of images. ">StartGrabbing()</a> until <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if still grabbing.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a0c0cff3ffcc15443884a8c9a8727a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the open state of the attached Pylon device object. </p>
<dl class="section note"><dt>Note</dt><dd>This method still returns true if the camera device has been physically removed from the PC while the attached Pylon device object is open. The Pylon device object will not automatically close itself on device removal. It must be closed by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a56fd8d061c6762f8f60e14a0e1345738" title="Closes the attached Pylon device. ">CInstantCamera::Close()</a>. The <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3bc410c61618d7565455751991ce2791" title="Returns the connection state of the camera device. ">IsCameraDeviceRemoved()</a> method can be used to check if the connection to the camera device has been lost while the attached Pylon device object is open. </dd></dl>
<dl class="section user"><dt>Error Safety: Does not throw C++ exceptions.</dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a Pylon device is attached and it is open. </dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0088d6161a718272d54ba7d214919a27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsPylonDeviceAttached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Pylon device attached state of the Instant Camera object. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a Pylon device is attached.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d3fd5e7e9f079ca304ca30d9e4860d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::IsUsb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a USB Pylon device is attached to the Instant Camera object. </p>
<p>This method is provided for convenience only. The device type can also be determined as shown in the following example.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_device_class_8h.html">pylon/DeviceClass.h</a>&gt;</span></div><div class="line">...</div><div class="line">if (camera.GetDeviceInfo().GetDeviceClass() == <a class="code" href="group___pylon___transport_layer.html#gab285d4c25cf8854e8cadc05f71366aae">BaslerUsbDeviceClass</a>)</div><div class="line">{</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d55354035ee749bc587b4d923a22c5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::Open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens the attached Pylon device. </p>
<ul>
<li>
Opened by user flag is set, preventing closing of the device on <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a>. </li>
<li>
If the Pylon device is already open, nothing more is done. </li>
<li>
The OnOpen configuration event is fired. The notification of event handlers stops when an event call triggers an exception. </li>
<li>
The Pylon device is opened and a connection to the camera device is established. </li>
<li>
The instant camera migration mode setting is applied to the Pylon device transport layer node map. </li>
<li>
A device removal call back is registered at the Pylon device. </li>
<li>
Callbacks for camera events are registered at the camera node map. </li>
<li>
The OnOpened configuration event is fired if the Pylon device has been opened successfully. The notification of event handlers stops when an event call triggers an exception. </li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>A Pylon device is attached.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The Pylon device is open and a connection to the camera device has been established. </li>
<li>
Opened by user flag is set, preventing closing of the Pylon device on <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error. The Pylon device open may throw. Configuration event calls may throw. Callback registrations may throw. The Pylon device is closed with <a class="el" href="class_pylon_1_1_c_instant_camera.html#a56fd8d061c6762f8f60e14a0e1345738" title="Closes the attached Pylon device. ">Close()</a> if the OnOpened event call triggers an exception.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#a2259eb38eb56652d48cca092ecd95877">Pylon::CDeviceSpecificInstantCameraT&lt; CameraTraitsT &gt;</a>, and <a class="el" href="class_pylon_1_1_c_device_specific_instant_camera_t.html#a2259eb38eb56652d48cca092ecd95877">Pylon::CDeviceSpecificInstantCameraT&lt; CBaslerUniversalInstantCameraTraits &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a87c99761ba31e7ecd256d344e5ad1eb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::RegisterCameraEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_camera_event_handler.html">CCameraEventHandler</a> *&#160;</td>
          <td class="paramname"><em>pCameraEventHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_pylon.html#a243b4b164b22d387ffd02a9ed20f15b9">String_t</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga6ad39f74e5f882a64461ad02c70567ed">ERegistrationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a>&#160;</td>
          <td class="paramname"><em>cleanupProcedure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga9a7a8dfdc280fbb3ae8cc4cb3af55d9c">ECameraEventAvailability</a>&#160;</td>
          <td class="paramname"><em>availability</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#gga9a7a8dfdc280fbb3ae8cc4cb3af55d9ca8bce3aba4fcbd4b5e2a49e851026b4d8">CameraEventAvailability_Mandatory</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an camera event handler to the list of registered camera event handler objects. </p>
<ul>
<li>
If mode equals RegistrationMode_ReplaceAll, the list of registered camera event handlers is cleared. </li>
<li>
If the pointer <code>pCameraEventHandler</code> is not NULL, it is appended to the list of camera event handlers. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCameraEventHandler</td><td>The receiver of camera events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeName</td><td>The name of the event data node updated on camera event, e.g. "ExposureEndEventTimestamp" for exposure end event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This ID is passed as a parameter in <a class="el" href="class_pylon_1_1_c_camera_event_handler.html#a7ead8a697266d0672778c1f8df8a4f37" title="This method is called when a camera event has been received. ">CCameraEventHandler::OnCameraEvent</a> and can be used to distinguish between different events. It is recommended to create an own application specific enum and use it's values as IDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates how to register the new cameraEventHandler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cleanupProcedure</td><td>If cleanupProcedure equals Cleanup_Delete, the passed event handler is deleted when no longer needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">availability</td><td>If availability equals CameraEventAvailability_Mandatory, the camera must support the data node specified by node name. If not, an exception is thrown when the Instant Camera is open, the Instant Camera is opened, or an open Pylon device is attached.</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, a <a class="el" href="namespace_gen_api.html" title="Contains definitions of the types of GenICam GenApi modules. ">GenApi</a> node call back is registered for the node identified by <code>nodeName</code>. This callback triggers a call to the <code><a class="el" href="class_pylon_1_1_c_camera_event_handler.html#a7ead8a697266d0672778c1f8df8a4f37" title="This method is called when a camera event has been received. ">CCameraEventHandler::OnCameraEvent()</a></code> method. That's why a Camera Event Handler can be registered for any node of the camera node map to get informed about changes.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The cameraEventHandler is registered and called on camera events.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the availability is set to CameraEventAvailability_Mandatory and the node with the name <code>nodeName</code> is not available in the camera node map (see <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3227195969200a52200364bf31e9c586" title="Provides access to the node map of the camera device. ">GetNodeMap()</a>). Throws an exception fail if the node callback registration fails. The event handler is not registered when an C++ exception is thrown.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the camera event handler lock. If the camera is open, the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a> and the camera node map lock are also used for synchronization. </dd></dl>

</div>
</div>
<a class="anchor" id="aefc4e8480ceec5fe3991f059e1c4d8d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::RegisterConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_configuration_event_handler.html">CConfigurationEventHandler</a> *&#160;</td>
          <td class="paramname"><em>pConfigurator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga6ad39f74e5f882a64461ad02c70567ed">ERegistrationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a>&#160;</td>
          <td class="paramname"><em>cleanupProcedure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a configurator to the list of registered configurator objects. </p>
<ul>
<li>
If mode equals RegistrationMode_ReplaceAll, the list of registered configurators is cleared. </li>
<li>
If pointer <code>pConfigurator</code> is not NULL, it is appended to the list of configurators. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pConfigurator</td><td>The receiver of configuration events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates how to register the new configurator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cleanupProcedure</td><td>If cleanupProcedure equals Cleanup_Delete, the passed event handler is deleted when no longer needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The configurator is registered and called on configuration events.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions, except when memory allocation fails.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a514f71e6302ab4f74f315ef778e5eaa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::RegisterImageEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_image_event_handler.html">CImageEventHandler</a> *&#160;</td>
          <td class="paramname"><em>pImageEventHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga6ad39f74e5f882a64461ad02c70567ed">ERegistrationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a>&#160;</td>
          <td class="paramname"><em>cleanupProcedure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an image event handler to the list of registered image event handler objects. </p>
<ul>
<li>
If mode equals RegistrationMode_ReplaceAll, the list of registered image event handlers is cleared. </li>
<li>
If pointer <code>pImageEventHandler</code> is not NULL, it is appended to the list of image event handlers. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pImageEventHandler</td><td>The receiver of image events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates how to register the new imageEventHandler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cleanupProcedure</td><td>If cleanupProcedure equals Cleanup_Delete, the passed event handler is deleted when no longer needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The imageEventHandler is registered and called on image related events.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions, except when memory allocation fails.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the internal image event handler registry lock. </dd></dl>

</div>
</div>
<a class="anchor" id="a3af3b05b85ea0aeb68eb5fb1b6dba0c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::RetrieveResult </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_c_grab_result_ptr.html">CGrabResultPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>grabResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga038e4dd8fbd49dd4e7ec17cc605d1344">ETimeoutHandling</a>&#160;</td>
          <td class="paramname"><em>timeoutHandling</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a grab result according to the strategy, waits if it is not yet available. </p>
<ul>
<li>
The content of the passed grab result is released. </li>
<li>
If no Pylon device is attached or the grabbing is not started, the method returns immediately "false". </li>
<li>
Wait for a grab result if it is not yet available. The access to the camera is not locked during waiting. Camera events are handled. </li>
<li>
Only if camera events are used: Incoming camera events are handled. </li>
<li>
One grab result is retrieved per call according to the strategy applied. </li>
<li>
Only if chunk mode is used: The chunk data parsing is performed. The grab result data is updated using chunk data. </li>
<li>
The image event OnImagesSkipped is fired if grab results have been skipped according to the strategy. The notification of event handlers stops when an event call triggers an exception. </li>
<li>
The image event OnImageGrabbed is fired if a grab result becomes available. The notification of event handlers stops when an event call triggers an exception. </li>
<li>
Stops the grabbing by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a> if the maximum number of images has been grabbed. </li>
</ul>
<p>It needs to be checked whether the grab represented by the grab result has been successful, see <a class="el" href="class_pylon_1_1_c_grab_result_data.html#a57fbc04cd2abf3bf6307e07131dd0503" title="Returns true if an image has been grabbed successfully and false in the case of an error...">CGrabResultData::GrabSucceeded()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMs</td><td>A timeout value in ms for waiting for a grab result, or the INFINITE value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grabResult</td><td>Receives the grab result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutHandling</td><td>If timeoutHandling equals TimeoutHandling_ThrowException, a timeout exception is thrown on timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the call successfully retrieved a grab result, false otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
There is no other thread waiting for a result. This will be the case when the Instant Camera grab loop thread is used. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If a grab result has been retrieved, one image is removed from the output queue and is returned in the grabResult parameter. </li>
<li>
If no grab result has been retrieved, an empty grab result is returned in the grabResult parameter. </li>
<li>
If the maximum number of images has been grabbed, the grabbing is stopped. </li>
<li>
If camera event handling is enabled and camera events were received, at least one or more camera event messages have been processed. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error. The grabbing is stopped if an exception is thrown.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a> while not waiting. </dd></dl>

</div>
</div>
<a class="anchor" id="a241b201d21860f4f8ba11cda277af957"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::SetBufferFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pylon_1_1_i_buffer_factory.html">IBufferFactory</a> *&#160;</td>
          <td class="paramname"><em>pFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#gae495d43181dadd7d44dc47ae1542fed5">ECleanup</a>&#160;</td>
          <td class="paramname"><em>cleanupProcedure</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an alternative buffer factory that is used for buffer allocation. </p>
<p>This use of this method is optional and intended for advanced use cases only.</p>
<p>If NULL is passed as buffer factory then the default buffer factory is used. Buffers are allocated when StartGrabbing is called. A buffer factory must not be deleted while it is attached to the camera object and it must not be deleted until the last buffer is freed. To free all buffers the grab needs to be stopped and all grab results must be released or destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFactory</td><td>A pointer to a buffer factory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cleanupProcedure</td><td>If ownership is cleanupProcedure Cleanup_Delete, the passed factory is destroyed when no longer needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="add8a80a19165e6e7403eda22de3d9064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::SetCameraContext </td>
          <td>(</td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a context that is attached to each grab result of the camera object on <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8" title="Retrieves a grab result according to the strategy, waits if it is not yet available. ">RetrieveResult()</a>. </p>
<p>This is useful when handling multiple cameras. It has nothing in common with the context passed to the stream grabber when queuing a buffer.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a386b84c29f9ee7ec3646fbfbf70236ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::StartGrabbing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga56a922b1bd37848234153b9e12f7fecb">EGrabStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#gaf582b0a1fa8604d4e18857bd525291e6">EGrabLoop</a>&#160;</td>
          <td class="paramname"><em>grabLoopType</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a1006c968199ded056843b9c42854b206">GrabLoop_ProvidedByUser</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the grabbing of images. </p>
<ul>
<li>
If a grab loop thread has been used in the last grab session, the grab loop thread context is joined with the caller's context. </li>
<li>
If the Pylon device is not already open, it is opened by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d55354035ee749bc587b4d923a22c5f" title="Opens the attached Pylon device. ">Open()</a>. </li>
<li>
The configuration event OnGrabStart is fired. The notification of event handlers stops when an event call triggers an exception. </li>
<li>
Grab-specific parameters of the camera object are locked, e.g. MaxNumBuffers. </li>
<li>
If the camera device parameter ChunkModeActive is enabled, the Instant Camera chunk parsing support is initialized. </li>
<li>
If the Instant Camera parameter GrabCameraEvents is enabled, the Instant Camera event grabbing support is initialized. </li>
<li>
The grabbing is started. </li>
<li>
The AcquisitionStart command of the camera device is executed. </li>
<li>
The configuration event OnGrabStarted is fired if the grab has been started successfully. The notification of event handlers stops when an event call triggers an exception. </li>
<li>
If grabLoopType equals GrabLoop_ProvidedByInstantCamera, an additional grab loop thread is started calling RetrieveResult( GrabLoopThreadTimeout, grabResult) in a loop. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strategy</td><td>The grab strategy. See <a class="el" href="group___pylon___instant_camera_api_generic.html#ga56a922b1bd37848234153b9e12f7fecb" title="Lists the possible grab strategies. ">Pylon::EGrabStrategy</a> for more information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grabLoopType</td><td>If grabLoopType equals GrabLoop_ProvidedByInstantCamera, an additional grab loop thread is used to run the grab loop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A Pylon device is attached. </li>
<li>
The stream grabber of the Pylon device is closed. </li>
<li>
The grabbing is stopped. </li>
<li>
The attached Pylon device supports grabbing. </li>
<li>
Must not be called while holding the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a> when using the grab loop thread. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The grabbing is started. </li>
<li>
Grab-specific parameters of the camera object are locked, e.g. MaxNumBuffers. </li>
<li>
If grabLoopType equals GrabLoop_ProvidedByInstantCamera, an additional grab loop thread is running that calls RetrieveResult( GrabLoopThreadTimeout, grabResult) in a loop. Images are processed by registered image event handlers. </li>
<li>
Operating the stream grabber from outside the camera object will result in undefined behavior. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The Instant Camera object is still valid after error. <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d55354035ee749bc587b4d923a22c5f" title="Opens the attached Pylon device. ">Open()</a> may throw. Configuration event calls may throw. The grab implementation may throw. The grabbing is stopped with <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f" title="Stops the grabbing of images. ">StopGrabbing()</a> if the OnGrabStarted event call triggers an exception. Throws a C++ exception, if Upcoming Image grab strategy is used together with USB camera devices.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a048529e40bbcbb7f30bd7b03ac2d72e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::StartGrabbing </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga56a922b1bd37848234153b9e12f7fecb">EGrabStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#gaf582b0a1fa8604d4e18857bd525291e6">EGrabLoop</a>&#160;</td>
          <td class="paramname"><em>grabLoopType</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a1006c968199ded056843b9c42854b206">GrabLoop_ProvidedByUser</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the grabbing for a maximum number of images. </p>
<p>Extends the StartGrabbing(EStrategy, EGrabLoop) by a number of images to grab. If the passed count of images has been reached, StopGrabbing is called automatically. The images are counted according to the grab strategy. Skipped images are not taken into account.</p>
<p>The amount of allocated buffers is reduced to maxImages when grabbing fewer images than according to the value of the <a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params__v6__1__0.html#a9205abb1850ef7e5f1a79fe2ccd377f9"><code>MaxNumBuffer</code> </a> parameter and the grab strategy is GrabStrategy_OneByOne.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxImages</td><td>The count of images to grab. This value must be larger than zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strategy</td><td>The grab strategy. See Pylon::InstantCamera::EStrategy for more information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grabLoopType</td><td>If grabLoopType equals GrabLoop_ProvidedByInstantCamera, an additional grab loop thread is used to run the grab loop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ef34cbfa61d4f0c2c1739bea5e5ee4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CInstantCamera::StopGrabbing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the grabbing of images. </p>
<ul>
<li>
Nothing is done if the Instant Camera is not currently grabbing. </li>
<li>
The configuration event OnGrabStop is fired. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
<li>
The AcquisitionStop command of the camera device is executed. </li>
<li>
The grabbing is stopped. </li>
<li>
All buffer queues of the Instant Camera are cleared. </li>
<li>
The OnGrabStopped configuration event is fired if the grab has been stopped successfully. Possible C++ exceptions from event calls are caught and ignored. All event handlers are notified. </li>
<li>
If the Instant Camera has been opened by StartGrabbing, it is closed by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a56fd8d061c6762f8f60e14a0e1345738" title="Closes the attached Pylon device. ">Close()</a>. </li>
<li>
Grab-specific parameters of the camera object are unlocked, e.g. MaxNumBuffers. </li>
</ul>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The grabbing is stopped. </li>
<li>
If the Pylon device has been opened by StartGrabbing and no other camera object service requires it to be open, it is closed. </li>
<li>
Grab specific parameters of the camera object are unlocked, e.g. MaxNumBuffers. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. Possible C++ exceptions are caught and ignored.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7506b5b38079ba4583a088a620187b29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CInstantCamera::WaitForFrameTriggerReady </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___instant_camera_api_generic.html#ga038e4dd8fbd49dd4e7ec17cc605d1344">ETimeoutHandling</a>&#160;</td>
          <td class="paramname"><em>timeoutHandling</em> = <code><a class="el" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actively waits until the the camera is ready to accept a frame trigger. </p>
<p>The implementation selects 'FrameTriggerWait' for the 'AcquisitionStatusSelector' and waits until the 'AcquisitionStatus' is true. If the above mentioned nodes are not available and the 'SoftwareTrigger' node is readable, the implementation waits for SoftwareTrigger.IsDone().</p>
<p>The WaitForFrameTriggerReady method does not work for A600 Firewire cameras.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMs</td><td>The timeout in ms for active waiting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutHandling</td><td>If timeoutHandling equals TimeoutHandling_ThrowException, a timeout exception is thrown on timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the camera can execute a frame trigger.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The 'AcquisitionStatusSelector' node is writable and the 'AcquisitionStatus' node is readable or the 'SoftwareTrigger' node is readable. This depends on the used camera model.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Accessing the camera registers may fail.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <a class="el" href="class_pylon_1_1_c_instant_camera.html#abe9d596c6ad821ff7d36945535684da3" title="Provides access to the lock used for synchronizing the access to the camera. ">GetLock()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6146e8376cf959658ebe363c6af76b8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::AcquisitionStartStopExecutionEnable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set, this will automatically execute AcquisitionStart when calling StartGrabbing and AcquisitionStop when calling StopGrabbing This option is enabled by default - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="aa9ea97177f145126ea04cad43c7f1a32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::ChunkNodeMapsEnable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables/disables the use of a chunk node map for each grab result Grab result chunk node maps can be disabled to save resources - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="a1536831bf959461851a860bde593e413"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::ClearBufferModeEnable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set, all buffers will be cleared (set to 0) before grabbing an image Note that this requires additional processing time per frame - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="a13e369783a9a6389ea22366e0ff6ce75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::GrabCameraEvents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables/disables the grabbing of camera events while images are grabbed Is writable when the camera object is closed - Applies to: InstantCamera. </p>
<p>Visibility: Expert </p>

</div>
</div>
<a class="anchor" id="a234277cb10664ba17c0fb28d1e5a5b99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::GrabLoopThreadPriority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The grab loop thread priority - Applies to: InstantCamera. </p>
<p>This value sets the absolute thread priority for the grab loop thread.</p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="afde4984a24386f79f184df8a22025c8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::GrabLoopThreadPriorityOverride</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If enabled, the user can set a custom priority for the grab loop thread Otherwise, the priority of the newly created thread is not changed - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="ad172893d678d609e7a42ec47cde296ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::GrabLoopThreadTimeout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A custom timeout for the grab loop thread's call to RetrieveResult RetrieveResult is configured to throw an exception on timeout, which will stop the grab session - Applies to: InstantCamera. </p>
<p>Visibility: Beginner </p>

</div>
</div>
<a class="anchor" id="a3d0fd49592b32fa6536fecc088d6738e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::GrabLoopThreadUseTimeout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If enabled, the user can set a custom timeout for the grab loop thread's call to RetrieveResult RetrieveResult is configured to throw an exception on timeout, which will stop the grab session - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="a635956dab71ee9e7b3773dc2592081e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::InternalGrabEngineThreadPriority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal grab engine thread priority - Applies to: InstantCamera. </p>
<p>This value sets the absolute thread priority for the internal grab engine thread operating the stream grabber.</p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="adb9e713a5af6d9170957c051650e01fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::InternalGrabEngineThreadPriorityOverride</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If enabled, the user can set a custom priority for the internal grab engine thread operating the stream grabber Otherwise the priority defaults to 25 - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="a9205abb1850ef7e5f1a79fe2ccd377f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::MaxNumBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of buffers that are allocated and used for grabbing - Applies to: InstantCamera. </p>
<p>Visibility: Beginner </p>

</div>
</div>
<a class="anchor" id="a7ddce05d310e007cba7498ecfb1a50bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::MaxNumGrabResults</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of grab results available at any time during a grab session This value can be limited to save resources Furthermore, it can be used to check that the grab results are returned correctly - Applies to: InstantCamera. </p>
<p>Visibility: Beginner </p>

</div>
</div>
<a class="anchor" id="ab91a278d159ff95e0c78c772a7259d67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::MaxNumQueuedBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of buffers that are queued in the stream grabber input queue - Applies to: InstantCamera. </p>
<p>Visibility: Beginner </p>

</div>
</div>
<a class="anchor" id="a1f502f113f04f3bda3fdb8d8bc502ac9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::MigrationModeActive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The migration mode is set up according to this setting at defined points e g , when the camera is opened - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="ae49c0a2eba56fc913af574e602e57aae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_boolean_ex.html">Pylon::IBooleanEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::MonitorModeActive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The camera object is set to monitor mode when enabled, e g when using the GigE multicast feature Is writable when the camera object is closed - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<a class="anchor" id="a4387e9f5f5556892f3b8ebcc12d9357a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::NumEmptyBuffers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of empty buffers that are not used for grabbing yet - Applies to: InstantCamera. </p>
<p>Visibility: Expert </p>

</div>
</div>
<a class="anchor" id="af6b3ae8b812c2c188f3382eea529a1af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::NumQueuedBuffers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of buffers queued at Low Level API stream grabber - Applies to: InstantCamera. </p>
<p>This is the number of buffers that are queued for grabbing in the stream grabber. The number is influenced by the number of available free buffers and the maximum number of buffers that can be queued. See also the MaxNumBuffer and MaxNumQueuedBuffer parameters.</p>
<p>This parameter can be used to check whether the number of buffers ready for grabbing is stable, which means that the image processing is fast enough to keep up with the rate of incoming images when using the GrabStrategy_OneByOne grab strategy.</p>
<p>Visibility: Expert </p>

</div>
</div>
<a class="anchor" id="a7c203b097f07da79cc35b3839451a410"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::NumReadyBuffers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of grab result buffers in the output queue that are ready for retrieval - Applies to: InstantCamera. </p>
<p>Visibility: Expert </p>

</div>
</div>
<a class="anchor" id="a36d1fe2d22ff3a2f21fda6e568049e07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::OutputQueueSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the grab result buffer output queue - Applies to: InstantCamera. </p>
<p>Visibility: Expert </p>

</div>
</div>
<a class="anchor" id="a745513e6c84f8c4e6bb7c1f725ee2e3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pylon_1_1_i_integer_ex.html">Pylon::IIntegerEx</a>&amp; Basler_InstantCameraParams::CInstantCameraParams_Params_v6_1_0::StaticChunkNodeMapPoolSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If larger than 0, a static chunk node map pool is used instead of dynamic chunk node map creation - Applies to: InstantCamera. </p>
<p>Visibility: Guru </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pylon/<a class="el" href="_instant_camera_8h.html">InstantCamera.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="projectname">pylon <span id="projectnumber">6.1.0</span></div>
<address><small>Copyright (c) 2006-2020 <a href="http://www.baslerweb.com/">Basler AG</a>   (Mon Mar 16 2020 10:57:00)</small></address>
</body>
</html>
