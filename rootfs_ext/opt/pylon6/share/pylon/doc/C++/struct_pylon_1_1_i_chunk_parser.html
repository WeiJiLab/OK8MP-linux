<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_pylon.html">Pylon</a></li><li class="navelem"><a class="el" href="struct_pylon_1_1_i_chunk_parser.html">IChunkParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interface_pylon_1_1_i_chunk_parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pylon::IChunkParser Interface Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___pylon___low_level_api.html">Low Level API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Low Level API: The interface for chunk parsers analyzing a data stream consisting of chunks.  
 <a href="struct_pylon_1_1_i_chunk_parser.html#details">More...</a></p>

<p><code>#include &lt;pylon/ChunkParser.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Pylon::IChunkParser:</div>
<div class="dyncontent">
<div class="center"><img src="struct_pylon_1_1_i_chunk_parser__inherit__graph.png" border="0" usemap="#_pylon_1_1_i_chunk_parser_inherit__map" alt="Inheritance graph"/></div>
<map name="_pylon_1_1_i_chunk_parser_inherit__map" id="_pylon_1_1_i_chunk_parser_inherit__map">
<area shape="rect" id="node2" href="struct_pylon_1_1_i_self_reliant_chunk_parser.html" title="Low Level API: Interface for chunk parsers with an own chunk data node map attached. " alt="" coords="5,80,175,121"/>
<area shape="rect" id="node3" href="class_pylon_1_1_c_chunk_parser.html" title="Low Level API: Base class for chunk parsers returned by camera objects. " alt="" coords="15,169,165,196"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf00ad3cddd2cfafd5f67fe0e525c5df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_chunk_parser.html#abf00ad3cddd2cfafd5f67fe0e525c5df">AttachBuffer</a> (const void *pBuffer, int64_t BufferLength, <a class="el" href="struct_gen_api_1_1_attach_statistics__t.html">GenApi::AttachStatistics_t</a> *pAttachStatistics=NULL)=0</td></tr>
<tr class="memdesc:abf00ad3cddd2cfafd5f67fe0e525c5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in a buffer and let the chunk parser analyze it.  <a href="#abf00ad3cddd2cfafd5f67fe0e525c5df">More...</a><br /></td></tr>
<tr class="separator:abf00ad3cddd2cfafd5f67fe0e525c5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df13e2e077db2ccd71f1e7030c95523"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_chunk_parser.html#a8df13e2e077db2ccd71f1e7030c95523">DetachBuffer</a> ()=0</td></tr>
<tr class="memdesc:a8df13e2e077db2ccd71f1e7030c95523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a buffer from the chunk parser. The buffer will no longer accessed by the chunk parser.  <a href="#a8df13e2e077db2ccd71f1e7030c95523">More...</a><br /></td></tr>
<tr class="separator:a8df13e2e077db2ccd71f1e7030c95523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57a3dc039fcf30066189f8888a402db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_chunk_parser.html#ae57a3dc039fcf30066189f8888a402db">UpdateBuffer</a> (const void *pBaseAddress)=0</td></tr>
<tr class="memdesc:ae57a3dc039fcf30066189f8888a402db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in a buffer and let the chunk parser update the camera object's parameters.  <a href="#ae57a3dc039fcf30066189f8888a402db">More...</a><br /></td></tr>
<tr class="separator:ae57a3dc039fcf30066189f8888a402db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774ea6638a134c3fcbecbd7506a5fadc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_chunk_parser.html#a774ea6638a134c3fcbecbd7506a5fadc">HasCRC</a> () const =0</td></tr>
<tr class="memdesc:a774ea6638a134c3fcbecbd7506a5fadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if buffer has a CRC attached.  <a href="#a774ea6638a134c3fcbecbd7506a5fadc">More...</a><br /></td></tr>
<tr class="separator:a774ea6638a134c3fcbecbd7506a5fadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5fcbd36a9d52cf62c985fb4c76e6b1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_chunk_parser.html#afa5fcbd36a9d52cf62c985fb4c76e6b1">CheckCRC</a> () const =0</td></tr>
<tr class="memdesc:afa5fcbd36a9d52cf62c985fb4c76e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks CRC sum of buffer.  <a href="#afa5fcbd36a9d52cf62c985fb4c76e6b1">More...</a><br /></td></tr>
<tr class="separator:afa5fcbd36a9d52cf62c985fb4c76e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low Level API: The interface for chunk parsers analyzing a data stream consisting of chunks. </p>
<p>When chunk data is enabled in the camera the stream sends additional data along with the image. This data needs to be extracted with help of a chunk parser. These are created using the camera's member function <a class="el" href="struct_pylon_1_1_i_pylon_device.html#ae12a77eb59b95ba9ef4feb369905b55f" title="Creates a chunk parser used to update those camera object members reflecting the content of additiona...">IPylonDevice::CreateChunkParser()</a>.</p>
<p>When an image buffer containing chunked data is passed to a chunk parser, the camera's chunk related parameters are updated. After changing the data layout either by changing the AOI or enabling/disabling chunk features the parser needs to be reinitialized by calling <a class="el" href="struct_pylon_1_1_i_chunk_parser.html#abf00ad3cddd2cfafd5f67fe0e525c5df" title="Pass in a buffer and let the chunk parser analyze it. ">IChunkParser::AttachBuffer()</a>. Thereafter buffers with the same layout are processed with the <a class="el" href="struct_pylon_1_1_i_chunk_parser.html#ae57a3dc039fcf30066189f8888a402db" title="Pass in a buffer and let the chunk parser update the camera object&#39;s parameters. ">IChunkParser::UpdateBuffer()</a> method. Chunk related properties remain unchanged until a new buffer is passed in.</p>
<p>After usage return the chunk parser with a call of the camera's <a class="el" href="struct_pylon_1_1_i_pylon_device.html#a30524c8f50fe32d7c63cf8142300bf87" title="Deletes a chunk parser. ">IPylonDevice::DestroyChunkParser()</a> member function.</p>
<p>The code snippet below demonstrates the usage of a chunk parser. A complete program is found in the sample AcquireSingleFrame_ChunkImage.</p>
<dl class="section note"><dt>Note</dt><dd>Check the payload type of the GrabResult_t before attaching or updating the buffer.</dd></dl>
<div class="fragment"><div class="line">IChunkParser &amp;ChunkParser = *Camera.CreateChunkParser();</div><div class="line"></div><div class="line"><span class="comment">// enable Frame Counter chunk</span></div><div class="line">Camera.ChunkModeActive.SetValue( <span class="keyword">true</span> );</div><div class="line">Camera.ChunkSelector.SetValue( ChunkSelector_Framecounter );</div><div class="line">Camera.ChunkEnable.SetValue( <span class="keyword">true</span> );</div><div class="line"></div><div class="line"><span class="comment">// retrieve data from the chunk</span></div><div class="line">GrabResult Result;</div><div class="line"><span class="keywordflow">if</span> (StreamGrabber.RetrieveResult( Result ) &amp;&amp;</div><div class="line">    Result.Succeeded() &amp;&amp;</div><div class="line">    Result.PayloadType() == <a class="code" href="group___pylon___instant_camera_api_generic.html#ggaf50b993da3a56a8a843e4d54e15b2329a5424a047d0e7ac6d548ced0dcad05b3e">PayloadType_ChunkData</a>)</div><div class="line">{</div><div class="line">    ChunkParser.AttachBuffer( Result.Buffer(), Result.GetPayloadSize() );</div><div class="line">    int64_t frameCounter = Camera.ChunkFramecounter.GetValue();</div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abf00ad3cddd2cfafd5f67fe0e525c5df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IChunkParser::AttachBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>BufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_gen_api_1_1_attach_statistics__t.html">GenApi::AttachStatistics_t</a> *&#160;</td>
          <td class="paramname"><em>pAttachStatistics</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass in a buffer and let the chunk parser analyze it. </p>
<p>Corresponding parameters of the camera object reflecting the chunked data will be updated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>Pointer to the new buffer </td></tr>
    <tr><td class="paramname">BufferLength</td><td>Size of the new buffer in bytes </td></tr>
    <tr><td class="paramname">pAttachStatistics</td><td>(optional) Pointer to a record taking statistic data of the analyzed buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_pylon_1_1_c_chunk_parser.html#ab24a8bd2ac2f56686937130175265df7">Pylon::CChunkParser</a>.</p>

</div>
</div>
<a class="anchor" id="afa5fcbd36a9d52cf62c985fb4c76e6b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::IChunkParser::CheckCRC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks CRC sum of buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the contained CRC equals the computed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a8df13e2e077db2ccd71f1e7030c95523"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IChunkParser::DetachBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches a buffer from the chunk parser. The buffer will no longer accessed by the chunk parser. </p>
<p>An attached buffer must be detached before freeing it. When attaching a new buffer, the previous one gets detached automatically. </p>

<p>Implemented in <a class="el" href="class_pylon_1_1_c_chunk_parser.html#ab79478220ea36ea0f648ac40d4f433a5">Pylon::CChunkParser</a>.</p>

</div>
</div>
<a class="anchor" id="a774ea6638a134c3fcbecbd7506a5fadc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::IChunkParser::HasCRC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if buffer has a CRC attached. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer contains CRC value. </dd></dl>

</div>
</div>
<a class="anchor" id="ae57a3dc039fcf30066189f8888a402db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IChunkParser::UpdateBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBaseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass in a buffer and let the chunk parser update the camera object's parameters. </p>
<p>This method can be used when the layout of the chunk data hasn't changed since a previous buffer has been attached to the chunk parser. In this case UpdateBuffer is slightly faster than AttachBuffer, because the buffer's layout is reused. If you call UpdateBuffer without having called AttachBuffer first, a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> is raised. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBaseAddress</td><td>Pointer to the new buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_pylon_1_1_c_chunk_parser.html#a40b4fa8e55ca6ca03e3602b5f7beeba1">Pylon::CChunkParser</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>pylon/<a class="el" href="_chunk_parser_8h.html">ChunkParser.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="projectname">pylon <span id="projectnumber">6.1.0</span></div>
<address><small>Copyright (c) 2006-2020 <a href="http://www.baslerweb.com/">Basler AG</a>   (Mon Mar 16 2020 10:57:00)</small></address>
</body>
</html>
