<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image Handling Support</div>  </div>
</div><!--header-->
<div class="contents">

<p>Besides the Instant Camera classes used for grabbing images pylon offers additional classes that support handling the grabbed images.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_image.html">Pylon::IImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usable to access image properties and image buffer.  <a href="struct_pylon_1_1_i_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html">Pylon::CImageFormatConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new images by converting a source image to another format.  <a href="class_pylon_1_1_c_image_format_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_persistence_options.html">Pylon::CImagePersistenceOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to pass options to <a class="el" href="class_pylon_1_1_c_image_persistence.html" title="Contains static functions supporting loading and saving of images. ">CImagePersistence</a> methods.  <a href="class_pylon_1_1_c_image_persistence_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_persistence.html">Pylon::CImagePersistence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains static functions supporting loading and saving of images.  <a href="class_pylon_1_1_c_image_persistence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_s_b_g_r_a8_pixel.html">Pylon::SBGRA8Pixel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the memory layout of a BGRA8 pixel. This pixel is used in Windows bitmaps.  <a href="struct_pylon_1_1_s_b_g_r_a8_pixel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_s_b_g_r8_pixel.html">Pylon::SBGR8Pixel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the memory layout of a BGR8 pixel. This pixel is used in Windows bitmaps.  <a href="struct_pylon_1_1_s_b_g_r8_pixel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_s_r_g_b8_pixel.html">Pylon::SRGB8Pixel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the memory layout of a RGB8 pixel.  <a href="struct_pylon_1_1_s_r_g_b8_pixel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_s_r_g_b16_pixel.html">Pylon::SRGB16Pixel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the memory layout of a RGB16 pixel.  <a href="struct_pylon_1_1_s_r_g_b16_pixel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_s_y_u_v422___u_y_v_y.html">Pylon::SYUV422_UYVY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the memory layout of a YUV422_UYVY pixel with information about brightness and chroma for two pixels.  <a href="struct_pylon_1_1_s_y_u_v422___u_y_v_y.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_s_y_u_v422___y_u_y_v.html">Pylon::SYUV422_YUYV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the memory layout of a YUV422_YUYV pixel with information about brightness and chroma for two pixels.  <a href="struct_pylon_1_1_s_y_u_v422___y_u_y_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_s_pixel_data.html">Pylon::SPixelData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the data of one pixel.  <a href="struct_pylon_1_1_s_pixel_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image.html">Pylon::CPylonImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes an image.  <a href="class_pylon_1_1_c_pylon_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_pylon_image_base.html">Pylon::CPylonImageBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides basic functionality for pylon image classes.  <a href="class_pylon_1_1_c_pylon_image_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_reusable_image.html">Pylon::IReusableImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the <a class="el" href="struct_pylon_1_1_i_image.html" title="Usable to access image properties and image buffer. ">IImage</a> interface to be able to reuse the image's resources to represent a different image.  <a href="struct_pylon_1_1_i_reusable_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad31d735d6a6499bb4f568a36d4f43747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad31d735d6a6499bb4f568a36d4f43747"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gad31d735d6a6499bb4f568a36d4f43747">Pylon::IsMonoPacked</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gad31d735d6a6499bb4f568a36d4f43747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pixel type is Mono and the pixel values are not byte aligned. <br /></td></tr>
<tr class="separator:gad31d735d6a6499bb4f568a36d4f43747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d57797efdd5949e96962f6b461d7d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84d57797efdd5949e96962f6b461d7d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga84d57797efdd5949e96962f6b461d7d0">Pylon::IsBayerPacked</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga84d57797efdd5949e96962f6b461d7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pixel type is Bayer and the pixel values are not byte aligned. <br /></td></tr>
<tr class="separator:ga84d57797efdd5949e96962f6b461d7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8604322badf1ffca82fecd671488543c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8604322badf1ffca82fecd671488543c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga8604322badf1ffca82fecd671488543c">Pylon::IsRGBPacked</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga8604322badf1ffca82fecd671488543c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pixel type is RGB and the pixel values are not byte aligned. <br /></td></tr>
<tr class="separator:ga8604322badf1ffca82fecd671488543c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410f0dd8b3004a56d1b7fc93344345ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga410f0dd8b3004a56d1b7fc93344345ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga410f0dd8b3004a56d1b7fc93344345ed">Pylon::IsBGRPacked</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga410f0dd8b3004a56d1b7fc93344345ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pixel type is BGR and the pixel values are not byte aligned. <br /></td></tr>
<tr class="separator:ga410f0dd8b3004a56d1b7fc93344345ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34f72b29074831f40a685c3da18776c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa34f72b29074831f40a685c3da18776c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gaa34f72b29074831f40a685c3da18776c">Pylon::IsPacked</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gaa34f72b29074831f40a685c3da18776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pixels of the given pixel type are not byte aligned. <br /></td></tr>
<tr class="separator:gaa34f72b29074831f40a685c3da18776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28dc6c70905f4c0eaceca7d5060f50db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga28dc6c70905f4c0eaceca7d5060f50db">Pylon::IsPackedInLsbFormat</a> (EPixelType pixelType)</td></tr>
<tr class="separator:ga28dc6c70905f4c0eaceca7d5060f50db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45afd1397817675adec052653595c24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae45afd1397817675adec052653595c24"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gae45afd1397817675adec052653595c24">Pylon::PlaneCount</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gae45afd1397817675adec052653595c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of planes in the image composed of the pixel type. <br /></td></tr>
<tr class="separator:gae45afd1397817675adec052653595c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd04d13cbb54a86ca29d25afc33cf981"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd04d13cbb54a86ca29d25afc33cf981"></a>
EPixelType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gadd04d13cbb54a86ca29d25afc33cf981">Pylon::GetPlanePixelType</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gadd04d13cbb54a86ca29d25afc33cf981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pixel type of a plane. <br /></td></tr>
<tr class="separator:gadd04d13cbb54a86ca29d25afc33cf981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga708cb9771247c5093a3f96df67d5abb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga708cb9771247c5093a3f96df67d5abb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga708cb9771247c5093a3f96df67d5abb3">Pylon::IsPlanar</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga708cb9771247c5093a3f96df67d5abb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if images of the pixel type are divided into multiple planes. <br /></td></tr>
<tr class="separator:ga708cb9771247c5093a3f96df67d5abb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a4f8c221a2302e9baab3068e1c7916c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a4f8c221a2302e9baab3068e1c7916c"></a>
EPixelColorFilter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga9a4f8c221a2302e9baab3068e1c7916c">Pylon::GetPixelColorFilter</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga9a4f8c221a2302e9baab3068e1c7916c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Bayer color filter type. <br /></td></tr>
<tr class="separator:ga9a4f8c221a2302e9baab3068e1c7916c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1edb0667000ba8d09be587fd1534915"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gaf1edb0667000ba8d09be587fd1534915">Pylon::BitPerPixel</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gaf1edb0667000ba8d09be587fd1534915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bits needed to store a pixel.  <a href="group___pylon___image_handling_support.html#gaf1edb0667000ba8d09be587fd1534915">More...</a><br /></td></tr>
<tr class="separator:gaf1edb0667000ba8d09be587fd1534915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b0371eb8bd99d8bf51135302eadd5f5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga9b0371eb8bd99d8bf51135302eadd5f5">Pylon::SamplesPerPixel</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga9b0371eb8bd99d8bf51135302eadd5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of measured values per pixel.  <a href="group___pylon___image_handling_support.html#ga9b0371eb8bd99d8bf51135302eadd5f5">More...</a><br /></td></tr>
<tr class="separator:ga9b0371eb8bd99d8bf51135302eadd5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb9adb1c6ce0e9b5c9ec6492fbfcbd28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb9adb1c6ce0e9b5c9ec6492fbfcbd28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gadb9adb1c6ce0e9b5c9ec6492fbfcbd28">Pylon::IsYUV</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gadb9adb1c6ce0e9b5c9ec6492fbfcbd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the pixel type represents a YUV format. <br /></td></tr>
<tr class="separator:gadb9adb1c6ce0e9b5c9ec6492fbfcbd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6cf268dffa0bec5bae3bc687205a24d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6cf268dffa0bec5bae3bc687205a24d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gae6cf268dffa0bec5bae3bc687205a24d">Pylon::IsRGBA</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gae6cf268dffa0bec5bae3bc687205a24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the pixel type represents an RGBA format. <br /></td></tr>
<tr class="separator:gae6cf268dffa0bec5bae3bc687205a24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca37e43961be66705b1dee83ef0915c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadca37e43961be66705b1dee83ef0915c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gadca37e43961be66705b1dee83ef0915c">Pylon::IsRGB</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gadca37e43961be66705b1dee83ef0915c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the pixel type represents an RGB or RGBA format. <br /></td></tr>
<tr class="separator:gadca37e43961be66705b1dee83ef0915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f2eb00a850ba1b30abfcafe9591241d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f2eb00a850ba1b30abfcafe9591241d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga5f2eb00a850ba1b30abfcafe9591241d">Pylon::IsBGRA</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga5f2eb00a850ba1b30abfcafe9591241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the pixel type represents a BGRA format. <br /></td></tr>
<tr class="separator:ga5f2eb00a850ba1b30abfcafe9591241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d4303bd7be3bb3fe2a87b24d0ead859"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d4303bd7be3bb3fe2a87b24d0ead859"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga4d4303bd7be3bb3fe2a87b24d0ead859">Pylon::IsBGR</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga4d4303bd7be3bb3fe2a87b24d0ead859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the pixel type represents a BGR or BGRA format. <br /></td></tr>
<tr class="separator:ga4d4303bd7be3bb3fe2a87b24d0ead859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd030e31339caa81ce7d44b865610745"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabd030e31339caa81ce7d44b865610745"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gabd030e31339caa81ce7d44b865610745">Pylon::IsBayer</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gabd030e31339caa81ce7d44b865610745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the pixel type represents a Bayer format. <br /></td></tr>
<tr class="separator:gabd030e31339caa81ce7d44b865610745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac53b1cdbd531172e4d503cb4e14cd245"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac53b1cdbd531172e4d503cb4e14cd245"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gac53b1cdbd531172e4d503cb4e14cd245">Pylon::IsMono</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gac53b1cdbd531172e4d503cb4e14cd245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when a given pixel is monochrome, e.g. PixelType_Mono8 or PixelType_BayerGR8. <br /></td></tr>
<tr class="separator:gac53b1cdbd531172e4d503cb4e14cd245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4c1eef8c3249b856a9f6560e404c8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f4c1eef8c3249b856a9f6560e404c8e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga6f4c1eef8c3249b856a9f6560e404c8e">Pylon::IsMonoImage</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga6f4c1eef8c3249b856a9f6560e404c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when an image using the given pixel type is monochrome, e.g. PixelType_Mono8. <br /></td></tr>
<tr class="separator:ga6f4c1eef8c3249b856a9f6560e404c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace42e0ebbde7d08e10bfd5cfa951cc3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace42e0ebbde7d08e10bfd5cfa951cc3f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gace42e0ebbde7d08e10bfd5cfa951cc3f">Pylon::IsColorImage</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gace42e0ebbde7d08e10bfd5cfa951cc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when an image using the given pixel type is a color image (RGB/BGR/RGBA/BGRA/ etc or Bayer. <br /></td></tr>
<tr class="separator:gace42e0ebbde7d08e10bfd5cfa951cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba707f639b89eab74d71b70a51c7518"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ba707f639b89eab74d71b70a51c7518"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga0ba707f639b89eab74d71b70a51c7518">Pylon::HasAlpha</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga0ba707f639b89eab74d71b70a51c7518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when an the image using the given pixel type has an alpha channel. <br /></td></tr>
<tr class="separator:ga0ba707f639b89eab74d71b70a51c7518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1f7b3c87b99ad5e92ef1ce6d7db0a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacb1f7b3c87b99ad5e92ef1ce6d7db0a2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gacb1f7b3c87b99ad5e92ef1ce6d7db0a2">Pylon::GetPixelIncrementX</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gacb1f7b3c87b99ad5e92ef1ce6d7db0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum step size expressed in pixels for extracting an AOI. <br /></td></tr>
<tr class="separator:gacb1f7b3c87b99ad5e92ef1ce6d7db0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ef2101cdd62450eadc7c08f21a5df2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga21ef2101cdd62450eadc7c08f21a5df2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga21ef2101cdd62450eadc7c08f21a5df2">Pylon::GetPixelIncrementY</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:ga21ef2101cdd62450eadc7c08f21a5df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum step size expressed in pixels for extracting an AOI. <br /></td></tr>
<tr class="separator:ga21ef2101cdd62450eadc7c08f21a5df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac717c32f1717b871ef8c76595e831b6e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gac717c32f1717b871ef8c76595e831b6e">Pylon::BitDepth</a> (EPixelType pixelType)</td></tr>
<tr class="memdesc:gac717c32f1717b871ef8c76595e831b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit depth of a value of the pixel in bits.  <a href="group___pylon___image_handling_support.html#gac717c32f1717b871ef8c76595e831b6e">More...</a><br /></td></tr>
<tr class="separator:gac717c32f1717b871ef8c76595e831b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga716a806dfdabb206952bcefcbfe4b0eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga716a806dfdabb206952bcefcbfe4b0eb">Pylon::ComputeStride</a> (size_t &amp;strideBytes, EPixelType pixelType, uint32_t width, size_t paddingX=0)</td></tr>
<tr class="memdesc:ga716a806dfdabb206952bcefcbfe4b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the stride in byte.  <a href="group___pylon___image_handling_support.html#ga716a806dfdabb206952bcefcbfe4b0eb">More...</a><br /></td></tr>
<tr class="separator:ga716a806dfdabb206952bcefcbfe4b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9593b9c03df7d1b19e342e9b7ff50c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gabb9593b9c03df7d1b19e342e9b7ff50c">Pylon::ComputePaddingX</a> (size_t strideBytes, EPixelType pixelType, uint32_t width)</td></tr>
<tr class="memdesc:gabb9593b9c03df7d1b19e342e9b7ff50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the padding value from row stride in byte.  <a href="group___pylon___image_handling_support.html#gabb9593b9c03df7d1b19e342e9b7ff50c">More...</a><br /></td></tr>
<tr class="separator:gabb9593b9c03df7d1b19e342e9b7ff50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a02f2d51768384ef52c27c0e0d6bb5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#ga31a02f2d51768384ef52c27c0e0d6bb5">Pylon::ComputeBufferSize</a> (EPixelType pixelType, uint32_t width, uint32_t height, size_t paddingX=0)</td></tr>
<tr class="memdesc:ga31a02f2d51768384ef52c27c0e0d6bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the buffer size in byte.  <a href="group___pylon___image_handling_support.html#ga31a02f2d51768384ef52c27c0e0d6bb5">More...</a><br /></td></tr>
<tr class="separator:ga31a02f2d51768384ef52c27c0e0d6bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa68692447d311facefc6fcb189e1fa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pylon___image_handling_support.html#gafa68692447d311facefc6fcb189e1fa8">Pylon::GetPixelTypesForUnpacking</a> (EPixelType pixelTypeSource, EPixelType &amp;pixelTypeToImpose, EPixelType &amp;pixelTypeTarget)</td></tr>
<tr class="memdesc:gafa68692447d311facefc6fcb189e1fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pixel types needed for conversion from packed to unpacked image formats using the <a class="el" href="class_pylon_1_1_c_image_format_converter.html" title="Creates new images by converting a source image to another format. ">CImageFormatConverter</a> class.  <a href="group___pylon___image_handling_support.html#gafa68692447d311facefc6fcb189e1fa8">More...</a><br /></td></tr>
<tr class="separator:gafa68692447d311facefc6fcb189e1fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Besides the Instant Camera classes used for grabbing images pylon offers additional classes that support handling the grabbed images. </p>
<p>You can find more information here: </p><ul>
<li><a class="el" href="pylon_programmingguide.html#hi_image_handling">Image Handling</a> </li>
</ul>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga8bf3ed15161132846cd68070762ba2bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___pylon___image_handling_support.html#ga8bf3ed15161132846cd68070762ba2bd">Pylon::EImageFileFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the available file formats. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8bf3ed15161132846cd68070762ba2bda9474c4f4880b9fd6acb85132357f8490"></a>ImageFileFormat_Tiff&#160;</td><td class="fielddoc">
<p>Tagged Image File Format, no compression, supports mono images with more than 8 bit bit depth. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8bf3ed15161132846cd68070762ba2bda6a2ec5f9ee0cf11fa1417b73bf5ccef1"></a>ImageFileFormat_Png&#160;</td><td class="fielddoc">
<p>Portable Network Graphics, lossless data compression. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8bf3ed15161132846cd68070762ba2bda1ab4e3ae6094afe8f2602f6e6e9790ea"></a>ImageFileFormat_Raw&#160;</td><td class="fielddoc">
<p>Saves the raw image buffer data. Packed image formats are unpacked. See <a class="el" href="group___pylon___image_handling_support.html#gafa68692447d311facefc6fcb189e1fa8" title="Returns the pixel types needed for conversion from packed to unpacked image formats using the CImageF...">GetPixelTypesForUnpacking()</a> for more information. This format cannot be loaded unsing <a class="el" href="class_pylon_1_1_c_image_persistence.html#a788383f8c5747eb4c85c8259dfe6ad99" title="Loads an image from disk. ">CImagePersistence::Load()</a>. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga710fdd7cf7f7516c56b90cbdf0085f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">Pylon::EImageOrientation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the vertical orientation of an image in memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga710fdd7cf7f7516c56b90cbdf0085f70aa3a5473ebd7fe7ec97418120bdac6e95"></a>ImageOrientation_TopDown&#160;</td><td class="fielddoc">
<p>The first row of the image is located at the start of the image buffer. This is the default for images taken by a camera. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga710fdd7cf7f7516c56b90cbdf0085f70ae1f42994440eb05088eee5c81fd5c9f2"></a>ImageOrientation_BottomUp&#160;</td><td class="fielddoc">
<p>The last row of the image is located at the start of the image buffer. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga097b5738ad0a0549a79c08b778a82011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___pylon___image_handling_support.html#ga097b5738ad0a0549a79c08b778a82011">Pylon::EPixelColorFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the Bayer color filter types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga097b5738ad0a0549a79c08b778a82011a49d09ddf9eb62db7fabe043b49f4e205"></a>PCF_BayerRG&#160;</td><td class="fielddoc">
<p>red green </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga097b5738ad0a0549a79c08b778a82011a09c299c6cb533cb27ee62a70e94fdfc8"></a>PCF_BayerGB&#160;</td><td class="fielddoc">
<p>green blue </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga097b5738ad0a0549a79c08b778a82011a70304ec0cb653c70461e8e0eb4e4770a"></a>PCF_BayerGR&#160;</td><td class="fielddoc">
<p>green red </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga097b5738ad0a0549a79c08b778a82011ab84f22b08fbf96c48c28ff347c096110"></a>PCF_BayerBG&#160;</td><td class="fielddoc">
<p>blue green </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga097b5738ad0a0549a79c08b778a82011ac11aec5e59fe828f4ffbcc2cbe7ffd00"></a>PCF_Undefined&#160;</td><td class="fielddoc">
<p>undefined color filter or not applicable </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga159b4bb49b4973a30bc8b39a4fcf3067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">Pylon::EPixelType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the available pixel types. </p>
<p>These pixel types are returned by a grab result and are used by the Image Handling Support classes.</p>
<p>The camera parameter interface classes define additional pixel format enumerations. These pixel format enumerations are different from the enumeration EPixelType pylon uses, e.g. the pylon pixel type PixelType_Mono1packed corresponds to PixelFormat_Mono1packed or PixelFormat_Mono1p. See the documentation of the parameter interface classes for more information.</p>
<p>The camera User's Manual provides more information on pixel formats and the memory layout of the image data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067abf180ef8c969c81c0e2fe1978a142cc1"></a>PixelType_Undefined&#160;</td><td class="fielddoc">
<p>Undefined pixel type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ae9265a02192c3b4082fc02c69b1fcd26"></a>PixelType_Mono1packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono1Packed or PixelFormat_Mono1p </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a0f6390d0f91e108acb16d96964a5bcec"></a>PixelType_Mono2packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono2Packed or PixelFormat_Mono2p </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067aeb8ce37fd0cd49b10d8cb976caa350d0"></a>PixelType_Mono4packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono4Packed or PixelFormat_Mono4p </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ac5f47f20839fba7496c9c6e7f9f10457"></a>PixelType_Mono8&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a70992e855c2ee64cd71b86f727a06121"></a>PixelType_Mono8signed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono8signed or PixelFormat_Mono8s </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ad2585ebe7ea7fdf85f267f3fb2d25477"></a>PixelType_Mono10&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067aaa14e33414207f5e86e611147c1fb55a"></a>PixelType_Mono10packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono10Packed. The memory layouts of PixelType_Mono10packed and PixelType_Mono10p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a156f2de7dfbfed71b5f242e79d97038c"></a>PixelType_Mono10p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono10p. The memory layouts of PixelType_Mono10packed and PixelType_Mono10p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a99496721756db23ae8879a51d54e11ef"></a>PixelType_Mono12&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono12 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a05662b9af5d2b9acee70aca861b674a7"></a>PixelType_Mono12packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono12Packed. The memory layouts of PixelType_Mono12packed and PixelType_Mono12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067aa5072da01d209eff8fa37795910f7ad8"></a>PixelType_Mono12p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono12p. The memory layouts of PixelType_Mono12packed and PixelType_Mono12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a71cbd9075e8bffa35e39c4aafefcd631"></a>PixelType_Mono16&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Mono16 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a077485e67dc83d4e7f1c5e97424fdf23"></a>PixelType_BayerGR8&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGR8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a5d9657d8166359728b99479e3c2aefa4"></a>PixelType_BayerRG8&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerRG8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067abc3f9932597b6457c034680441cc767b"></a>PixelType_BayerGB8&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGB8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a9d782b23feb146cd79a5cbc8ea42a852"></a>PixelType_BayerBG8&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerBG8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a018589de1ca66a59d4dd29e5bc13bbd9"></a>PixelType_BayerGR10&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGR10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ad1368931942bf51b4743e5a9cfbdac92"></a>PixelType_BayerRG10&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerRG10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ab261e77f7a968e3722f151e689b43937"></a>PixelType_BayerGB10&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGB10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067aecbd39f18098cad02c2b66dfb8c99feb"></a>PixelType_BayerBG10&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerBG10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a07a99fac745314508a46c2cd70c04bc5"></a>PixelType_BayerGR12&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGR12 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ab4a414d9ec4262ea1354416e0bae7fe4"></a>PixelType_BayerRG12&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerRG12 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a75afe33478ad215de5624ad7d6f96099"></a>PixelType_BayerGB12&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGB12 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067acd443a38f9bca9ef2e236baca4ba2b1e"></a>PixelType_BayerBG12&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerBG12 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067aed40cb79221f2ecf6af9170d10cb17bc"></a>PixelType_RGB8packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB8Packed or PixelFormat_RGB8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ab49f2952dd6a68835d6619cf771db015"></a>PixelType_BGR8packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BGR8Packed or PixelFormat_BGR8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a0d88b2cf4a6fc2099e5d612d8b0fd56e"></a>PixelType_RGBA8packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGBA8Packed or PixelFormat_RGBa8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a76bf9b43cbfd9ead04226d387a49ea02"></a>PixelType_BGRA8packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BGRA8Packed or PixelFormat_BGRa8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ada92edd13dc66af026f882780dba8adf"></a>PixelType_RGB10packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB10Packed or PixelFormat_RGB10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a1d60bcdb127849cff27cb7b2d677290d"></a>PixelType_BGR10packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BGR10Packed or PixelFormat_BGR10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ad04fc524065c40e05d01348c8ae8428f"></a>PixelType_RGB12packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB12Packed or PixelFormat_RGB12 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a0a00e267facebe0705fbc319946240e0"></a>PixelType_BGR12packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BGR12Packed or PixelFormat_BGR12 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067aff00240097210121652eabf0a69032a8"></a>PixelType_RGB16packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB16Packed or PixelFormat_RGB16 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067af5631ccf522d57f2fb19cfc77c9715b0"></a>PixelType_BGR10V1packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BGR10V1Packed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a60bd95789c722af0edf1727b095036c6"></a>PixelType_BGR10V2packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BGR10V2Packed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a36b0883b80a57f7ffd84b0ecf6bbc3bf"></a>PixelType_YUV411packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_YUV411Packed or PixelFormat_YCbCr411_8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a4922a74853463f0723232edf3e34f0d6"></a>PixelType_YUV422packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_YUV422Packed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a4f7e5f9ff2e5851b5151060ca89863e6"></a>PixelType_YUV444packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_YUV444Packed or PixelFormat_YCbCr8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ad6977d3d0a9dda6cd8dad71fd736ed5f"></a>PixelType_RGB8planar&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB8Planar or PixelFormat_RGB8_Planar </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a95194d7c672bc2163a69c99b9c56ce99"></a>PixelType_RGB10planar&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB10Planar or PixelFormat_RGB10_Planar </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a7cbe52f88242b8d53115aaae4e0f62e6"></a>PixelType_RGB12planar&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB12Planar or PixelFormat_RGB12_Planar </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a9cdc7601247fa18fb1609b9fca3db11e"></a>PixelType_RGB16planar&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB16Planar or PixelFormat_RGB16_Planar </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a76ab1285d2b3343cbbdb619b75a5a250"></a>PixelType_YUV422_YUYV_Packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_YUV422_YUYV_Packed or PixelFormat_YCbCr422_8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a13f71aca393f8de6b32a6dd051e21ca1"></a>PixelType_YUV444planar&#160;</td><td class="fielddoc">
<p>8 bit / channel YUV 444 planar YY YY UU UU VV VV </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ab9769342e99d7f7aeed3079a0b4f828a"></a>PixelType_YUV422planar&#160;</td><td class="fielddoc">
<p>8 bit / channel YUV 422 planar YY YY U U V V </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a6d7e2e9e71ed5b0489b4db24063f4605"></a>PixelType_YUV420planar&#160;</td><td class="fielddoc">
<p>8 bit / channel YUV 420 planar YY YY U V </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a34e9927bb3e51f9ad6bb449a8d076139"></a>PixelType_YCbCr422_8_YY_CbCr_Semiplanar&#160;</td><td class="fielddoc">
<p>8 bit / channel YUV 422 semiplanar YY YY UV UV also known as PixelType_YUV422_NV16 4:2:2 image with a plane of 8 bit Y samples followed by an interleaved U/V plane </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ade87dd3c492acb8edfae00dbddd2bcd2"></a>PixelType_YCbCr420_8_YY_CbCr_Semiplanar&#160;</td><td class="fielddoc">
<p>8 bit / channel YUV 420 semiplanar YY YY UV also known as PixelType_YUV420_NV12 4:2:0 image with a plane of 8 bit Y samples followed by an interleaved U/V plane </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067aa7db4622390ae317f094dc6ec7cf6560"></a>PixelType_BayerGR12Packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGR12Packed. The memory layouts of PixelType_BayerGR12Packed and PixelType_BayerGR12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a7b68204c64a25d17e5fe99f59cd2e479"></a>PixelType_BayerRG12Packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerRG12Packed. The memory layouts of PixelType_BayerRG12Packed and PixelType_BayerRG12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a9ddb3696f37e94f471fba9a732c5a00d"></a>PixelType_BayerGB12Packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGB12Packed. The memory layouts of PixelType_BayerGB12Packed and PixelType_BayerGB12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a971853a820f1a5f1414de25a9462a3eb"></a>PixelType_BayerBG12Packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerBG12Packed. The memory layouts of PixelType_BayerBG12Packed and PixelType_BayerBG12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a90b54ffbe0af99509cd4ef3caa352027"></a>PixelType_BayerGR10p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGR10p. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a0eac9cc5b01775f2c3bff62aaa9cefc5"></a>PixelType_BayerRG10p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerRG10p. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a99b10c81bfde704c79143c0e5f37b8ef"></a>PixelType_BayerGB10p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGB10p. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ac95837b4128584edd2c9e68ba3c30e32"></a>PixelType_BayerBG10p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerBG10p. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a3f0ea0a0d6e663e1a2c019cbce84b431"></a>PixelType_BayerGR12p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGR12p. The memory layouts of PixelType_BayerGR12Packed and PixelType_BayerGR12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067adccf9ab19eb03907dfb1c51d3ccbf1e2"></a>PixelType_BayerRG12p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerRG12p. The memory layouts of PixelType_BayerRG12Packed and PixelType_BayerRG12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a6da41b111a272815724dd29d4e541221"></a>PixelType_BayerGB12p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGB12p. The memory layouts of PixelType_BayerGB12Packed and PixelType_BayerGB12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a9e4120cc33a5ce8a0d02851db7969461"></a>PixelType_BayerBG12p&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerBG12p. The memory layouts of PixelType_BayerBG12Packed and PixelType_BayerBG12p are different. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a27999a85f9f6b282b50dc27d90f1a408"></a>PixelType_BayerGR16&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGR16 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067af54b1ac72486dc0f8a8bab57051300ed"></a>PixelType_BayerRG16&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerRG16 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a39d116b1a0e59de5640d05baef07e330"></a>PixelType_BayerGB16&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerGB16 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a1b030630aa1189755d3fcb334419ee83"></a>PixelType_BayerBG16&#160;</td><td class="fielddoc">
<p>alias PixelFormat_BayerBG16 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067ac1d91048e59c9a78d9385face13ccc1c"></a>PixelType_RGB12V1packed&#160;</td><td class="fielddoc">
<p>alias PixelFormat_RGB12V1Packed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga159b4bb49b4973a30bc8b39a4fcf3067a761cdd1e1ea6aaa379e6d94fd63de117"></a>PixelType_Double&#160;</td><td class="fielddoc">
<p>alias PixelFormat_Double </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac717c32f1717b871ef8c76595e831b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Pylon::BitDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bit depth of a value of the pixel in bits. </p>
<p>This may be less than the size needed to store the pixel. BitDepth(PixelType_Mono12) returns 12, BitDepth(PixelType_Mono12packed) returns 12, and BitDepth(PixelType_RGB8packed) returns 8 for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The pixel type must be valid.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the pixel type is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1edb0667000ba8d09be587fd1534915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Pylon::BitPerPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bits needed to store a pixel. </p>
<p>BitPerPixel(PixelType_Mono12) returns 16 and BitPerPixel(PixelType_Mono12packed) returns 12 for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The pixel type must be defined.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the pixel type is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="ga31a02f2d51768384ef52c27c0e0d6bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Pylon::ComputeBufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>paddingX</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the buffer size in byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The number of rows in an image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paddingX</td><td>The number of extra data bytes at the end of each row (byte aligned). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size in byte.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The pixel type must be valid. </li>
<li>
The <code>width</code> value must be &gt;= 0 and &lt;= _I32_MAX. </li>
<li>
The <code>height</code> value must be &gt;= 0 and &lt;= _I32_MAX. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the preconditions are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb9593b9c03df7d1b19e342e9b7ff50c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Pylon::ComputePaddingX </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>strideBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the padding value from row stride in byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">strideBytes</td><td>The stride in byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the paddingX value for the given stride value (byte aligned).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The value of <code>strideBytes</code> must be large enough to contain a line described by <code>pixelType</code> and <code>width</code>. </li>
<li>
The pixel type must be valid. </li>
<li>
The <code>width</code> value must be &gt;= 0 and &lt;= _I32_MAX. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the preconditions are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="ga716a806dfdabb206952bcefcbfe4b0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Pylon::ComputeStride </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>strideBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>paddingX</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the stride in byte. </p>
<p>The stride indicates the number of bytes between the beginning of one row in an image and the beginning of the next row. For planar pixel types the returned value represents the stride of a plane.</p>
<p>The stride in bytes cannot be computed for packed image format when the stride is not byte aligned and paddingX == 0. If paddingX is larger than zero and the stride without padding is not byte aligned then the rest of the partially filled byte is considered as padding, e.g. pixelType = PixelType_Mono12packed, width = 5, paddingX = 10 results in a stride of 18 Bytes (stride without padding is 5 * BitPerPixel( PixelType_Mono12packed) = 5 * 12 = 60 Bits = 7.5 Bytes).</p>
<p>The stride can also be not computed for planar YUV422 and YUV420 image formats.</p>
<p>See also <a class="el" href="group___pylon___image_handling_support.html#gaa34f72b29074831f40a685c3da18776c" title="Returns true if the pixels of the given pixel type are not byte aligned. ">Pylon::IsPacked()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">strideBytes</td><td>The stride in byte if it can be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The number of pixels in a row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paddingX</td><td>The number of additional bytes at the end of a row (byte aligned).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the stride can be computed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>width</code> value must be &gt;= 0 and &lt;= _I32_MAX.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the preconditions are not met. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa68692447d311facefc6fcb189e1fa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Pylon::GetPixelTypesForUnpacking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelTypeSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> &amp;&#160;</td>
          <td class="paramname"><em>pixelTypeToImpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> &amp;&#160;</td>
          <td class="paramname"><em>pixelTypeTarget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pixel types needed for conversion from packed to unpacked image formats using the <a class="el" href="class_pylon_1_1_c_image_format_converter.html" title="Creates new images by converting a source image to another format. ">CImageFormatConverter</a> class. </p>
<p>The following pixel types are supported: </p><ul>
<li>
source: PixelType_Mono1packed target: PixelType_Mono8 </li>
<li>
source: PixelType_Mono2packed target: PixelType_Mono8 </li>
<li>
source: PixelType_Mono4packed target: PixelType_Mono8 </li>
<li>
source: PixelType_Mono10packed target: PixelType_Mono16 </li>
<li>
source: PixelType_Mono10p target: PixelType_Mono16 </li>
<li>
source: PixelType_Mono12packed target: PixelType_Mono16 </li>
<li>
source: PixelType_Mono12p target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerGB12Packed imposed: PixelType_Mono12packed target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerGR12Packed imposed: PixelType_Mono12packed target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerRG12Packed imposed: PixelType_Mono12packed target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerBG12Packed imposed: PixelType_Mono12packed target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerGB10p imposed: PixelType_Mono10p target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerGR10p imposed: PixelType_Mono10p target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerRG10p imposed: PixelType_Mono10p target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerBG10p imposed: PixelType_Mono10p target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerGB12p imposed: PixelType_Mono12p target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerGR12p imposed: PixelType_Mono12p target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerRG12p imposed: PixelType_Mono12p target: PixelType_Mono16 </li>
<li>
source: PixelType_BayerBG12p imposed: PixelType_Mono12p target: PixelType_Mono16 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelTypeSource</td><td>The source pixel type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pixelTypeToImpose</td><td>The pixel type that is used for conversion instead of the source pixel type. Returns <code>pixelTypeSource</code> if changing the source pixel type is not needed. Returns PixelType_Undefined if no unpacking is needed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pixelTypeTarget</td><td>The pixel type to which the image pixel data are converted. Returns PixelType_Undefined if no unpacking is needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the source <code>pixelTypeSource</code> is in packed image format and a conversion is possible. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28dc6c70905f4c0eaceca7d5060f50db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Pylon::IsPackedInLsbFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the pixel type is packed in lsb packed format. For lsb packed format, the data is filled lsb first in the lowest address byte (byte 0) starting with the first pixel and continued in the lsb of byte 1 (and so on). See the camera User's Manual or the Pixel Format Naming Convention (PFNC) of the <a class="el" href="namespace_gen_i_cam.html" title="Contains definitions of GenICam types and exceptions. ">GenICam</a> standard group for more information. </p>

</div>
</div>
<a class="anchor" id="ga9b0371eb8bd99d8bf51135302eadd5f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Pylon::SamplesPerPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>pixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of measured values per pixel. </p>
<p>SamplesPerPixel(PixelType_Mono8) returns 1 and SamplesPerPixel(PixelType_RGB8packed) returns 3 for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelType</td><td>The pixel type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The pixel type must be defined. The pixel type is not PixelType_YUV411packed.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception when the pixel type is undefined. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr>
<div id="projectname">pylon <span id="projectnumber">6.1.0</span></div>
<address><small>Copyright (c) 2006-2020 <a href="http://www.baslerweb.com/">Basler AG</a>   (Mon Mar 16 2020 10:56:53)</small></address>
</body>
</html>
