<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_pylon.html">Pylon</a></li><li class="navelem"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html">IStreamGrabber</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interface_pylon_1_1_i_stream_grabber-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pylon::IStreamGrabber Interface Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___pylon___low_level_api.html">Low Level API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Low Level API: Interface to an (input) data stream.  
 <a href="struct_pylon_1_1_i_stream_grabber.html#details">More...</a></p>

<p><code>#include &lt;pylon/StreamGrabber.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe98508c625e3271e6c7be7aa5c63f71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#afe98508c625e3271e6c7be7aa5c63f71">Open</a> ()=0</td></tr>
<tr class="memdesc:afe98508c625e3271e6c7be7aa5c63f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the stream grabber.  <a href="#afe98508c625e3271e6c7be7aa5c63f71">More...</a><br /></td></tr>
<tr class="separator:afe98508c625e3271e6c7be7aa5c63f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f126feac936eab5e7283e2ac436641"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a69f126feac936eab5e7283e2ac436641">Close</a> ()=0</td></tr>
<tr class="memdesc:a69f126feac936eab5e7283e2ac436641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream grabber.  <a href="#a69f126feac936eab5e7283e2ac436641">More...</a><br /></td></tr>
<tr class="separator:a69f126feac936eab5e7283e2ac436641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaacddf710c6482de03474df72bac60f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aaaacddf710c6482de03474df72bac60f">IsOpen</a> () const =0</td></tr>
<tr class="memdesc:aaaacddf710c6482de03474df72bac60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve whether the stream grabber is open.  <a href="#aaaacddf710c6482de03474df72bac60f">More...</a><br /></td></tr>
<tr class="separator:aaaacddf710c6482de03474df72bac60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc61d10843dd0eea41ef0bf19218dbe3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#adc61d10843dd0eea41ef0bf19218dbe3">RegisterBuffer</a> (void *pBuffer, size_t bufferSize)=0</td></tr>
<tr class="memdesc:adc61d10843dd0eea41ef0bf19218dbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a buffer for subsequent use.  <a href="#adc61d10843dd0eea41ef0bf19218dbe3">More...</a><br /></td></tr>
<tr class="separator:adc61d10843dd0eea41ef0bf19218dbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352745f77dfef747e9bf09549789ecea"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a352745f77dfef747e9bf09549789ecea">DeregisterBuffer</a> (<a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a> hStreamBuffer)=0</td></tr>
<tr class="memdesc:a352745f77dfef747e9bf09549789ecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregisters the buffer.  <a href="#a352745f77dfef747e9bf09549789ecea">More...</a><br /></td></tr>
<tr class="separator:a352745f77dfef747e9bf09549789ecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811c289595bc5ae0bbfc8154a86c369e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a811c289595bc5ae0bbfc8154a86c369e">PrepareGrab</a> ()=0</td></tr>
<tr class="memdesc:a811c289595bc5ae0bbfc8154a86c369e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares grabbing.  <a href="#a811c289595bc5ae0bbfc8154a86c369e">More...</a><br /></td></tr>
<tr class="separator:a811c289595bc5ae0bbfc8154a86c369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a447b6fde021b92ab8305e6426a3b6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aa3a447b6fde021b92ab8305e6426a3b6">IsStartAndStopStreamingMandatory</a> ()=0</td></tr>
<tr class="memdesc:aa3a447b6fde021b92ab8305e6426a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Stream Grabber requires calling <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac" title="Starts streaming for the stream grabber if this is mandatory for operation. ">StartStreamingIfMandatory()</a> for operation.  <a href="#aa3a447b6fde021b92ab8305e6426a3b6">More...</a><br /></td></tr>
<tr class="separator:aa3a447b6fde021b92ab8305e6426a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb25b33ed41be93374b91e1cc4656ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac">StartStreamingIfMandatory</a> ()=0</td></tr>
<tr class="memdesc:a0fb25b33ed41be93374b91e1cc4656ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts streaming for the stream grabber if this is mandatory for operation.  <a href="#a0fb25b33ed41be93374b91e1cc4656ac">More...</a><br /></td></tr>
<tr class="separator:a0fb25b33ed41be93374b91e1cc4656ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3f5cb33e02557c9e4f7033ff10dae6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a8c3f5cb33e02557c9e4f7033ff10dae6">StopStreamingIfMandatory</a> ()=0</td></tr>
<tr class="memdesc:a8c3f5cb33e02557c9e4f7033ff10dae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops streaming for the stream grabber if this is mandatory for operation.  <a href="#a8c3f5cb33e02557c9e4f7033ff10dae6">More...</a><br /></td></tr>
<tr class="separator:a8c3f5cb33e02557c9e4f7033ff10dae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63bcf8121005ad87ee9ae4eead0d238"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aa63bcf8121005ad87ee9ae4eead0d238">FinishGrab</a> ()=0</td></tr>
<tr class="memdesc:aa63bcf8121005ad87ee9ae4eead0d238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops grabbing finally.  <a href="#aa63bcf8121005ad87ee9ae4eead0d238">More...</a><br /></td></tr>
<tr class="separator:aa63bcf8121005ad87ee9ae4eead0d238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb33c417642eeb46c7e9de8b3ddfe090"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#afb33c417642eeb46c7e9de8b3ddfe090">QueueBuffer</a> (<a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a> hStreamBuffer, const void *pContext=NULL)=0</td></tr>
<tr class="memdesc:afb33c417642eeb46c7e9de8b3ddfe090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a buffer in the input queue.  <a href="#afb33c417642eeb46c7e9de8b3ddfe090">More...</a><br /></td></tr>
<tr class="separator:afb33c417642eeb46c7e9de8b3ddfe090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd70617e6289a1139fc407a2d8d56a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#acbd70617e6289a1139fc407a2d8d56a9">FlushBuffersToOutput</a> ()=0</td></tr>
<tr class="memdesc:acbd70617e6289a1139fc407a2d8d56a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels grabbing the current buffer and flushes all buffers to the output queue.  <a href="#acbd70617e6289a1139fc407a2d8d56a9">More...</a><br /></td></tr>
<tr class="separator:acbd70617e6289a1139fc407a2d8d56a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf0b3c2e794146f5cdeb4cd1518d015"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadf0b3c2e794146f5cdeb4cd1518d015"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aadf0b3c2e794146f5cdeb4cd1518d015">CancelGrab</a> ()=0</td></tr>
<tr class="memdesc:aadf0b3c2e794146f5cdeb4cd1518d015"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method has been renamed to <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#acbd70617e6289a1139fc407a2d8d56a9" title="Cancels grabbing the current buffer and flushes all buffers to the output queue. ">FlushBuffersToOutput()</a>. Calling CancelGrab calls <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#acbd70617e6289a1139fc407a2d8d56a9" title="Cancels grabbing the current buffer and flushes all buffers to the output queue. ">FlushBuffersToOutput()</a>;. <br /></td></tr>
<tr class="separator:aadf0b3c2e794146f5cdeb4cd1518d015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ec72de8830ebed2642f2ab0007dd1c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a04ec72de8830ebed2642f2ab0007dd1c">RetrieveResult</a> (<a class="el" href="class_pylon_1_1_grab_result.html">GrabResult</a> &amp;grabResult)=0</td></tr>
<tr class="memdesc:a04ec72de8830ebed2642f2ab0007dd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves one grab result from the output queue.  <a href="#a04ec72de8830ebed2642f2ab0007dd1c">More...</a><br /></td></tr>
<tr class="separator:a04ec72de8830ebed2642f2ab0007dd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d3f9485a5f0edbb44af8504a822b23"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a73d3f9485a5f0edbb44af8504a822b23">GetWaitObject</a> () const =0</td></tr>
<tr class="memdesc:a73d3f9485a5f0edbb44af8504a822b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result event object of the stream grabber.  <a href="#a73d3f9485a5f0edbb44af8504a822b23">More...</a><br /></td></tr>
<tr class="separator:a73d3f9485a5f0edbb44af8504a822b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d628796a93407a6b5ef8e2db8881db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#af8d628796a93407a6b5ef8e2db8881db">GetNodeMap</a> ()=0</td></tr>
<tr class="memdesc:af8d628796a93407a6b5ef8e2db8881db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated stream grabber parameters.  <a href="#af8d628796a93407a6b5ef8e2db8881db">More...</a><br /></td></tr>
<tr class="separator:af8d628796a93407a6b5ef8e2db8881db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low Level API: Interface to an (input) data stream. </p>
<dl class="section attention"><dt>Attention</dt><dd>The Low Level API has been deprecated in pylon 6.0. It is recommended to use the Instant Camera classes instead.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a69f126feac936eab5e7283e2ac436641"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the stream grabber. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<p>This method calls <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aa63bcf8121005ad87ee9ae4eead0d238" title="Stops grabbing finally. ">FinishGrab()</a> automatically if needed.</p>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
Any running grab has been stopped by calling <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aa63bcf8121005ad87ee9ae4eead0d238" title="Stops grabbing finally. ">FinishGrab()</a>. </li>
<li>
The stream grabber is closed. </li>
<li>
All results waiting in the output queue are discarded. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a352745f77dfef747e9bf09549789ecea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* Pylon::IStreamGrabber::DeregisterBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a>&#160;</td>
          <td class="paramname"><em>hStreamBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deregisters the buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hStreamBuffer</td><td>The handle of a buffer that has been provided by <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#adc61d10843dd0eea41ef0bf19218dbe3" title="Registers a buffer for subsequent use. ">RegisterBuffer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer of the corresponding buffer.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The buffer is registered. </li>
<li>
The buffer is not queued. Either it has not been queued yet, see <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#afb33c417642eeb46c7e9de8b3ddfe090" title="Enqueues a buffer in the input queue. ">QueueBuffer()</a>, or it has been retrieved after grabbing using <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a04ec72de8830ebed2642f2ab0007dd1c" title="Retrieves one grab result from the output queue. ">RetrieveResult()</a>. </li>
<li>
<a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aa63bcf8121005ad87ee9ae4eead0d238" title="Stops grabbing finally. ">FinishGrab()</a> or <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a69f126feac936eab5e7283e2ac436641" title="Closes the stream grabber. ">Close()</a> have not been called for the grab session yet. </li>
<li>
If the stream grabber requires the additional streaming state, streaming must not be started, see <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aa3a447b6fde021b92ab8305e6426a3b6" title="Returns true if the Stream Grabber requires calling StartStreamingIfMandatory() for operation...">IsStartAndStopStreamingMandatory()</a> and <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac" title="Starts streaming for the stream grabber if this is mandatory for operation. ">StartStreamingIfMandatory()</a>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
Transport layer-specific preparations have been reversed. </li>
<li>
The buffer is deregistered. </li>
<li>
The buffer can be freed if needed e.g., by calling delete. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if deregistering the buffer fails. </dd></dl>

</div>
</div>
<a class="anchor" id="aa63bcf8121005ad87ee9ae4eead0d238"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::FinishGrab </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops grabbing finally. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<p>This method calls <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#acbd70617e6289a1139fc407a2d8d56a9" title="Cancels grabbing the current buffer and flushes all buffers to the output queue. ">FlushBuffersToOutput()</a> automatically if needed.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The stream grabber is prepared. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
Resources required for grabbing are freed. </li>
<li>
The camera is not set up for grabbing anymore </li>
<li>
Critical camera parameters, provided by <a class="el" href="struct_pylon_1_1_i_pylon_device.html#a100126837d4bc3eaa74531f9b1e39bf6" title="Returns the set of camera parameters. ">IPylonDevice::GetNodeMap()</a>, are unlocked. </li>
<li>
The stream grabber is open. </li>
<li>
Queued buffers are available in the output queue of the stream grabber and can be retrieved calling <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a04ec72de8830ebed2642f2ab0007dd1c" title="Retrieves one grab result from the output queue. ">RetrieveResult()</a>. </li>
<li>
All buffers are deregistered. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber state does not match the preconditions. </li>
<li>
Throws an exception if finishing the grab fails. The stream grabber is in open state after raising the exception. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acbd70617e6289a1139fc407a2d8d56a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::FlushBuffersToOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels grabbing the current buffer and flushes all buffers to the output queue. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The stream grabber is prepared. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
All queued buffers are placed in the output queue of the stream grabber and can be retrieved using <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a04ec72de8830ebed2642f2ab0007dd1c" title="Retrieves one grab result from the output queue. ">RetrieveResult()</a>. </li>
<li>
Buffers that have not been grabbed completely before calling FlushBuffersToOutput are marked with the EGrabStatus Canceled. </li>
<li>
The stream grabber is prepared. </li>
<li>
Buffers can be queued again to continue grabbing. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber state does not match the preconditions. </li>
<li>
Throws an exception if canceling the grab fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af8d628796a93407a6b5ef8e2db8881db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>* Pylon::IStreamGrabber::GetNodeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the associated stream grabber parameters. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the associated stream grabber parameters. The returned pointer is never NULL.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method can be synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a73d3f9485a5f0edbb44af8504a822b23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a>&amp; Pylon::IStreamGrabber::GetWaitObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result event object of the stream grabber. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<p>This object is associated with the output queue of the stream grabber. The event is signaled when output queue is non-empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the result event object of the stream grabber.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method can be synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaacddf710c6482de03474df72bac60f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::IStreamGrabber::IsOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve whether the stream grabber is open. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the stream grabber is open.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method can be synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3a447b6fde021b92ab8305e6426a3b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::IStreamGrabber::IsStartAndStopStreamingMandatory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the Stream Grabber requires calling <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac" title="Starts streaming for the stream grabber if this is mandatory for operation. ">StartStreamingIfMandatory()</a> for operation. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="afe98508c625e3271e6c7be7aa5c63f71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::Open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens the stream grabber. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The corresponding device is open. </li>
<li>
The stream grabber is closed. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The stream grabber is open. </li>
<li>
If the device is closed while the stream grabber is open, the stream grabber is closed automatically. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber is already open or prepared. The stream grabber remains in the same state after raising the exception in this case. </li>
<li>
Throws an exception if the stream grabber is closed and opening the stream grabber fails. The stream grabber remains closed after raising the exception. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a811c289595bc5ae0bbfc8154a86c369e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::PrepareGrab </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares grabbing. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd>
<dd>
pylon uses a pool of buffers with a fixed amount of buffers to grab images. This is required because certain preparations e.g., locking the buffer's memory pages, must be made by the driver to be able to grab images into a buffer. Thus, using a pool of buffers is much more efficient than allocating a new buffer for every grabbed image.</dd></dl>
<p>The node map integer parameters MaxBufferSize and MaxNumBuffer need to be set before calling <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a811c289595bc5ae0bbfc8154a86c369e" title="Prepares grabbing. ">PrepareGrab()</a>.</p>
<p>MaxNumBuffer should be set to the number of buffers you plan to use for grabbing. </p><dl class="section note"><dt>Note</dt><dd>There can be limitations depending on the transport layer technology used when using a large amount of buffers.</dd></dl>
<p>MaxBufferSize needs to be set according to the PayloadSize parameter of the camera device or the stream grabber. If the stream grabber provides a PayloadSize parameter, the MaxBufferSize must be at least the size reported by the stream grabber payload size. This is the case if for instance a frame grabber or additional preprocessing is used. If the stream grabber does not provide a PayloadSize parameter, the MaxBufferSize must be at least the size reported by the camera device PayloadSize parameter.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The node map integer parameter MaxBufferSize is set, see GetNodeNap(). </li>
<li>
The node map integer parameter MaxNumBuffer is set, see GetNodeNap(). </li>
<li>
The stream grabber is open. </li>
<li>
No grab session is currently in progress. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
Resources required for grabbing are allocated. </li>
<li>
The camera is set up for grabbing. </li>
<li>
Critical camera parameters, provided by <a class="el" href="struct_pylon_1_1_i_pylon_device.html#a100126837d4bc3eaa74531f9b1e39bf6" title="Returns the set of camera parameters. ">IPylonDevice::GetNodeMap()</a>, are locked. </li>
<li>
The stream grabber is prepared. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber state does not match the preconditions. </li>
<li>
Throws an exception if preparing the stream grabber fails. The stream grabber is not prepared after raising the exception. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afb33c417642eeb46c7e9de8b3ddfe090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::QueueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a>&#160;</td>
          <td class="paramname"><em>hStreamBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pContext</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues a buffer in the input queue. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hStreamBuffer</td><td>The handle of a buffer that has been provided by <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#adc61d10843dd0eea41ef0bf19218dbe3" title="Registers a buffer for subsequent use. ">RegisterBuffer()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>A user-provided pointer passed along with buffer in the internal input and output queues.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The buffer is registered, see <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#adc61d10843dd0eea41ef0bf19218dbe3" title="Registers a buffer for subsequent use. ">RegisterBuffer()</a>. </li>
<li>
The stream grabber is prepared. </li>
<li>
The buffer has not been queued for grabbing yet. </li>
<li>
The buffer is not waiting in the output queue of the stream grabber. The buffer can be queued again after it has been retrieved using <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a04ec72de8830ebed2642f2ab0007dd1c" title="Retrieves one grab result from the output queue. ">RetrieveResult()</a>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The buffer is queued to input queue of the stream grabber. </li>
<li>
The buffer cannot be deregistered until it has been retrieved using <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a04ec72de8830ebed2642f2ab0007dd1c" title="Retrieves one grab result from the output queue. ">RetrieveResult()</a>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber state does not match the preconditions. </li>
<li>
Throws an exception if queuing the buffer fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="adc61d10843dd0eea41ef0bf19218dbe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a> Pylon::IStreamGrabber::RegisterBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a buffer for subsequent use. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>The pointer of the buffer that is to be used for grabbing e.g., for grabbing images. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the provided buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle for the registered buffer that can be used in subsequent calls.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
pBuffer must not be NULL. </li>
<li>
The buffer size must not exceed the value of the node map integer parameter MaxBufferSize specified when PrepareGrab was called. </li>
<li>
Less buffers are already registered than value of the node map integer parameter MaxNumBuffer specified when PrepareGrab was called. </li>
<li>
The stream grabber is prepared, see <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a811c289595bc5ae0bbfc8154a86c369e" title="Prepares grabbing. ">PrepareGrab()</a>. </li>
<li>
The buffer has not been registered already. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The buffer is registered. </li>
<li>
Transport Layer specific preparations have been executed e.g., locking the memory pages of the buffer. </li>
<li>
The buffer must not be freed while being registered. </li>
<li>
If the stream grabber requires the additional streaming state, streaming must not be started, see <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aa3a447b6fde021b92ab8305e6426a3b6" title="Returns true if the Stream Grabber requires calling StartStreamingIfMandatory() for operation...">IsStartAndStopStreamingMandatory()</a> and <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac" title="Starts streaming for the stream grabber if this is mandatory for operation. ">StartStreamingIfMandatory()</a>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method can be synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber state does not match the preconditions. </li>
<li>
Throws an exception if registering the buffer fails. The buffer is not registered after raising an exception. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a04ec72de8830ebed2642f2ab0007dd1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::IStreamGrabber::RetrieveResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_grab_result.html">GrabResult</a> &amp;&#160;</td>
          <td class="paramname"><em>grabResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves one grab result from the output queue. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<p>param[out] grabResult The object the grab result data is returned in if true is returned. The <code>grabResult</code> remains unchanged if false is returned. </p><dl class="section return"><dt>Returns</dt><dd>Returns true when result was available.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The stream grabber is open. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If a grab result was available, it has been removed from the ouput queue. </li>
<li>
The corresponding buffer can be queued again for grabbing. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber state does not match the preconditions. </li>
<li>
Throws an exception if retrieving the result fails. This does not change the stream grabber state. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0fb25b33ed41be93374b91e1cc4656ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::StartStreamingIfMandatory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts streaming for the stream grabber if this is mandatory for operation. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<p>Some stream grabbers e.g., some stream grabbers based on GenTL, have limitations on when buffers can be registered. For these stream grabbers it is mandatory to register all buffers first and call <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac" title="Starts streaming for the stream grabber if this is mandatory for operation. ">StartStreamingIfMandatory()</a> aftwards. Between the <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac" title="Starts streaming for the stream grabber if this is mandatory for operation. ">StartStreamingIfMandatory()</a> and <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a8c3f5cb33e02557c9e4f7033ff10dae6" title="Stops streaming for the stream grabber if this is mandatory for operation. ">StopStreamingIfMandatory()</a> calls no buffers can be registered or deregistered if such a limitation exists.</p>
<dl class="section note"><dt>Note</dt><dd>This method has been added in pylon 6.0 for supporting CoaXPress. Prior implementations of pylon stream grabbers did not require calling start and stop streaming. The <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aa3a447b6fde021b92ab8305e6426a3b6" title="Returns true if the Stream Grabber requires calling StartStreamingIfMandatory() for operation...">IsStartAndStopStreamingMandatory()</a>, <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac" title="Starts streaming for the stream grabber if this is mandatory for operation. ">StartStreamingIfMandatory()</a>, and <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a8c3f5cb33e02557c9e4f7033ff10dae6" title="Stops streaming for the stream grabber if this is mandatory for operation. ">StopStreamingIfMandatory()</a> methods allow backward-compatible operation.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The stream grabber is prepared. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If the stream grabber does not require <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a0fb25b33ed41be93374b91e1cc4656ac" title="Starts streaming for the stream grabber if this is mandatory for operation. ">StartStreamingIfMandatory()</a>, nothing is done. </li>
<li>
Streaming is started. For GenTL-based stream grabbers DSStartAcquistion is called </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber state does not match the preconditions. </li>
<li>
Throws an exception if start streaming fails. The stream grabber is not streaming after raising the exception. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8c3f5cb33e02557c9e4f7033ff10dae6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::StopStreamingIfMandatory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops streaming for the stream grabber if this is mandatory for operation. </p>
<dl class="section note"><dt>Note</dt><dd>Basler recommends using one of the Instant Camera classes <a class="el" href="class_pylon_1_1_c_basler_universal_instant_camera.html" title="Extends the CInstantCamera by universal parameter interface classes combining all interface types...">CBaslerUniversalInstantCamera</a> or <a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">CInstantCamera</a> for new projects. If you want to control which buffers are used for grabbing, you can use the <a class="el" href="struct_pylon_1_1_i_buffer_factory.html" title="Usable to create a custom buffer factory when needed. ">Pylon::IBufferFactory</a>.</dd></dl>
<p>Some stream grabbers e.g., some stream grabbers based on GenTL, have limitations on when buffers can be registered. For these stream grabbers it is mandatory to call StopStreamingIfMandatory to be able to deregister buffer afterwards.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The stream grabber is in streaming mode if start and stop streaming is mandatory. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If the stream grabber does not require <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a8c3f5cb33e02557c9e4f7033ff10dae6" title="Stops streaming for the stream grabber if this is mandatory for operation. ">StopStreamingIfMandatory()</a>, nothing is done. </li>
<li>
Streaming is stopped. For GenTL-based stream grabbers DSStopAcquistion is called. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal stream grabber lock.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd><ul>
<li>
Throws a <a class="el" href="class_pylon_1_1_logical_error_exception.html" title="Exception thrown to indicate logical errors in program flow. ">LogicalErrorException</a> if the stream grabber state does not match the preconditions. </li>
<li>
Throws an exception if stop streaming fails. The stream grabber is not streaming after raising the exception. </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>pylon/<a class="el" href="_stream_grabber_8h.html">StreamGrabber.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="projectname">pylon <span id="projectnumber">6.1.0</span></div>
<address><small>Copyright (c) 2006-2020 <a href="http://www.baslerweb.com/">Basler AG</a>   (Mon Mar 16 2020 10:57:01)</small></address>
</body>
</html>
