<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: pylon C Programmer&#39;s Guide</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">pylon C Programmer&#39;s Guide</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Programming with pylon C </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>
<a class="el" href="programmingguide.html#architecture">The Architecture of the pylon C API</a> <ul>
<li>
<a class="el" href="programmingguide.html#arch_genapi">pylon C and GenApi</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_objhdl">Objects and Handles</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_camobj">Camera Objects</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_tl">Transport Layers</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_wait">Waiting</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_stream_grabber">Stream Grabbers</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_event_grabber">Event Grabbers</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_chunk_parser">Chunk Parsers</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_param">Parameters</a> </li>
<li>
<a class="el" href="programmingguide.html#arch_grab_basics">Image Terminology Issues</a> </li>
</ul>
</li>
<li>
<a class="el" href="programmingguide.html#pylon_programming">Programming the pylon C API</a> <ul>
<li>
<a class="el" href="programmingguide.html#pylonprog_debugging_gige">Debugging pylon Applications Using GigE Cameras</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_init">Initialization/Uninitialization of the pylon C Runtime Library</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_errorhandling">Error Handling</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_enum">Enumerating and Creating Camera Objects</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_open">Opening and Closing a Camera</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_config">Camera Configuration</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab">Grabbing Images</a> <ul>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_grabsingleframe">Grabbing Using the PylonDeviceGrabSingleFrame() Function</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_usingstreamgrabber">Grabbing Using Stream Grabber Objects</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_gettingstreamgrabber">Getting a Stream Grabber</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_configurestreamgrabber">Configuring a Stream Grabber</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_preparingstreamgrabber">Preparing a Stream Grabber for Grabbing</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_buffer_setup">Providing Memory for Grabbing</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_feedinginputqueue">Feeding the Stream Grabber's Input Queue</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_startstop">Starting and Stopping Image Acquisition</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_get_data">Retrieving Grabbed Images</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_finish">Finish Grabbing</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_grab_completesample">Sample Program</a> </li>
</ul>
</li>
<li>
<a class="el" href="programmingguide.html#pylonprog_waitobjects">Using Wait Objects</a> <ul>
<li>
<a class="el" href="programmingguide.html#pylonprog_waitobjects_example">Sample Program</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_waitobjects_interruptible">Interruptible Wait Operation</a> </li>
</ul>
</li>
<li>
<a class="el" href="programmingguide.html#pylonprog_event">Handling Camera Events</a> <ul>
<li>
<a class="el" href="programmingguide.html#pylonprog_event_grabber">Event Grabbers</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_event_grabber_get">Getting and Preparing Event Grabbers</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_event_enable">Enabling Events</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_event_receive">Receiving Event Messages</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_event_dispatch">Parsing and Dispatching Event Messages</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_event_callback">Event Callbacks</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_event_cleanup">Cleanup</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_event_sample">Sample Program</a> </li>
</ul>
</li>
<li>
<a class="el" href="programmingguide.html#pylonprog_chunk">Chunk Parser: Accessing Chunk Features</a> <ul>
<li>
<a class="el" href="programmingguide.html#pylonprog_chunk_enable">Enabling Chunks</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_chunk_grab">Grabbing Buffers</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_chunk_parse">Accessing the Chunk Data</a> </li>
<li>
<a class="el" href="programmingguide.html#pylonprog_chunk_sample">Sample Program</a> </li>
</ul>
</li>
<li>
<a class="el" href="programmingguide.html#pylonprog_pnp">Getting Informed About Device Removal</a> </li>
</ul>
</li>
<li>
<a class="el" href="programmingguide.html#advanced">Advanced Topics</a> <ul>
<li>
<a class="el" href="programmingguide.html#advanced_genapinodemaps">Generic Parameter Access</a> </li>
<li>
<a class="el" href="programmingguide.html#advanced_parambrowse">Browsing Parameters</a> </li>
<li>
<a class="el" href="programmingguide.html#advanced_paramchange">Getting Notified About Parameter Changes</a> </li>
<li>
<a class="el" href="programmingguide.html#advanced_mcgrab">GigE Multicast/Broadcast: Grab Images of One Camera on Multiple PCs</a> </li>
<li>
<a class="el" href="programmingguide.html#advanced_action">GigE Action Commands</a> </li>
<li>
<a class="el" href="programmingguide.html#migration_to_sfnc2">Migrating Existing Code for Using SFNC 2.X-Based Camera Devices</a> </li>
<li>
<a class="el" href="programmingguide.html#sfnc_parameter_name_changes_cm">Migration Mode</a> </li>
<li>
<a class="el" href="programmingguide.html#migration_to_usb">Migrating to Using USB Camera Devices</a> </li>
<li>
<a class="el" href="programmingguide.html#camemu_tl">Camera Emulator</a> </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="architecture"></a>
The Architecture of the pylon C API</h1>
<p>This section introduces several concepts that are essential for understanding the pylon&#160;C API.</p>
<h2><a class="anchor" id="arch_genapi"></a>
pylon C and GenApi</h2>
<p>The pylon&#160;C API builds upon GenApi, a software framework that provides a high-level API for generic access to all compliant digital cameras, hiding the peculiarities of the particular interface technology used. Accordingly, the application developer can focus on the functional aspects of the program to be developed. Due to the abstraction provided by GenApi, programs need not be adjusted to work with different types of camera interfaces. Even applications can be addressed where different camera interfaces are used at the same time.</p>
<p>The dependency of pylon&#160;C upon GenApi shows in some places, mostly where names of functions or other entities start with a GenApi prefix. Wherever this is the case, an element of the underlying GenApi layer is directly exposed to the pylon&#160;C user.</p>
<h2><a class="anchor" id="arch_objhdl"></a>
Objects and Handles</h2>
<p>The pylon&#160;C API defines several data entities termed 'objects'. These are used to expose certain aspects of the pylon&#160;C functionality to the user. For example, there is a stream grabber object that serves the purpose of receiving image data streamed by a camera (which, in turn, is also represented by an object called a camera object).</p>
<p>Inside a program, every object is represented and uniquely identified by a handle. A function performing an action that involves an object is passed a handle for that object. Handles are type-safe, which is to say that handles representing different kinds of objects are of different types. Accordingly, the C language type system is able to detect errors such as passing a wrong kind of object to a function call.Furthermore, handles are unique in the sense that no two handles representing two different objects will ever be equal when they are compared. This is even true if the comparison is made between two handles of different types after they were forcefully cast to a common type.</p>
<h2><a class="anchor" id="arch_camobj"></a>
Camera Objects</h2>
<p>In pylon&#160;C, physical camera devices are represented by camera objects (sometimes also referred to as device objects). A camera object handle has the type of <code>PYLON_DEVICE_HANDLE</code>.</p>
<p>A camera object is used for: </p><ul>
<li>Establishing communication with a camera (i.e., opening the camera object) </li>
<li>Accessing the camera's parameters (to query or change its configuration, see <a class="el" href="programmingguide.html#arch_param">Parameters</a> below) </li>
<li>Obtaining a stream grabber object used for grabbing images (see <a class="el" href="programmingguide.html#arch_stream_grabber">Stream Grabbers</a> below) </li>
<li>Obtaining an event grabber object used for retrieving event messages (see <a class="el" href="programmingguide.html#arch_event_grabber">Event Grabbers</a> below) </li>
<li>Obtaining a chunk parser object used for analyzing a self-descriptive, structured data stream (see <a class="el" href="programmingguide.html#arch_chunk_parser">Chunk Parsers</a> below)</li>
</ul>
<h2><a class="anchor" id="arch_tl"></a>
Transport Layers</h2>
<p>The term 'transport layer' is used as an abstraction for a physical interface such as Gigabit Ethernet (GigE), USB, or CoaXPress (CXP). For each of these interfaces, there are drivers that provide access to camera devices. As an abstraction of these drivers, a transport layer provides the following functionality: </p><ul>
<li>Device discovery (also called device enumeration) </li>
<li>Reading and writing camera registers </li>
<li>Grabbing images </li>
<li>Retrieving event messages </li>
<li>Configuring the transport layer itself (e.g. timeouts) </li>
<li>Creating camera objects </li>
<li>Deleting camera objects</li>
</ul>
<p>pylon&#160;C includes multiple transport layers, e.g.: </p><ul>
<li>PylonGigE for Gigabit Ethernet cameras using the GigE Vision protocol </li>
<li>PylonUsb for USB3 Vision compliant cameras </li>
<li>PylonCLSer for Camera Link cameras using the CL serial interface (limited to camera configuration only) </li>
<li>PylonGtc for CoaXPress compliant cameras using GenTL (generic transport layer)</li>
</ul>
<p>A transport layer is strictly an internal concept of the pylon&#160;C API that application writers need not be concerned with, as there is no user-visible entity related to it. This means there is no 'transport layer object' in pylon&#160;C. As every camera has exactly one transport layer, it is, for all practical purposes, considered an integral part of the camera object. However, being aware of the transport layer concept may be useful for properly understanding device enumeration and communication.</p>
<h1><a class="anchor" id="arch_wait"></a>
Waiting</h1>
<p>Typically, pylon&#160;C applications are event-driven. This means that such applications, or the threads running within them, will often wait for some condition to become true, for example, a buffer with image data to become available.</p>
<p>pylon&#160;C provides a generalized mechanism for applications to wait for externally generated events, based on the concepts of <em>wait objects</em> and <em>wait object containers</em>. Wait objects provide an abstraction layer for operating system-specific synchronization mechanisms. Events in pylon&#160;C include image data that become available at a stream grabber (see <a class="el" href="programmingguide.html#pylonprog_grab_get_data">Retrieving Grabbed Images</a>), or event data that become available at an event grabber. With wait objects, pylon&#160;C provides a mechanism for applications to wait for these events. Moreover, applications can create wait objects of their own that can be explicitly signaled.</p>
<p>Wait objects can be grouped into <em>wait object containers</em>, and wait functions are provided by pylon&#160;C for the application to wait until either any one or all wait objects in a container are signaled. This way, events originating from multiple sources can be processed by a single thread.</p>
<p>Wait objects are represented by handles of the <code>PYLON_WAITOBJECT_HANDLE</code> type, while handles of the <code>PYLON_WAITOBJECTS_HANDLE</code> type represent wait object containers.</p>
<h2><a class="anchor" id="arch_stream_grabber"></a>
Stream Grabbers</h2>
<p>A camera object, as defined by the pylon&#160;C architecture, is capable of delivering one or more <em>streams</em> of image data (see below for an exception). To grab images from a stream, a <em>stream grabber</em> object is required. Stream grabber objects cannot be created directly by an application. They are managed by camera objects, which create and pass out stream grabbers. All stream grabbers expose the very same interface, regardless of the transport mechanism they use for data transfer. This means that for all transport layers, images are grabbed from streams in exactly the same way. The details of grabbing images are described in the <a class="el" href="programmingguide.html#pylonprog_grab">Grabbing Images</a> section below.</p>
<dl class="section note"><dt>Note</dt><dd>There may be cameras for which image data support is not implemented in pylon&#160;C. Device objects for cameras of this kind will have no stream grabber at all. Such device objects can still be used to access device parameters, grabbing, however, will not be possible. Throughout the remainder of this document it will be assumed that there is at least one image data channel available for every device object.</dd></dl>
<p>If a camera is capable of delivering multiple data streams, its device object will provide a stream grabber for each data stream. A device object can report the number of provided stream grabbers. Stream grabber objects are represented by handles of the <code>PYLON_STREAMGRABBER_HANDLE</code> type. Section <a class="el" href="programmingguide.html#pylonprog_grab">Grabbing Images</a> describes their use in detail.</p>
<h2><a class="anchor" id="arch_event_grabber"></a>
Event Grabbers</h2>
<p>In addition to sending image data streams, some cameras are capable of sending event messages to inform the application about certain conditions that arise. For example, a camera may send an event message when the image acquisition process is complete within the camera, but before the image data are actually transferred out of the camera. The application might need this information to know when it is safe to start a handling system that moves the next part into position for a subsequent acquisition, without having to wait for the image data to arrive.</p>
<p>Event grabber objects are used to receive event messages. Retrieving and processing event messages is described below in the <a class="el" href="programmingguide.html#pylonprog_event">Handling Camera Events</a> section.</p>
<p>Event grabber objects are represented by handles of the <code>PYLON_EVENTGRABBER_HANDLE</code> type.</p>
<h2><a class="anchor" id="arch_chunk_parser"></a>
Chunk Parsers</h2>
<p>If the so-called chunk mode is activated, Basler cameras can send additional information appended to the image data. When chunk mode is enabled, the camera sends an extended data stream consisting of the image data combined with additional information, such as a frame number or a time stamp. The extended data stream is self-descriptive. pylon&#160;C chunk parser objects are used for parsing the extended data stream and for providing access to the additional information. Use of chunk parser objects is explained in the <a class="el" href="programmingguide.html#pylonprog_chunk">Chunk Parser: Accessing Chunk Features</a> section.</p>
<p>Chunk parser objects are represented by handles of the <code>PYLON_CHUNKPARSER_HANDLE</code> type.</p>
<h2><a class="anchor" id="arch_param"></a>
Parameters</h2>
<p>The behavior of some kinds of objects (camera objects in particular) can be controlled by the application through a set of related <em>parameters</em> (sometimes also called <em>features</em>). Parameters are named entities having a value that may or may not be readable or writable by the application. Writing a new value to an object's parameter will generally modify the behavior of that object.</p>
<p>Every parameter has an associated type. There are currently six different types defined:</p>
<ul>
<li>Integer - An integer parameter represents a feature that can be set by an integer number, such as a camera's image width or height in pixels. The current value of an integer parameter is augmented by a minimum and a maximum value, defining a range of allowed values for the parameter, and an increment that acts as a 'step width' for changes to the parameter's value. The set of all allowed values for an integer parameter can hence be expressed as x&#160;:=&#160;{minimum}&#160;+&#160;N&#160;*&#160;{increment}, with N&#160;=&#160;0,1,2&#160;..., x&#160;&lt;=&#160;{maximum}. The current value, minimum, maximum, and increment can all be accessed as 64 bit values via functions provided by pylon&#160;C for this purpose. </li>
<li>Float - A float parameter represents a feature that can be set by a floating-point value, such as a camera's exposure time expressed in seconds. It resembles the integer parameter with two exceptions: all values are of the 'double' type (double precision floating point numbers as defined by the IEEE 754 standard), and there is no increment value. Hence, a float parameter is allowed to take any value from the interval {minimum}&#160;&lt;=&#160;x&#160;&lt;={maximum}. </li>
<li>Boolean - A boolean parameter represents a binary-valued feature, which, can be enabled or disabled. pylon&#160;C provides functions for checking the current state and setting the parameter. An example for a boolean parameter would be a 'switch' to enable or disable a particular feature, such as a camera's external trigger input. </li>
<li>String - The parameter's value is a text string like, for example, a camera's type designator or its serial number. </li>
<li>Enumeration - The parameter can take any value from a predefined set. The set of possible values is organized as an ordered list, such that any value can be identified by a both name (text string) and an index (integer number). </li>
<li>Command - A command parameter represents an executable feature, a provides a way of telling an object to perform a certain action. The operation thus triggered may need some time to execute, and will eventually terminate. An example is the 'perform white balance auto calibration' command that may be available for a color camera. A command parameter can be queried for its execution state (whether the command is still executing or has already terminated).</li>
</ul>
<p>Every parameter also has an associated <em>access mode</em> that determines the kind of access allowed. There are currently four access modes defined:</p>
<ul>
<li>Implemented - A parameter with the given name actually exists, because the object does implement the related feature. Some features are only available for certain devices and not for others. For example, a monochrome camera will not have a white balance feature, and consequently will not have a parameter named "WhiteBalance". </li>
<li>Available - Depending on the object's state, a parameter may be temporarily unavailable. For example, a camera parameter related to external triggering may not be available while the camera is in free run mode. 'Available' implies 'implemented'. </li>
<li>Readable - A parameter's value can be read. 'Readable' implies 'available'. </li>
<li>Writable - A parameter's value can be changed (set). 'Writable' implies 'available'.</li>
</ul>
<p>Parameters can be both readable and writable at the same time.</p>
<h2><a class="anchor" id="arch_grab_basics"></a>
Image Terminology Issues</h2>
<p>Throughout this document, a distinction is made between image acquisition, image data transfer, and image grabbing. It is essential to understand the exact meaning of these terms.</p>
<p>The operations performed internally by the camera to produce a single image are collectively termed <em>image acquisition</em>. This includes, among other things, controlling exposure of the image sensor and sensor read-out. This process eventually results in the camera being ready to transfer image data out of the camera to the computer. <em>Image data transfer</em> designates the transfer of the aquired data from the camera's memory to the computer via the camera's interface, e.g., USB or Gigabit Ethernet. The process of writing the image data to the computer's main memory is referred to as <em>image grabbing</em>.</p>
<h1><a class="anchor" id="pylon_programming"></a>
Programming the pylon C API</h1>
<h2><a class="anchor" id="pylonprog_debugging_gige"></a>
Debugging pylon Applications Using GigE Cameras</h2>
<p>When debugging a pylon application using GigE cameras you may encounter heartbeat timeouts. The application must send special network packets to the camera in defined intervals. If the camera doesn't receive these heartbeats it will consider the connection as broken and won't accept any commands from the application. This requires setting the heartbeat timeout of a camera to a higher value when debugging. The <a class="el" href="buildingapplications.html#debugginggige">build topics section</a> shows how to do this.</p>
<h2><a class="anchor" id="pylonprog_init"></a>
Initialization/Uninitialization of the pylon C Runtime Library</h2>
<p>The pylon&#160;C runtime system must be initialized before use. A pylon based application must call the <code><a class="el" href="group__pylon.html#gab3304990fb825b61d47267f6cfb7b768" title="Initialize the pylon&#160;C runtime system. ">PylonInitialize()</a></code> function before using any other functions of the pylon&#160;C runtime system.</p>
<div class="fragment"><div class="line"><span class="comment">/* Before using any pylon methods, the pylon runtime must be initialized. */</span></div><div class="line"><a class="code" href="group__pylon.html#gab3304990fb825b61d47267f6cfb7b768">PylonInitialize</a>();</div></div><!-- fragment --><p>Before an application exits, it must call the <code><a class="el" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503" title="Shut down the pylon&#160;C runtime system. ">PylonTerminate()</a></code> function to free resources allocated by the pylon&#160;C runtime system.</p>
<div class="fragment"><div class="line"><span class="comment">/* ... Shut down the pylon runtime system. Don&#39;t call any pylon method after</span></div><div class="line"><span class="comment">   calling PylonTerminate(). */</span></div><div class="line"><a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div></div><!-- fragment --><h2><a class="anchor" id="pylonprog_errorhandling"></a>
Error Handling</h2>
<p>All pylon&#160;C API functions return a value of the GENAPIC_RESULT (see <a class="el" href="group__errorcodes.html">Error&#160;Codes</a>) type, defined in <a class="el" href="_gen_api_c_error_8h.html" title="Error codes for GenApi C bindings. ">GenApiCError.h</a>. The return value is <code>GENAPI_E_OK</code> if the function completed normally without detecting any errors. Otherwise, an error code is returned. This will either be one of the <code>GENAPI_E_XXX</code> error codes defined in <a class="el" href="_gen_api_c_error_8h.html" title="Error codes for GenApi C bindings. ">GenApiCError.h</a>, if the error is detected in the GenApi layer that forms the basis of pylon&#160;C, or one of the <code>PYLON_E_XXX</code> error codes defined in <a class="el" href="_pylon_c_error_8h.html" title="Error codes for pylon C bindings. ">PylonCError.h</a>.</p>
<p>In addition to returning an error code, pylon&#160;C functions set up a textual error description that applications can retrieve. It consists of two parts that can be accessed via <code><a class="el" href="group__genapi.html#ga63a2890e8dac339372faebea5695abbd" title="Get a brief textual description of the latest error. ">GenApiGetLastErrorMessage()</a></code> and <code><a class="el" href="group__genapi.html#ga739bba460344dcd2b64062fd26d5261c" title="Get detailed textual description for the latest error details, e.g. the origin of the error...">GenApiGetLastErrorDetail()</a></code>. The string returned by <code><a class="el" href="group__genapi.html#ga63a2890e8dac339372faebea5695abbd" title="Get a brief textual description of the latest error. ">GenApiGetLastErrorMessage()</a></code> contains a concise description of the most recent error, suitable to be displayed to the user as part of an error message. Additional error information is returned by <code><a class="el" href="group__genapi.html#ga739bba460344dcd2b64062fd26d5261c" title="Get detailed textual description for the latest error details, e.g. the origin of the error...">GenApiGetLastErrorDetail()</a></code>; this error information is intended to aid in identifying the conditions that caused the error.</p>
<p>This is what a typical error handler might look like:</p>
<div class="fragment"><div class="line"><span class="comment">/* This function demonstrates how to retrieve the error message for the last failed</span></div><div class="line"><span class="comment">   function call. */</span></div><div class="line"><span class="keywordtype">void</span> printErrorAndExit( GENAPIC_RESULT errc )</div><div class="line">{</div><div class="line">    <span class="keywordtype">char</span> *errMsg;</div><div class="line">    <span class="keywordtype">size_t</span> length;</div><div class="line"></div><div class="line">    <span class="comment">/* Retrieve the error message.</span></div><div class="line"><span class="comment">    ... First find out how big the buffer must be, */</span></div><div class="line">    <a class="code" href="group__genapi.html#ga63a2890e8dac339372faebea5695abbd">GenApiGetLastErrorMessage</a>( NULL, &amp;length );</div><div class="line">    errMsg = (<span class="keywordtype">char</span>*) malloc( length );</div><div class="line">    <span class="comment">/* ... and retrieve the message. */</span></div><div class="line">    <a class="code" href="group__genapi.html#ga63a2890e8dac339372faebea5695abbd">GenApiGetLastErrorMessage</a>( errMsg, &amp;length );</div><div class="line"></div><div class="line">    fprintf( stderr, <span class="stringliteral">&quot;%s (%#08x).\n&quot;</span>, errMsg, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) errc);</div><div class="line">    free( errMsg);</div><div class="line"></div><div class="line">    <span class="comment">/* Retrieve the more details about the error</span></div><div class="line"><span class="comment">    ... First find out how big the buffer must be, */</span></div><div class="line">    <a class="code" href="group__genapi.html#ga739bba460344dcd2b64062fd26d5261c">GenApiGetLastErrorDetail</a>( NULL, &amp;length );</div><div class="line">    errMsg = (<span class="keywordtype">char</span>*) malloc( length );</div><div class="line">    <span class="comment">/* ... and retrieve the message. */</span></div><div class="line">    <a class="code" href="group__genapi.html#ga739bba460344dcd2b64062fd26d5261c">GenApiGetLastErrorDetail</a>( errMsg, &amp;length );</div><div class="line"></div><div class="line">    fprintf( stderr, <span class="stringliteral">&quot;%s\n&quot;</span>, errMsg);</div><div class="line">    free( errMsg);</div><div class="line"></div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();  <span class="comment">/* Releases all pylon resources */</span></div><div class="line">    pressEnterToExit();</div><div class="line"></div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">}</div></div><!-- fragment --><p>All programming examples use a macro to check for error conditions and conditionally invoke the above error handler:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CHECK( errc ) if ( GENAPI_E_OK != errc ) printErrorAndExit( errc )</span></div></div><!-- fragment --><h2><a class="anchor" id="pylonprog_enum"></a>
Enumerating and Creating Camera Objects</h2>
<p>In pylon&#160;C, camera devices are managed by means of 'camera objects'. A camera object is a software abstraction and is represented by a handle of the <code>PYLON_DEVICE_HANDLE</code> type. Available devices are discovered dynamically, using facilities provided by the transport layer.</p>
<p>Device discovery (aka enumeration) is a two-step process. In the first step, the <code><a class="el" href="group__pylon.html#ga107201b44a28c3d5fb655e89a73946e9" title="Enumerate all camera devices. ">PylonEnumerateDevices()</a></code> function returns, in its <em>numDevices</em> argument,the total number of camera devices detected for all interfaces. Assuming this value is N, you can then access every camera using a numeric index from the range [0&#160;..&#160;N-1]. In the second step, <a class="el" href="group__pylon.html#ga71c722f722db7e3541dabf6ee56a1323" title="Get information about camera device identified by its index. ">PylonGetDeviceInfo()</a> is called for every index value in turn. By looking at the fields of the <code><a class="el" href="struct_pylon_device_info__t.html" title="Device info struct. ">PylonDeviceInfo_t</a></code> struct, every individual camera can be identified. A call to <code><a class="el" href="group__pylon.html#ga59272fcd5548458a2e5b18f4f41f0db3" title="Return a handle for a camera device info object. ">PylonGetDeviceInfoHandle()</a></code> then translates the device index to a <code>PYLON_DEVICE_INFO_HANDLE</code> that can be used to query device properties. Finally, a device object (represented by a <code>PYLON_DEVICE_HANDLE</code>) can be created by calling <code><a class="el" href="group__pylon.html#gaa635d34dd80fbd30a1d495d90e3e152b" title="Create a device object. ">PylonCreateDeviceByIndex()</a></code>. A <code>PYLON_DEVICE_HANDLE</code> is required for all operations involving a device.</p>
<p>The code snippet below illustrates device enumeration and creation:</p>
<div class="fragment"><div class="line"><span class="comment">/* Enumerate all camera devices. You must call</span></div><div class="line"><span class="comment">PylonEnumerateDevices() before creating a device. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga107201b44a28c3d5fb655e89a73946e9">PylonEnumerateDevices</a>( &amp;numDevices );</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> ( 0 == numDevices )</div><div class="line">{</div><div class="line">    fprintf( stderr, <span class="stringliteral">&quot;No devices found.\n&quot;</span> );</div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">    pressEnterToExit();</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Get a handle for the first device found.  */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaa635d34dd80fbd30a1d495d90e3e152b">PylonCreateDeviceByIndex</a>( 0, &amp;hDev );</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>If an application is done using a device, the device handle must be destroyed:</p>
<div class="fragment"><div class="line"><span class="comment">/* ...The device is no longer used, destroy it. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga52908e60392f52b4bd055c5e821c4b62">PylonDestroyDevice</a> ( hDev );</div><div class="line">CHECK(res);</div></div><!-- fragment --><h2><a class="anchor" id="pylonprog_open"></a>
Opening and Closing a Camera</h2>
<p>Before access to camera parameters is possible, the transport layer must be initialized and a connection to the physical camera device must be established. This is achieved by calling the <code><a class="el" href="group__pylon.html#gaa90f00f56a23d31abe6634ff33fb981d" title="Open a device. ">PylonDeviceOpen()</a></code> function.</p>
<div class="fragment"><div class="line"><span class="comment">/* Before using the device, it must be opened. Open it for configuring</span></div><div class="line"><span class="comment">parameters and for grabbing images. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaa90f00f56a23d31abe6634ff33fb981d">PylonDeviceOpen</a>( hDev, PYLONC_ACCESS_MODE_CONTROL | PYLONC_ACCESS_MODE_STREAM );</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>To release the connection to a device, and to free all related resources, call the <code><a class="el" href="group__pylon.html#ga41878ee7b3ba7064553a6aac3ca37bcd" title="Close a device. ">PylonDeviceClose()</a></code> function.</p>
<div class="fragment"><div class="line"><span class="comment">/* ... Close and release the pylon device. The stream grabber becomes invalid</span></div><div class="line"><span class="comment">   after closing the pylon device. Don&#39;t call stream grabber related methods after</span></div><div class="line"><span class="comment">   closing or releasing the device. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga41878ee7b3ba7064553a6aac3ca37bcd">PylonDeviceClose</a>( hDev );</div><div class="line">CHECK(res);</div></div><!-- fragment --><h2><a class="anchor" id="pylonprog_config"></a>
Camera Configuration</h2>
<p>This section describes how a camera object is used to configure camera device parameters. For a discussion of all relevant concepts, see <a class="el" href="programmingguide.html#arch_param">Parameters</a>. Parameters are identified by their names. After opening the <em>pylon Viewer</em>, you can easily browse through all parameters that are available for a particular type of camera. This is described in more detail under <a class="el" href="programmingguide.html#advanced_parambrowse">Browsing Parameters</a>.</p>
<p>All functions that work on parameters respect accessibility. If the desired kind of access is not (currently) possible, error messages are returned accordingly. It is also possible to check for sufficient accessibility beforehand, using one of the following functions: <code><a class="el" href="group__pylon.html#ga32085fa30c27a5fc6fa9698057e2bc3f" title="Return boolean &#39;implemented&#39; status for feature. ">PylonDeviceFeatureIsImplemented()</a></code>, <code><a class="el" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989" title="Return boolean &#39;available&#39; status for feature. ">PylonDeviceFeatureIsAvailable()</a></code>, <code><a class="el" href="group__pylon.html#gaaef3e0144fd4f0ad0f18540899994d8d" title="Return boolean &#39;readable&#39; status for feature. ">PylonDeviceFeatureIsReadable()</a></code>, or <code><a class="el" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88" title="Return boolean &#39;writable&#39; status for feature. ">PylonDeviceFeatureIsWritable()</a></code>.</p>
<div class="fragment"><div class="line"><span class="comment">/* This function demonstrates how to check the presence, readability, and writability</span></div><div class="line"><span class="comment">   of a feature. */</span></div><div class="line"><span class="keywordtype">void</span> demonstrateAccessibilityCheck( <a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev )</div><div class="line">{</div><div class="line">    _Bool val;  <span class="comment">/* Output of the check functions */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Check to see if a feature is implemented at all. */</span></div><div class="line">    val = <a class="code" href="group__pylon.html#ga32085fa30c27a5fc6fa9698057e2bc3f">PylonDeviceFeatureIsImplemented</a>(hDev, <span class="stringliteral">&quot;Width&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;The &#39;Width&#39; feature %s implemented\n&quot;</span>, val ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line">    val = <a class="code" href="group__pylon.html#ga32085fa30c27a5fc6fa9698057e2bc3f">PylonDeviceFeatureIsImplemented</a>(hDev, <span class="stringliteral">&quot;MyCustomFeature&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;The &#39;MyCustomFeature&#39; feature %s implemented\n&quot;</span>, val ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Although a feature is implemented by the device, it might not be available</span></div><div class="line"><span class="comment">       with the device in its current state. Check to see if the feature is currently</span></div><div class="line"><span class="comment">       available. The PylonDeviceFeatureIsAvailable sets val to 0 if either the feature</span></div><div class="line"><span class="comment">       is not implemented or if the feature is not currently available. */</span></div><div class="line"></div><div class="line">    val = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;BinningVertical&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;The &#39;BinningVertical&#39; feature %s available\n&quot;</span>, val ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* If a feature is available, it could be read-only, write-only, or both</span></div><div class="line"><span class="comment">       readable and writable. Use the PylonDeviceFeatureIsReadable() and the</span></div><div class="line"><span class="comment">       PylonDeviceFeatureIsWritable() functions(). It is safe to call these functions</span></div><div class="line"><span class="comment">       for features that are currently not available or not implemented by the device.</span></div><div class="line"><span class="comment">       A feature that is not available or not implemented is neither readable nor writable.</span></div><div class="line"><span class="comment">       The readability and writability of a feature can change depending on the current</span></div><div class="line"><span class="comment">       state of the device. For example, the Width parameter might not be writable when</span></div><div class="line"><span class="comment">       the camera is acquiring images. */</span></div><div class="line"></div><div class="line"></div><div class="line">    val = <a class="code" href="group__pylon.html#gaaef3e0144fd4f0ad0f18540899994d8d">PylonDeviceFeatureIsReadable</a>(hDev, <span class="stringliteral">&quot;Width&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;The &#39;Width&#39; feature %s readable\n&quot;</span>, val ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line">    val = <a class="code" href="group__pylon.html#gaaef3e0144fd4f0ad0f18540899994d8d">PylonDeviceFeatureIsReadable</a>( hDev, <span class="stringliteral">&quot;MyCustomFeature&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;The &#39;MyCustomFeature&#39; feature %s readable\n&quot;</span>, val ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line"></div><div class="line">    val = <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>( hDev, <span class="stringliteral">&quot;Width&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;The &#39;Width&#39; feature %s writable\n&quot;</span>, val ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>The next code snippet demonstrates how to read and set an integer parameter:</p>
<div class="fragment"><div class="line"><span class="comment">/* This function demonstrates how to handle integer camera parameters. */</span></div><div class="line"><span class="keywordtype">void</span> demonstrateIntFeature( <a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev )</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>   featureName[] = <span class="stringliteral">&quot;Width&quot;</span>;  <span class="comment">/* Name of the feature used in this sample: AOI Width */</span></div><div class="line">    int64_t             val, min, max, incr;      <span class="comment">/* Properties of the feature */</span></div><div class="line">    GENAPIC_RESULT      res;                      <span class="comment">/* Return value */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( <a class="code" href="group__pylon.html#gaaef3e0144fd4f0ad0f18540899994d8d">PylonDeviceFeatureIsReadable</a>(hDev, featureName) )</div><div class="line">    {</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">          Query the current value, the allowed value range, and the increment of the feature.</span></div><div class="line"><span class="comment">          For some integer features, you are not allowed to set every value within the</span></div><div class="line"><span class="comment">          value range. For example, for some cameras the Width parameter must be a multiple</span></div><div class="line"><span class="comment">          of 2. These constraints are expressed by the increment value. Valid values</span></div><div class="line"><span class="comment">          follow the rule: val &gt;= min &amp;&amp; val &lt;= max &amp;&amp; val == min + n * inc. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#gae3a4b41a5f15a6b9c5e58af2b9729d8f">PylonDeviceGetIntegerFeatureMin</a>( hDev, featureName, &amp;min );  <span class="comment">/* Get the minimum value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__pylon.html#gaeeb89386ddc12bf89e3e6f41c1c82750">PylonDeviceGetIntegerFeatureMax</a>( hDev, featureName, &amp;max );  <span class="comment">/* Get the maximum value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__pylon.html#ga9e734ff5ec5e1f5174338691d9e78431">PylonDeviceGetIntegerFeatureInc</a>( hDev, featureName, &amp;incr);  <span class="comment">/* Get the increment value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__pylon.html#gae91b560e639a7ad3182f388c3b57c185">PylonDeviceGetIntegerFeature</a>( hDev, featureName, &amp;val );     <span class="comment">/* Get the current value. */</span></div><div class="line">        CHECK(res);</div><div class="line"></div><div class="line"><span class="preprocessor">#if __STDC_VERSION__ &gt;= 199901L || defined(__GNUC__)</span></div><div class="line">        printf(<span class="stringliteral">&quot;%s: min= %lld  max= %lld  incr=%lld  Value=%lld\n&quot;</span>, featureName, (<span class="keywordtype">long</span> <span class="keywordtype">long</span> ) min, (<span class="keywordtype">long</span> <span class="keywordtype">long</span> ) max, (<span class="keywordtype">long</span> <span class="keywordtype">long</span> ) incr, (<span class="keywordtype">long</span> <span class="keywordtype">long</span> ) val );</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        printf(<span class="stringliteral">&quot;%s: min= %I64d  max= %I64d  incr=%I64d  Value=%I64d\n&quot;</span>, featureName, min, max, incr, val );</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ( <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>(hDev, featureName) )</div><div class="line">        {</div><div class="line">            <span class="comment">/* Set the Width half-way between minimum and maximum. */</span></div><div class="line">            res = <a class="code" href="group__pylon.html#ga6197f7aa18b1689db37665d7ae5c36e1">PylonDeviceSetIntegerFeature</a>( hDev, featureName, min + (max - min) / incr / 2 * incr );</div><div class="line">            CHECK(res);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;The %s feature is not writable.\n&quot;</span>, featureName );</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;The %s feature is not readable.\n&quot;</span>, featureName );</div><div class="line">}</div></div><!-- fragment --><p>32 bit variants of the integer access functions are also provided for convenience. These allow to handle the common case where all values are known to be 32 bit entities more easily:</p>
<div class="fragment"><div class="line"><span class="comment">/* The integer functions illustrated above take 64 bit integers as output parameters. There are variants</span></div><div class="line"><span class="comment">   of the integer functions that accept 32 bit integers instead. The Get.... functions return</span></div><div class="line"><span class="comment">   an error when the value returned by the device doesn&#39;t fit into a 32 bit integer. */</span></div><div class="line"><span class="keywordtype">void</span> demonstrateInt32Feature( <a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev )</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>   featureName[] = <span class="stringliteral">&quot;Height&quot;</span>;  <span class="comment">/* Name of the feature used in this sample: AOI height */</span></div><div class="line">    int32_t             val, min, max, incr;       <span class="comment">/* Properties of the feature */</span></div><div class="line">    GENAPIC_RESULT      res;                       <span class="comment">/* Return value */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( <a class="code" href="group__pylon.html#gaaef3e0144fd4f0ad0f18540899994d8d">PylonDeviceFeatureIsReadable</a>(hDev, featureName) )</div><div class="line">    {</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">           Query the current value, the allowed value range, and the increment of the feature.</span></div><div class="line"><span class="comment">           For some integer features, you are not allowed to set every value within the</span></div><div class="line"><span class="comment">           value range. For example, for some cameras the Width parameter must be a multiple</span></div><div class="line"><span class="comment">           of 2. These constraints are expressed by the increment value. Valid values</span></div><div class="line"><span class="comment">           follow the rule: val &gt;= min &amp;&amp; val &lt;= max &amp;&amp; val == min + n * inc. */</span></div><div class="line">        res = PylonDeviceGetIntegerFeatureMinInt32( hDev, featureName, &amp;min );  <span class="comment">/* Get the minimum value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = PylonDeviceGetIntegerFeatureMaxInt32( hDev, featureName, &amp;max );  <span class="comment">/* Get the maximum value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = PylonDeviceGetIntegerFeatureIncInt32( hDev, featureName, &amp;incr);  <span class="comment">/* Get the increment value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = PylonDeviceGetIntegerFeatureInt32( hDev, featureName, &amp;val );     <span class="comment">/* Get the current value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        printf(<span class="stringliteral">&quot;%s: min= %d  max= %d  incr=%d  Value=%d\n&quot;</span>, featureName, min, max, incr, val );</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ( <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>(hDev, featureName) )</div><div class="line">        {</div><div class="line">            <span class="comment">/* Set the value to half its maximum  */</span></div><div class="line">            res = PylonDeviceSetIntegerFeatureInt32( hDev, featureName, min + (max - min) / incr / 2 * incr );</div><div class="line">            CHECK(res);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;The %s feature is not writable.\n&quot;</span>, featureName );</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;The %s feature is not readable.\n&quot;</span>, featureName );</div><div class="line">}</div></div><!-- fragment --><p>Setting float parameters is similar, but there is no increment:</p>
<div class="fragment"><div class="line"><span class="comment">/* Some features are floating point features. This function illustrates how to set and get floating</span></div><div class="line"><span class="comment">   point parameters. */</span></div><div class="line"><span class="keywordtype">void</span> demonstrateFloatFeature( <a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev )</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>   featureName[] = <span class="stringliteral">&quot;Gamma&quot;</span>;  <span class="comment">/* The name of the feature used */</span></div><div class="line">    _Bool                isWritable;               <span class="comment">/* Is the feature writable? */</span></div><div class="line">    <span class="keywordtype">double</span>              min, max, value;          <span class="comment">/* Value range and current value */</span></div><div class="line">    GENAPIC_RESULT      res;                      <span class="comment">/* Return value */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( <a class="code" href="group__pylon.html#gaaef3e0144fd4f0ad0f18540899994d8d">PylonDeviceFeatureIsReadable</a>(hDev, featureName) )</div><div class="line">    {</div><div class="line">        <span class="comment">/* Query the value range and the current value. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#ga9680e954cad71c9dc3d3fd04c9bda667">PylonDeviceGetFloatFeatureMin</a>( hDev, featureName, &amp;min);</div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__pylon.html#gabf8bd507f7c09c6eeb6962896389c708">PylonDeviceGetFloatFeatureMax</a>( hDev, featureName, &amp;max);</div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__pylon.html#gaf7e5a67b74fe82fc9e3c944f8ad3da8c">PylonDeviceGetFloatFeature</a>( hDev, featureName, &amp;value );</div><div class="line">        CHECK(res);</div><div class="line"></div><div class="line">        printf(<span class="stringliteral">&quot;%s: min = %4.2f, max = %4.2f, value = %4.2f\n&quot;</span>, featureName, min, max, value );</div><div class="line"></div><div class="line">        <span class="comment">/* Set the value to half its maximum. */</span></div><div class="line">        isWritable = <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>(hDev, featureName);</div><div class="line">        <span class="keywordflow">if</span> ( isWritable )</div><div class="line">        {</div><div class="line">            value = 0.5 * ( min + max );</div><div class="line">            printf(<span class="stringliteral">&quot;Setting %s to %4.2f\n&quot;</span>, featureName, value );</div><div class="line">            res = <a class="code" href="group__pylon.html#ga000efa39f55f2c51eef7d29fef7e6420">PylonDeviceSetFloatFeature</a>( hDev, featureName, value );</div><div class="line">            CHECK(res);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;The %s feature is not writable.\n&quot;</span>, featureName );</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;The %s feature is not readable.\n&quot;</span>, featureName );</div><div class="line">}</div></div><!-- fragment --><p>Setting boolean parameters is even simpler:</p>
<div class="fragment"><div class="line"><span class="comment">/* Some features are boolean features that can be switched on and off.</span></div><div class="line"><span class="comment">   This function illustrates how to access boolean features. */</span></div><div class="line"><span class="keywordtype">void</span> demonstrateBooleanFeature( <a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev )</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>   featureName[] = <span class="stringliteral">&quot;GammaEnable&quot;</span>; <span class="comment">/* The name of the feature */</span></div><div class="line">    _Bool                isWritable;                    <span class="comment">/* Is the feature writable? */</span></div><div class="line">    _Bool                value;                         <span class="comment">/* The value of the feature */</span></div><div class="line">    GENAPIC_RESULT      res;                           <span class="comment">/* Return value */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Check to see if the feature is writable. */</span></div><div class="line">    isWritable = <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>(hDev, featureName);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( isWritable )</div><div class="line">    {</div><div class="line">        <span class="comment">/* Retrieve the current state of the feature. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#ga2f6d5c1917521cbc55502aface12943f">PylonDeviceGetBooleanFeature</a>( hDev, featureName, &amp;value);</div><div class="line">        CHECK(res);</div><div class="line">        printf(<span class="stringliteral">&quot;The %s features is %s\n&quot;</span>, featureName, value ? <span class="stringliteral">&quot;on&quot;</span> : <span class="stringliteral">&quot;off&quot;</span> );</div><div class="line"></div><div class="line">        <span class="comment">/* Set a new value. */</span></div><div class="line">        value = (_Bool) !value;  <span class="comment">/* New value */</span></div><div class="line">        printf(<span class="stringliteral">&quot;Switching the %s feature %s\n&quot;</span>, featureName, value ? <span class="stringliteral">&quot;on&quot;</span> : <span class="stringliteral">&quot;off&quot;</span> );</div><div class="line">        res = <a class="code" href="group__pylon.html#gab566c93ad19a2aa3f0e4ae9589c54c47">PylonDeviceSetBooleanFeature</a>( hDev, featureName, value );</div><div class="line">        CHECK(res);</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        printf(<span class="stringliteral">&quot;The %s feature isn&#39;t writable\n&quot;</span>, featureName );</div><div class="line">}</div></div><!-- fragment --><p>An enumeration parameter can only be set to one of the members of a predefined set:</p>
<div class="fragment"><div class="line"><span class="comment">/* There are camera features that behave like enumerations. These features can take a value from a fixed</span></div><div class="line"><span class="comment">   set of possible values. One example is the pixel format feature. This function illustrates how to deal with</span></div><div class="line"><span class="comment">   enumeration features.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordtype">void</span> demonstrateEnumFeature( <a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev )</div><div class="line">{</div><div class="line">    <span class="keywordtype">char</span>                value[64];                     <span class="comment">/* The current value of the feature */</span></div><div class="line">    <span class="keywordtype">size_t</span>              len;                           <span class="comment">/* The length of the string */</span></div><div class="line">    GENAPIC_RESULT      res;                           <span class="comment">/* Return value */</span></div><div class="line">    _Bool                isWritable,</div><div class="line">                        supportsMono8,</div><div class="line">                        supportsYUV422Packed,</div><div class="line">                        supportsMono16;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* The allowed values for an enumeration feature are represented as strings. Use the</span></div><div class="line"><span class="comment">    PylonDeviceFeatureFromString() and PylonDeviceFeatureToString() methods for setting and getting</span></div><div class="line"><span class="comment">    the value of an enumeration feature. */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get the current value of the enumeration feature. */</span></div><div class="line">    len = <span class="keyword">sizeof</span>(value);</div><div class="line">    res = <a class="code" href="group__pylon.html#ga5a76d4b8774f57ce24f30fe6da41abf7">PylonDeviceFeatureToString</a>( hDev, <span class="stringliteral">&quot;PixelFormat&quot;</span>, value, &amp;len );</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;PixelFormat: %s\n&quot;</span>, value);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">      For an enumeration feature, the pylon Viewer&#39;s &quot;Feature Documentation&quot; window lists the the</span></div><div class="line"><span class="comment">      names of the possible values. Some of the values might not be supported by the device.</span></div><div class="line"><span class="comment">      To check if a certain &quot;SomeValue&quot; value for a &quot;SomeFeature&quot; feature can be set, call the</span></div><div class="line"><span class="comment">      PylonDeviceFeatureIsAvailable() function with &quot;EnumEntry_SomeFeature_SomeValue&quot; as an argument.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="comment">/* Check to see if the Mono8 pixel format can be set. */</span></div><div class="line">    supportsMono8 = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;EnumEntry_PixelFormat_Mono8&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;Mono8 %s a supported value for the PixelFormat feature\n&quot;</span>, supportsMono8 ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Check to see if the YUV422Packed pixel format can be set. */</span></div><div class="line">    supportsYUV422Packed = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;EnumEntry_PixelFormat_YUV422Packed&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;YUV422Packed %s a supported value for the PixelFormat feature\n&quot;</span>, supportsYUV422Packed ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Check to see if the Mono16 pixel format can be set. */</span></div><div class="line">    supportsMono16 = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;EnumEntry_PixelFormat_Mono16&quot;</span>);</div><div class="line">    printf(<span class="stringliteral">&quot;Mono16 %s a supported value for the PixelFormat feature\n&quot;</span>, supportsMono16 ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;isn&#39;t&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Before writing a value, we recommend checking to see if the enumeration feature is</span></div><div class="line"><span class="comment">       currently writable. */</span></div><div class="line">    isWritable = <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>(hDev, <span class="stringliteral">&quot;PixelFormat&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> ( isWritable )</div><div class="line">    {</div><div class="line">        <span class="comment">/* The PixelFormat feature is writable, set it to one of the supported values. */</span></div><div class="line">        <span class="keywordflow">if</span> ( supportsMono16 )</div><div class="line">        {</div><div class="line">            printf(<span class="stringliteral">&quot;Setting PixelFormat to Mono16\n&quot;</span>);</div><div class="line">            res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;PixelFormat&quot;</span>, <span class="stringliteral">&quot;Mono16&quot;</span> );</div><div class="line">            CHECK(res);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( supportsYUV422Packed )</div><div class="line">        {</div><div class="line">            printf(<span class="stringliteral">&quot;Setting PixelFormat to YUV422Packed\n&quot;</span>);</div><div class="line">            res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;PixelFormat&quot;</span>, <span class="stringliteral">&quot;YUV422Packed&quot;</span> );</div><div class="line">            CHECK(res);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( supportsMono8 )</div><div class="line">        {</div><div class="line">            printf(<span class="stringliteral">&quot;Setting PixelFormat to Mono8\n&quot;</span>);</div><div class="line">            res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;PixelFormat&quot;</span>, <span class="stringliteral">&quot;Mono8&quot;</span> );</div><div class="line">            CHECK(res);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Reset the PixelFormat feature to its previous value. */</span></div><div class="line">        <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;PixelFormat&quot;</span>, value );</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>The next code snippet demonstrates use of a command parameter:</p>
<div class="fragment"><div class="line"><span class="comment">/* There are camera features, such as starting image acquisition, that represent a command.</span></div><div class="line"><span class="comment">   This function that loads the factory settings, illustrates how to execute a command feature.  */</span></div><div class="line"><span class="keywordtype">void</span> demonstrateCommandFeature( <a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev )</div><div class="line">{</div><div class="line">    GENAPIC_RESULT      res;  <span class="comment">/* Return value. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Before executing the user set load command, the user set selector must be</span></div><div class="line"><span class="comment">       set to the default set. Since we are focusing on the command feature,</span></div><div class="line"><span class="comment">       we skip the recommended steps for checking the availability of the user set</span></div><div class="line"><span class="comment">       related features and values. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Choose the default configuration set (with one of the factory setups chosen). */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;UserSetSelector&quot;</span>, <span class="stringliteral">&quot;Default&quot;</span> );</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line">    <span class="comment">/* Execute the user set load command. */</span></div><div class="line">    printf(<span class="stringliteral">&quot;Loading the default set.\n&quot;</span>);</div><div class="line">    res = <a class="code" href="group__pylon.html#ga6dde7a627bdcc2405151c822fd2a9bb1">PylonDeviceExecuteCommandFeature</a>( hDev, <span class="stringliteral">&quot;UserSetLoad&quot;</span> );</div><div class="line">    CHECK(res);</div><div class="line">}</div></div><!-- fragment --><p>All kinds of parameters can be accessed as strings, as demonstrated by the following code snippet:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  Regardless of the parameter&#39;s type, any parameter value can be retrieved as a string. Each parameter</span></div><div class="line"><span class="comment">  can be set by passing in a string correspondingly. This function illustrates how to set and get the</span></div><div class="line"><span class="comment">  Width parameter as string. As demonstrated above, the Width parameter is of the integer type.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"><span class="keywordtype">void</span> demonstrateFromStringToString( <a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev )</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>   featureName[] = <span class="stringliteral">&quot;Width&quot;</span>;   <span class="comment">/* The name of the feature */</span></div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span>              len;</div><div class="line">    <span class="keywordtype">char</span>*               buf;</div><div class="line">    <span class="keywordtype">char</span>                smallBuf[1];</div><div class="line">    <span class="keywordtype">char</span>                properBuf[32];</div><div class="line">    GENAPIC_RESULT      res;                       <span class="comment">/* Return value */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Get the value of a feature as a string. Normally getting the value consits of 3 steps:</span></div><div class="line"><span class="comment">       1.) Determine the required buffer size.</span></div><div class="line"><span class="comment">       2.) Allocate the buffer.</span></div><div class="line"><span class="comment">       3.) Retrieve the value. */</span></div><div class="line">    <span class="comment">/* ... Get the required buffer size. The size is queried by</span></div><div class="line"><span class="comment">           passing a NULL pointer as a pointer to the buffer. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#ga5a76d4b8774f57ce24f30fe6da41abf7">PylonDeviceFeatureToString</a>( hDev, featureName, NULL, &amp;len );</div><div class="line">    CHECK(res);</div><div class="line">    <span class="comment">/* ... Len is set to the required buffer size (terminating zero included).</span></div><div class="line"><span class="comment">           Allocate the memory and retrieve the string. */</span></div><div class="line">    buf = (<span class="keywordtype">char</span>*) alloca( len );</div><div class="line">    res = <a class="code" href="group__pylon.html#ga5a76d4b8774f57ce24f30fe6da41abf7">PylonDeviceFeatureToString</a>( hDev, featureName, buf, &amp;len );</div><div class="line">    CHECK( res );</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;%s: %s\n&quot;</span>, featureName, buf );</div><div class="line"></div><div class="line">    <span class="comment">/* You are not necessarily required to query the buffer size in advance. If the buffer is</span></div><div class="line"><span class="comment">       big enough, passing in a buffer and a pointer to its length will work.</span></div><div class="line"><span class="comment">       When the buffer is too small, an error is returned. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Passing in a buffer that is too small */</span></div><div class="line">    len = <span class="keyword">sizeof</span> (smallBuf);</div><div class="line">    res = <a class="code" href="group__pylon.html#ga5a76d4b8774f57ce24f30fe6da41abf7">PylonDeviceFeatureToString</a>( hDev, featureName, smallBuf, &amp;len );</div><div class="line">    <span class="keywordflow">if</span> ( res == <a class="code" href="group__errorcodes.html#ga13ccf80133dac135eb9da4ba1737dda1">GENAPI_E_INSUFFICIENT_BUFFER</a> )</div><div class="line">    {</div><div class="line">        <span class="comment">/* The buffer was too small. The required size is indicated by len. */</span></div><div class="line">        printf(<span class="stringliteral">&quot;Buffer is too small for the value of &#39;%s&#39;. The required buffer size is %d\n&quot;</span>, featureName, (<span class="keywordtype">int</span>) len );</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        CHECK(res);  <span class="comment">/* Unexpected return value */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Passing in a buffer with sufficient size. */</span></div><div class="line">    len = <span class="keyword">sizeof</span> (properBuf );</div><div class="line">    res = <a class="code" href="group__pylon.html#ga5a76d4b8774f57ce24f30fe6da41abf7">PylonDeviceFeatureToString</a>( hDev, featureName, properBuf, &amp;len );</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* A feature can be set as a string using the PylonDeviceFeatureFromString() function.</span></div><div class="line"><span class="comment">       If the content of a string can not be converted to the type of the feature, an</span></div><div class="line"><span class="comment">       error is returned. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, featureName, <span class="stringliteral">&quot;fourty-two&quot;</span>); <span class="comment">/* Can not be converted to an integer */</span></div><div class="line">    <span class="keywordflow">if</span> ( res != <a class="code" href="group__errorcodes.html#gac7281a9a8cebe48fa600a002fbd3b598">GENAPI_E_OK</a> )</div><div class="line">    {</div><div class="line">        <span class="comment">/* Print out an error message. */</span></div><div class="line">        <span class="keywordtype">size_t</span> l;</div><div class="line">        <span class="keywordtype">char</span> *msg;</div><div class="line">        <a class="code" href="group__genapi.html#ga63a2890e8dac339372faebea5695abbd">GenApiGetLastErrorMessage</a>( NULL, &amp;l ); <span class="comment">/* Retrieve buffer size for the error message */</span></div><div class="line">        msg = (<span class="keywordtype">char</span> *)malloc(l);             <span class="comment">/* Provide memory */</span></div><div class="line">        <a class="code" href="group__genapi.html#ga63a2890e8dac339372faebea5695abbd">GenApiGetLastErrorMessage</a>( msg, &amp;l );  <span class="comment">/* Retrieve the message */</span></div><div class="line">        printf(<span class="stringliteral">&quot;%s\n&quot;</span>, msg );</div><div class="line">        free(msg);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="pylonprog_grab"></a>
Grabbing Images</h2>
<h3><a class="anchor" id="pylonprog_grab_grabsingleframe"></a>
Grabbing Using the PylonDeviceGrabSingleFrame() Function</h3>
<p>The easiest way to grab an image using pylon&#160;C API is to call the <code><a class="el" href="group__pylon.html#gafea7db714d0542d2e47e68d288700004" title="Set the acquision mode to &#39;single frame&#39; and grab one image. ">PylonDeviceGrabSingleFrame()</a></code> function. First, set up the camera using the methods described in <a class="el" href="programmingguide.html#pylonprog_config">Camera Configuration</a>. Then call <code><a class="el" href="group__pylon.html#gafea7db714d0542d2e47e68d288700004" title="Set the acquision mode to &#39;single frame&#39; and grab one image. ">PylonDeviceGrabSingleFrame()</a></code> to grab the image. It will adjust all neccessary parameters and grab an image into the buffer passed. This is shown in the following code snippet:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_pylon_grab_result__t.html">PylonGrabResult_t</a> grabResult;</div><div class="line">_Bool bufferReady;</div><div class="line"></div><div class="line"><span class="comment">/* Grab one single frame from stream channel 0. The</span></div><div class="line"><span class="comment">camera is set to single frame acquisition mode.</span></div><div class="line"><span class="comment">Wait up to 500 ms for the image to be grabbed. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gafea7db714d0542d2e47e68d288700004">PylonDeviceGrabSingleFrame</a>( hDev, 0, imgBuf, payloadSize,</div><div class="line">    &amp;grabResult, &amp;bufferReady, 500 );</div><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="group__errorcodes.html#gac7281a9a8cebe48fa600a002fbd3b598">GENAPI_E_OK</a> == res &amp;&amp; !bufferReady )</div><div class="line">{</div><div class="line">    <span class="comment">/* Timeout occurred. */</span></div><div class="line">    printf(<span class="stringliteral">&quot;Frame %d: timeout\n&quot;</span>, i+1);</div><div class="line">}</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Check to see if the image was grabbed successfully. */</span></div><div class="line"><span class="keywordflow">if</span> ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3217646a22faa23c898dfdc892ca3aca">Status</a> == <a class="code" href="group__pylon.html#gga7ef7a5f4d132577498ce7206274046fea354b91f0a367f3779da75499a612147a">Grabbed</a> )</div><div class="line">{</div><div class="line">    <span class="comment">/* Success. Perform image processing. */</span></div><div class="line">    getMinMax( imgBuf, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a5de217563769a2fecc939a8803c0de49">SizeX</a>, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#ac53ad1519fff771ec8810fb5ffea222d">SizeY</a>, &amp;min, &amp;max );</div><div class="line">    printf(<span class="stringliteral">&quot;Grabbed frame #%2d. Min. gray value = %3u, Max. gray value = %3u\n&quot;</span>, i+1, min, max);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3217646a22faa23c898dfdc892ca3aca">Status</a> == <a class="code" href="group__pylon.html#gga7ef7a5f4d132577498ce7206274046fea1f506c828f4945d6b5a7bf71445f7d54">Failed</a> )</div><div class="line">{</div><div class="line">    fprintf( stderr,  <span class="stringliteral">&quot;Frame %d wasn&#39;t grabbed successfully.  Error code = 0x%08X\n&quot;</span>,</div><div class="line">        i+1, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a597c9f0ddc8e7a63df7e108441e9bd78">ErrorCode</a> );</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Even though using <code><a class="el" href="group__pylon.html#gafea7db714d0542d2e47e68d288700004" title="Set the acquision mode to &#39;single frame&#39; and grab one image. ">PylonDeviceGrabSingleFrame()</a></code> is quite easy there are some limitations. It will, for instance, involve much set up and shutdown work for each invocation of the function, thus causing considerable overhead and execution time. <br />
If you need more flexibility or want to achieve the maximum possible frame rate you'll need to grab using stream grabber objects (see <a class="el" href="programmingguide.html#pylonprog_grab_usingstreamgrabber">Grabbing Using Stream Grabber Objects</a>). This will allow maximum control over the grab process.</dd></dl>
<h3><a class="anchor" id="pylonprog_grab_usingstreamgrabber"></a>
Grabbing Using Stream Grabber Objects</h3>
<p>The following sections describe the use of stream grabber objects. The order of the section reflects the sequence in which a typical grab application will use a stream grabber object.</p>
<h3><a class="anchor" id="pylonprog_grab_gettingstreamgrabber"></a>
Getting a Stream Grabber</h3>
<p>Stream grabber objects are managed by camera objects. The number of stream grabbers provided by a camera can be determined using the <code><a class="el" href="group__pylon.html#ga9a3ad0ce0576aaff19d7b6f3172ef5b8" title="Return the number of stream grabber channels for a device. ">PylonDeviceGetNumStreamGrabberChannels()</a></code> function. The <code><a class="el" href="group__pylon.html#ga07365e8eb42cbbf992511899023428a2" title="Obtain a stream grabber handle from a device. ">PylonDeviceGetStreamGrabber()</a></code> function returns a <code>PYLON_STREAMGRABBER_HANDLE</code>. Prior to retrieving a stream grabber handle, the camera device must have been opened. Please take note of the fact that the value returned from <code><a class="el" href="group__pylon.html#ga9a3ad0ce0576aaff19d7b6f3172ef5b8" title="Return the number of stream grabber channels for a device. ">PylonDeviceGetNumStreamGrabberChannels()</a></code> may be 0, as some camera devices, e.g. Camera Link cameras, have no stream grabber. These cameras can still be parameterized as described, but grabbing is not supported for them. Before use, stream grabbers must be opened by a call to <code><a class="el" href="group__pylon.html#ga46fc44105ef8adf7110d3d0fcd51aea3" title="Open a stream grabber. ">PylonStreamGrabberOpen()</a></code>. When acquiring images is finished the stream grabber must be closed by a call to <code><a class="el" href="group__pylon.html#ga01831a1617fdb98526757ed0e090f9f2" title="Close a stream grabber. ">PylonStreamGrabberClose()</a></code>.</p>
<p>A stream grabber also provides a wait object for the application to be notified whenever a buffer containing new image data becomes available.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">/* Image grabbing is done using a stream grabber.</span></div><div class="line"><span class="comment">  A device may be able to provide different streams. A separate stream grabber must</span></div><div class="line"><span class="comment">  be used for each stream. In this sample, we create a stream grabber for the default</span></div><div class="line"><span class="comment">  stream, i.e., the first stream ( index == 0 ).</span></div><div class="line"><span class="comment">  */</span></div><div class="line"></div><div class="line"><span class="comment">/* Get the number of streams supported by the device and the transport layer. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga9a3ad0ce0576aaff19d7b6f3172ef5b8">PylonDeviceGetNumStreamGrabberChannels</a>( hDev, &amp;nStreams );</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> ( nStreams &lt; 1 )</div><div class="line">{</div><div class="line">    fprintf( stderr, <span class="stringliteral">&quot;The transport layer doesn&#39;t support image streams\n&quot;</span>);</div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">    pressEnterToExit();</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Create and open a stream grabber for the first channel. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga07365e8eb42cbbf992511899023428a2">PylonDeviceGetStreamGrabber</a>( hDev, 0, &amp;hGrabber );</div><div class="line">CHECK(res);</div><div class="line">res = <a class="code" href="group__pylon.html#ga46fc44105ef8adf7110d3d0fcd51aea3">PylonStreamGrabberOpen</a>( hGrabber );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Get a handle for the stream grabber&#39;s wait object. The wait object</span></div><div class="line"><span class="comment">   allows waiting for buffers to be filled with grabbed data. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga87891dfaee855990f39551d7fcf574c8">PylonStreamGrabberGetWaitObject</a>( hGrabber, &amp;hWait );</div><div class="line">CHECK(res);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The lifetime of a stream grabber is managed by the camera owning it. There is no need (and no facility) to dispose off a <code>PYLON_STREAMGRABBER_HANDLE</code>. This also means that, if the camera object owning the stream grabber is deleted by calling <code><a class="el" href="group__pylon.html#ga52908e60392f52b4bd055c5e821c4b62" title="Delete a device object. ">PylonDestroyDevice()</a></code> on it, the related stream grabber handle will become invalid.</dd></dl>
<h3><a class="anchor" id="pylonprog_grab_configurestreamgrabber"></a>
Configuring a Stream Grabber</h3>
<p>Independent of the physical camera interface used, every stream grabber provides two mandatory parameters: </p><ul>
<li>MaxBufferSize - Maximum size in bytes of a buffer used for grabbing images </li>
<li>MaxNumBuffer - Maximum number of buffers used for grabbing images</li>
</ul>
<p>A grab application <b>must</b> set the above two parameters before grabbing begins. pylon&#160;C provides a set of convenience functions for easily accessing these parameters: <code><a class="el" href="group__pylon.html#ga95bd2bdbbda3ec1029ff221d063ed81e" title="Set the maximum number of data buffers for a stream grabber to use. ">PylonStreamGrabberSetMaxNumBuffer()</a></code>, <code><a class="el" href="group__pylon.html#ga99525a2cb731d9c165da5b1658894e18" title="Return the maximum number of data buffers a stream grabber is set to use. ">PylonStreamGrabberGetMaxNumBuffer()</a></code>, <code><a class="el" href="group__pylon.html#ga8eac300db1f6ee57bd3cb9a9ce44e1fd" title="Set the maximum data buffer size for a stream grabber. ">PylonStreamGrabberSetMaxBufferSize()</a></code>, <code><a class="el" href="group__pylon.html#gaa65c02586688f8cec2cb586f25c93eef" title="Return the maximum data buffer size for a stream grabber. ">PylonStreamGrabberGetMaxBufferSize()</a></code>.</p>
<p>The payload size is determined by the configuration of the camera object and the stream grabber object. Both objects may provide a PayloadSize parameter. The <code><a class="el" href="group__pylon.html#ga24f157b352652e4e031b748160cede56" title="Return minimum size for an image buffer. ">PylonStreamGrabberGetPayloadSize()</a></code> function returns the minimum size required for the buffer.</p>
<p>Depending on the transport technology, a stream grabber can provide further parameters such as streaming-related timeouts. All these parameters are initially set to reasonable default values, so that grabbing works without having to adjust them. An application can gain access to these parameters using the method described in <a class="el" href="programmingguide.html#advanced_genapinodemaps">Generic Parameter Access</a>.</p>
<h3><a class="anchor" id="pylonprog_grab_preparingstreamgrabber"></a>
Preparing a Stream Grabber for Grabbing</h3>
<p>Depending on the transport layer used for grabbing images, a number of system resources may be required, for example:</p>
<ul>
<li>DMA resources </li>
<li>Memory for the driver's data structures</li>
</ul>
<p>A call to <code><a class="el" href="group__pylon.html#gaa0e2988f96c56e94b39d137009b902de" title="Prepare a stream grabber for grabbing. ">PylonStreamGrabberPrepareGrab()</a></code> allocates all required resources and causes the camera object to change its state. For a typical camera, any parameters affecting resource requirements (AOI, pixel format, binning, etc.) will be read-only after the call to <code><a class="el" href="group__pylon.html#gaa0e2988f96c56e94b39d137009b902de" title="Prepare a stream grabber for grabbing. ">PylonStreamGrabberPrepareGrab()</a></code>. These parameters must be set up beforehand and cannot be changed while the camera object is in this state.</p>
<h3><a class="anchor" id="pylonprog_grab_buffer_setup"></a>
Providing Memory for Grabbing</h3>
<p>All pylon&#160;C transport layers utilize user-provided buffer memory for grabbing image and chunk data. An application is required to register the data buffers it intends to use with the stream grabber by calling <code><a class="el" href="group__pylon.html#ga9cf59896fdbc833402259b3c6be9655e" title="Attach an image data buffer to a stream grabber. ">PylonStreamGrabberRegisterBuffer()</a></code> for each data buffer. This is necessary for performance reasons, allowing the stream grabber to prepare and cache internal data structures used to deal with user-provided memory. The call to <code><a class="el" href="group__pylon.html#ga9cf59896fdbc833402259b3c6be9655e" title="Attach an image data buffer to a stream grabber. ">PylonStreamGrabberRegisterBuffer()</a></code> returns a handle for the buffer, which is used during later steps.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">/* Determine the minimum size of the grab buffer.</span></div><div class="line"><span class="comment">   The size is determined by the configuration of the camera</span></div><div class="line"><span class="comment">   and the stream grabber. Be aware that this may change</span></div><div class="line"><span class="comment">   by changing critical parameters after this call.*/</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga24f157b352652e4e031b748160cede56">PylonStreamGrabberGetPayloadSize</a>( hDev, hGrabber, &amp;payloadSize );</div><div class="line">CHECK( res );</div><div class="line"></div><div class="line"><span class="comment">/* Allocate memory for grabbing.  */</span></div><div class="line"><span class="keywordflow">for</span> ( i = 0; i &lt; NUM_BUFFERS; ++i )</div><div class="line">{</div><div class="line">    buffers[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) malloc ( payloadSize );</div><div class="line">    <span class="keywordflow">if</span> ( NULL == buffers[i] )</div><div class="line">    {</div><div class="line">        fprintf( stderr, <span class="stringliteral">&quot;Out of memory!\n&quot;</span> );</div><div class="line">        <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">        pressEnterToExit();</div><div class="line">        exit(EXIT_FAILURE);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* We must tell the stream grabber the number and size of the buffers</span></div><div class="line"><span class="comment">    we are using. */</span></div><div class="line"><span class="comment">/* .. We will not use more than NUM_BUFFERS for grabbing. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga95bd2bdbbda3ec1029ff221d063ed81e">PylonStreamGrabberSetMaxNumBuffer</a>( hGrabber, NUM_BUFFERS );</div><div class="line">CHECK(res);</div><div class="line"><span class="comment">/* .. We will not use buffers bigger than payloadSize bytes. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga8eac300db1f6ee57bd3cb9a9ce44e1fd">PylonStreamGrabberSetMaxBufferSize</a>( hGrabber, payloadSize );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*  Allocate the resources required for grabbing. After this, critical parameters</span></div><div class="line"><span class="comment">    that impact the payload size must not be changed until FinishGrab() is called. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaa0e2988f96c56e94b39d137009b902de">PylonStreamGrabberPrepareGrab</a>( hGrabber );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* Before using the buffers for grabbing, they must be registered at</span></div><div class="line"><span class="comment">   the stream grabber. For each registered buffer, a buffer handle</span></div><div class="line"><span class="comment">   is returned. After registering, these handles are used instead of the</span></div><div class="line"><span class="comment">   raw pointers. */</span></div><div class="line"><span class="keywordflow">for</span> ( i = 0; i &lt; NUM_BUFFERS; ++i )</div><div class="line">{</div><div class="line">    res = <a class="code" href="group__pylon.html#ga9cf59896fdbc833402259b3c6be9655e">PylonStreamGrabberRegisterBuffer</a>( hGrabber, buffers[i], payloadSize,  &amp;bufHandles[i] );</div><div class="line">    CHECK(res);</div><div class="line">}</div></div><!-- fragment --><p>The buffer registration mechanism transfers ownership of the buffers to the stream grabber. An application must never deallocate the memory belonging to buffers that are still registered. Freeing the memory is not allowed unless the buffers are deregistered by calling <code><a class="el" href="group__pylon.html#gaa98d52b7c02efc120a7a36b45282b3b0" title="Detach an image data buffer from a stream grabber. ">PylonStreamGrabberDeregisterBuffer()</a></code> first.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> ( i = 0; i &lt; NUM_BUFFERS; ++i )</div><div class="line">{</div><div class="line">    res = <a class="code" href="group__pylon.html#gaa98d52b7c02efc120a7a36b45282b3b0">PylonStreamGrabberDeregisterBuffer</a>( hGrabber, bufHandles[i] );</div><div class="line">    CHECK(res);</div><div class="line">    free( buffers[i] );</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_grab_feedinginputqueue"></a>
Feeding the Stream Grabber's Input Queue</h3>
<p>Every stream grabber maintains two different buffer queues, an <em>input queue</em> and an <em>output queue</em>. The buffers to be used for grabbing must be fed to the grabber's input queue. After grabbing, buffers containing image data can be retrieved from the grabber's output queue.</p>
<p>The <code><a class="el" href="group__pylon.html#gaf60db059b9fb6185ebafb858ba22b87b" title="Submit a data buffer to a stream grabber. ">PylonStreamGrabberQueueBuffer()</a></code> function is used to append a buffer to the end of the grabber's input queue. It takes two parameters, a buffer handle and an optional pointer to application-specific context information. Along with the data buffer, the context pointer is passed back to the user when retrieving the buffer from the grabber's output queue. The stream grabber does not access the memory to which the context pointer points in any way.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">/* Feed the buffers into the stream grabber&#39;s input queue. For each buffer, the API</span></div><div class="line"><span class="comment">   allows passing in a pointer to additional context information. This pointer</span></div><div class="line"><span class="comment">   will be returned unchanged when the grab is finished. In our example, we use the index of the</span></div><div class="line"><span class="comment">   buffer as context information. */</span></div><div class="line"><span class="keywordflow">for</span> ( i = 0; i &lt; NUM_BUFFERS; ++i )</div><div class="line">{</div><div class="line">    res = <a class="code" href="group__pylon.html#gaf60db059b9fb6185ebafb858ba22b87b">PylonStreamGrabberQueueBuffer</a>( hGrabber, bufHandles[i], (<span class="keywordtype">void</span>*) i );</div><div class="line">    CHECK(res);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Queuing buffers to a stream grabber's input queue does not start image acquisition. For this to happen, the camera must be programmed as described in <a class="el" href="programmingguide.html#pylonprog_grab_startstop">Starting and Stopping Image Acquisition</a>.</dd></dl>
<p>After buffers have been queued, the stream grabber is ready to grab image data into them, but acquisition must be started explicitly.</p>
<h3><a class="anchor" id="pylonprog_grab_startstop"></a>
Starting and Stopping Image Acquisition</h3>
<p>To start image acquisition, use the camera's <code>AcquisitionStart</code> parameter. <code>AcquisitionStart</code> is a command parameter, which means that calling <a class="el" href="group__pylon.html#ga6dde7a627bdcc2405151c822fd2a9bb1" title="Execute a command. ">PylonDeviceExecuteCommandFeature()</a> for the <code>AcquisitionStart</code> parameter sends an 'acquisition start' command to the camera.</p>
<p>A camera device typically provides two acquisition modes: </p><ul>
<li><em>Single Frame mode</em> where the camera acquires one image and then stops. </li>
<li><em>Continuous mode</em> where the camera continuously acquires and transfers images until acquisition is stopped explicitly.</li>
</ul>
<p>To be precise, the acquisition start command does not necessarily start acquisition in the camera immediately. If either external triggering or software triggering is enabled, the acquisition start command prepares the camera for image acquisition. Actual acquisition starts when the camera senses an external trigger signal or receives a software trigger command.</p>
<p>When the camera's continuous acquisition mode is enabled, the <code>AcquisitionStop</code> parameter must be used to stop image acquisition.</p>
<p>Normally, a camera starts to transfer image data as soon as possible after acquisition. There is no specific command to start the image transfer.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">/* Start the image acquisition engine. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gad3f7e833b396daf05e44c54f3b951f84">PylonStreamGrabberStartStreamingIfMandatory</a>(hGrabber);</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Let the camera acquire images. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga6dde7a627bdcc2405151c822fd2a9bb1">PylonDeviceExecuteCommandFeature</a>( hDev, <span class="stringliteral">&quot;AcquisitionStart&quot;</span>);</div><div class="line">CHECK(res);</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_grab_get_data"></a>
Retrieving Grabbed Images</h3>
<p>Image data is written to the buffer(s) in the stream grabber's input queue. When a buffer is filled with data, the stream grabber places it on its output queue, from which it can then be retrieved by the user application.</p>
<p>There is a wait object associated with every stream grabber's output queue. This wait object allows the application to wait until either a grabbed image arrives at the output queue or a timeout expires.</p>
<p>When the wait operation returns successfully, the grabbed buffer can be retrieved using the <code><a class="el" href="group__pylon.html#ga09611f06841721829628143f91beef96" title="Retrieve buffer after processing by stream grabber. ">PylonStreamGrabberRetrieveResult()</a></code> function. It uses a <code><a class="el" href="struct_pylon_grab_result__t.html" title="Result data struct for PylonStreamGrabberRetrieveResult(). This data describes grab results (typicall...">PylonGrabResult_t</a></code> struct to return information about the grab operation:</p>
<ul>
<li>Status of the grab (succeeded, canceled, failed) </li>
<li>The buffer's handle </li>
<li>The pointer to the buffer </li>
<li>The user-provided context pointer</li>
<li>AOI and image format </li>
<li>Error number and error description if the grab failed</li>
</ul>
<p>This also removes the buffer from the output queue. Ownership of the buffer is returned to the application. A buffer retrieved from the output queue will not be overwritten with new image data until it is placed on the grabber's input queue again.</p>
<p>Remember, a buffer retrieved from the output queue must be deregistered before its memory can be freed.</p>
<p>Use the buffer handle from the <code><a class="el" href="struct_pylon_grab_result__t.html" title="Result data struct for PylonStreamGrabberRetrieveResult(). This data describes grab results (typicall...">PylonGrabResult_t</a></code> struct to requeue a buffer to the grabber's input queue.</p>
<p>When the camera ceases to send data, all not yet processed buffers remain in the input queue until the <code><a class="el" href="group__pylon.html#gaa571171cb0805c4d0490caa1413553ae" title="Cancels grabbing the current buffer and flushes all buffers to the output queue. ">PylonStreamGrabberFlushBuffersToOutput()</a></code> function is called. <code><a class="el" href="group__pylon.html#gaa571171cb0805c4d0490caa1413553ae" title="Cancels grabbing the current buffer and flushes all buffers to the output queue. ">PylonStreamGrabberFlushBuffersToOutput()</a></code> puts all buffers from the input queue to the output queue, including any buffer currently being filled. Checking the status of the <code><a class="el" href="struct_pylon_grab_result__t.html" title="Result data struct for PylonStreamGrabberRetrieveResult(). This data describes grab results (typicall...">PylonGrabResult_t</a></code> struct returned by <code><a class="el" href="group__pylon.html#ga09611f06841721829628143f91beef96" title="Retrieve buffer after processing by stream grabber. ">PylonStreamGrabberRetrieveResult()</a></code>, allows to determine whether a buffer has been canceled.</p>
<p>The following example shows a typical grab loop:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Grab NUM_GRABS images */</span></div><div class="line">    nGrabs = 0;                         <span class="comment">/* Counts the number of images grabbed */</span></div><div class="line">    <span class="keywordflow">while</span> ( nGrabs &lt; NUM_GRABS )</div><div class="line">    {</div><div class="line">        <span class="keywordtype">size_t</span> bufferIndex;              <span class="comment">/* Index of the buffer */</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> min, max;</div><div class="line">        <span class="comment">/* Wait for the next buffer to be filled. Wait up to 1000 ms. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#ga3b7ab1f6e2b1f71418a99fb05418a7c8">PylonWaitObjectWait</a>( hWait, 1000, &amp;isReady );</div><div class="line">        CHECK(res);</div><div class="line">        <span class="keywordflow">if</span> ( ! isReady )</div><div class="line">        {</div><div class="line">            <span class="comment">/* Timeout occurred. */</span></div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Grab timeout occurred\n&quot;</span>);</div><div class="line">            <span class="keywordflow">break</span>; <span class="comment">/* Stop grabbing. */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Since the wait operation was successful, the result of at least one grab</span></div><div class="line"><span class="comment">           operation is available. Retrieve it. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#ga09611f06841721829628143f91beef96">PylonStreamGrabberRetrieveResult</a>( hGrabber, &amp;grabResult, &amp;isReady );</div><div class="line">        CHECK(res);</div><div class="line">        <span class="keywordflow">if</span> ( ! isReady )</div><div class="line">        {</div><div class="line">            <span class="comment">/* Oops. No grab result available? We should never have reached this point.</span></div><div class="line"><span class="comment">               Since the wait operation above returned without a timeout, a grab result</span></div><div class="line"><span class="comment">               should be available. */</span></div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Failed to retrieve a grab result\n&quot;</span>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        nGrabs++;</div><div class="line"></div><div class="line">        <span class="comment">/* Get the buffer index from the context information. */</span></div><div class="line">        bufferIndex = (size_t) grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3fa626bc45486a5b8561cbdfd3847ae4">Context</a>;</div><div class="line"></div><div class="line">        <span class="comment">/* Check to see if the image was grabbed successfully. */</span></div><div class="line">        if ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3217646a22faa23c898dfdc892ca3aca">Status</a> == <a class="code" href="group__pylon.html#gga7ef7a5f4d132577498ce7206274046fea354b91f0a367f3779da75499a612147a">Grabbed</a> )</div><div class="line">        {</div><div class="line">            <span class="comment">/*  Success. Perform image processing. Since we passed more than one buffer</span></div><div class="line"><span class="comment">            to the stream grabber, the remaining buffers are filled while</span></div><div class="line"><span class="comment">            we do the image processing. The processed buffer won&#39;t be touched by</span></div><div class="line"><span class="comment">            the stream grabber until we pass it back to the stream grabber. */</span></div><div class="line"></div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer;        <span class="comment">/* Pointer to the buffer attached to the grab result. */</span></div><div class="line"></div><div class="line">            <span class="comment">/* Get the buffer pointer from the result structure. Since we also got the buffer index,</span></div><div class="line"><span class="comment">               we could alternatively use buffers[bufferIndex]. */</span></div><div class="line">            buffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) grabResult.<a class="code" href="struct_pylon_grab_result__t.html#aa24d463aa40da5523491da53b48eeaf1">pBuffer</a>;</div><div class="line"></div><div class="line">            <span class="comment">/* Perform processing. */</span></div><div class="line">            getMinMax( buffer, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a5de217563769a2fecc939a8803c0de49">SizeX</a>, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#ac53ad1519fff771ec8810fb5ffea222d">SizeY</a>, &amp;min, &amp;max );</div><div class="line">            printf(<span class="stringliteral">&quot;Grabbed frame %2d into buffer %2d. Min. gray value = %3u, Max. gray value = %3u\n&quot;</span>,</div><div class="line">                nGrabs, (<span class="keywordtype">int</span>) bufferIndex, min, max);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef GENAPIC_WIN_BUILD</span></div><div class="line">            <span class="comment">/* Display image */</span></div><div class="line">            res = PylonImageWindowDisplayImageGrabResult(0, &amp;grabResult);</div><div class="line">            CHECK(res);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3217646a22faa23c898dfdc892ca3aca">Status</a> == <a class="code" href="group__pylon.html#gga7ef7a5f4d132577498ce7206274046fea1f506c828f4945d6b5a7bf71445f7d54">Failed</a> )</div><div class="line">        {</div><div class="line">            fprintf( stderr,  <span class="stringliteral">&quot;Frame %d wasn&#39;t grabbed successfully.  Error code = 0x%08X\n&quot;</span>,</div><div class="line">                nGrabs, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a597c9f0ddc8e7a63df7e108441e9bd78">ErrorCode</a> );</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Once finished with the processing, requeue the buffer to be filled again. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#gaf60db059b9fb6185ebafb858ba22b87b">PylonStreamGrabberQueueBuffer</a>( hGrabber, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a0dc087840e7dda694c92e8a54ac56838">hBuffer</a>, (<span class="keywordtype">void</span>*) bufferIndex );</div><div class="line">        CHECK(res);</div><div class="line">    }</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_grab_finish"></a>
Finish Grabbing</h3>
<p>If the camera is set for continuous acquisition mode, acquisition should first be stopped: </p><div class="fragment"><div class="line"><span class="comment">/*  ... Stop the camera. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga6dde7a627bdcc2405151c822fd2a9bb1">PylonDeviceExecuteCommandFeature</a>( hDev, <span class="stringliteral">&quot;AcquisitionStop&quot;</span>);</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* ... Stop the image acquisition engine. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga7a2d429ce4f61d445f534305efcb3298">PylonStreamGrabberStopStreamingIfMandatory</a>(hGrabber);</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>After stopping the camera you must ensure that all buffers waiting in the input queue will be moved to the output queue. You do this by calling the <code><a class="el" href="group__pylon.html#gaa571171cb0805c4d0490caa1413553ae" title="Cancels grabbing the current buffer and flushes all buffers to the output queue. ">PylonStreamGrabberFlushBuffersToOutput()</a></code> function. This will move all pending buffers from the input queue to the output queue and mark them as canceled.</p>
<p>An application should retrieve all buffers from the grabber's output queue before closing a stream grabber. Prior to deallocating their memory, deregister the buffers. After all buffers have been deregistered, call the <code><a class="el" href="group__pylon.html#gab84d13dc2435c44750259a4bb185319a" title="Shut down a stream grabber. ">PylonStreamGrabberFinishGrab()</a></code> function to release all resources allocated for grabbing. <code><a class="el" href="group__pylon.html#gab84d13dc2435c44750259a4bb185319a" title="Shut down a stream grabber. ">PylonStreamGrabberFinishGrab()</a></code> must not be called when there are still buffers in the grabber's input queue.</p>
<p>The last step is to close the stream grabber by calling <code><a class="el" href="group__pylon.html#ga01831a1617fdb98526757ed0e090f9f2" title="Close a stream grabber. ">PylonStreamGrabberClose()</a></code>.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">/* ... We must issue a flush call to ensure that all pending buffers are put into the</span></div><div class="line"><span class="comment">   stream grabber&#39;s output queue. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaa571171cb0805c4d0490caa1413553ae">PylonStreamGrabberFlushBuffersToOutput</a>( hGrabber );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* ... The buffers can now be retrieved from the stream grabber. */</span></div><div class="line"><span class="keywordflow">do</span></div><div class="line">{</div><div class="line">    res = <a class="code" href="group__pylon.html#ga09611f06841721829628143f91beef96">PylonStreamGrabberRetrieveResult</a>( hGrabber, &amp;grabResult, &amp;isReady );</div><div class="line">    CHECK(res);</div><div class="line">} <span class="keywordflow">while</span> ( isReady );</div><div class="line"></div><div class="line"><span class="comment">/* ... When all buffers have been retrieved from the stream grabber, they can be deregistered.</span></div><div class="line"><span class="comment">       After that, it is safe to free the memory. */</span></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( i = 0; i &lt; NUM_BUFFERS; ++i )</div><div class="line">{</div><div class="line">    res = <a class="code" href="group__pylon.html#gaa98d52b7c02efc120a7a36b45282b3b0">PylonStreamGrabberDeregisterBuffer</a>( hGrabber, bufHandles[i] );</div><div class="line">    CHECK(res);</div><div class="line">    free( buffers[i] );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* ... Release grabbing related resources. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gab84d13dc2435c44750259a4bb185319a">PylonStreamGrabberFinishGrab</a>( hGrabber );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* After calling PylonStreamGrabberFinishGrab(), parameters that impact the payload size (e.g.,</span></div><div class="line"><span class="comment">the AOI width and height parameters) are unlocked and can be modified again. */</span></div><div class="line"></div><div class="line"><span class="comment">/* ... Close the stream grabber. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga01831a1617fdb98526757ed0e090f9f2">PylonStreamGrabberClose</a>( hGrabber );</div><div class="line">CHECK(res);</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_grab_completesample"></a>
Sample Program</h3>
<p>A complete sample program for acquiring images with a GigE camera in continuous mode can be found here: <a class="el" href="samples.html#samples_overlappedgrab">OverlappedGrab Sample</a>. The sample program is included in the installation archive in Samples/C/OverlappedGrab.</p>
<h2><a class="anchor" id="pylonprog_waitobjects"></a>
Using Wait Objects</h2>
<p>Using the <code><a class="el" href="group__pylon.html#ga3b7ab1f6e2b1f71418a99fb05418a7c8" title="Wait on a wait object. ">PylonWaitObjectWait()</a></code> and <code><a class="el" href="group__pylon.html#ga604b2b67256d38b1b5b8a0916191c8f5" title="Extended wait on a wait object. ">PylonWaitObjectWaitEx()</a></code> functions, an application can wait for a single wait object to became signaled. This has already been demonstrated as part of the grab loop example presented in <a class="el" href="programmingguide.html#pylonprog_grab_get_data">Retrieving Grabbed Images</a>. However, it is much more common for an application to wait for events from multiple sources. For this purpose, pylon&#160;C defines a <em>wait object container</em>, represented by a <code>PYLON_WAITOBJECTS_HANDLE</code> handle. Wait objects can be added to a container by calling <code><a class="el" href="group__pylon.html#gaa4047a9ffc958de25a824ebf5931a21c" title="Add a single wait object to a wait object set. ">PylonWaitObjectsAdd()</a>or</code> <code><a class="el" href="group__pylon.html#ga0f780d671614a6866865d881b1e6bb38" title="Add multiple wait objects to a wait object set. ">PylonWaitObjectsAddMany()</a></code>. Once the wait objects are added to a container, an application can wait for the wait objects to become signaled:</p>
<ul>
<li><code><a class="el" href="group__pylon.html#ga3650b45e8e45fd56f9775abb485f4e4a" title="Wait for any one object in a wait object set to become signaled. ">PylonWaitObjectsWaitForAny()</a></code> and <code><a class="el" href="group__pylon.html#ga7bed3ced9ef2d03fb9b84b857b04822b" title="Wait for any one object in a wait object set to become signaled. ">PylonWaitObjectsWaitForAnyEx()</a></code> block until any single wait object in a container is signaled, while </li>
<li><code><a class="el" href="group__pylon.html#ga18fe570b830f0a6c3496819ab3299688" title="Wait for all objects in a wait object set to become signaled. ">PylonWaitObjectsWaitForAll()</a></code> and <code><a class="el" href="group__pylon.html#ga98272263637a30b4db6315a544dd7cfa" title="Wait for all objects in a wait object set to become signaled. ">PylonWaitObjectsWaitForAllEx()</a></code> block until all objects in the container are signaled.</li>
</ul>
<h3><a class="anchor" id="pylonprog_waitobjects_example"></a>
Sample Program</h3>
<p>The following code snippets illustrate how a grab thread uses the <code><a class="el" href="group__pylon.html#ga3650b45e8e45fd56f9775abb485f4e4a" title="Wait for any one object in a wait object set to become signaled. ">PylonWaitObjectsWaitForAny()</a></code> function to simultaneously wait for buffers and a termination request. The snippets are taken from the <em>GrabTwoCameras</em> sample program installed as part of the pylon&#160;C SDK.</p>
<p>The program grabs images for 5 seconds and then exits. First, the program creates a wait object container to hold all its wait objects. It then creates a system-dependent timer, which is transformed into a pylon&#160;C wait object. The wait object is then added to the container.</p>
<div class="fragment"><div class="line"><span class="comment">/* Create wait objects (must be done outside of the loop). */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga353472a82bfd5779376c28d32844227a">PylonWaitObjectsCreate</a>(&amp;wos);</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* In this sample, we want to grab for a given amount of time, then stop. */</span></div><div class="line"><span class="comment">/* Create a Linux timer, wrap it in a pylon C wait object, and add it to</span></div><div class="line"><span class="comment">   the wait object set. */</span></div><div class="line">fdTimer = timerfd_create(CLOCK_MONOTONIC, 0);</div><div class="line"><span class="keywordflow">if</span> (fdTimer == -1)</div><div class="line">{</div><div class="line">    fprintf( stderr, <span class="stringliteral">&quot;timerfd_create() failed. %s\n&quot;</span>, strerror(errno) );</div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">    pressEnterToExit();</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">}</div><div class="line">res = <a class="code" href="group__pylon.html#ga4be0658786cb3f515b1da2c19603f6a1">PylonWaitObjectFromFd</a>(fdTimer, &amp;woTimer);</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line">res = <a class="code" href="group__pylon.html#gaa4047a9ffc958de25a824ebf5931a21c">PylonWaitObjectsAdd</a>(wos, woTimer, NULL);</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>In this code snippet, multiple cameras are used for simultaneous grabbing. Every one of these cameras has a stream grabber, which in turn has a wait object. All these wait objects are added to the container, too. This is achieved by executing the following statements in a loop, once for every camera:</p>
<div class="fragment"><div class="line"><span class="comment">/* Get a handle for the stream grabber&#39;s wait object. The wait object</span></div><div class="line"><span class="comment">   allows waiting for buffers to be filled with grabbed data. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga87891dfaee855990f39551d7fcf574c8">PylonStreamGrabberGetWaitObject</a>( hGrabber[deviceIndex], &amp;hWait );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Add the stream grabber&#39;s wait object to our wait objects.</span></div><div class="line"><span class="comment">   This is needed to be able to wait until at least one camera has</span></div><div class="line"><span class="comment">   grabbed an image in the grab loop below. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaa4047a9ffc958de25a824ebf5931a21c">PylonWaitObjectsAdd</a>(wos, hWait, NULL);</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>At the beginning of the grab loop, <code><a class="el" href="group__pylon.html#ga3650b45e8e45fd56f9775abb485f4e4a" title="Wait for any one object in a wait object set to become signaled. ">PylonWaitObjectsWaitForAny()</a></code> is called. The index value returned is used to determine whether a buffer has been grabbed or the timer has expired. This means that the program should stop grabbing and exit:</p>
<div class="fragment"><div class="line">        <span class="comment">/* Grab until the timer expires. */</span></div><div class="line">        <span class="keywordflow">for</span> (;;)</div><div class="line">        {</div><div class="line">            _Bool isReady;</div><div class="line">            <span class="keywordtype">size_t</span> woidx;</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> min, max;</div><div class="line">            <a class="code" href="struct_pylon_grab_result__t.html">PylonGrabResult_t</a> grabResult;</div><div class="line"></div><div class="line">            <span class="comment">/* Wait for the next buffer to be filled. Wait up to 1000 ms. */</span></div><div class="line">            res = <a class="code" href="group__pylon.html#ga3650b45e8e45fd56f9775abb485f4e4a">PylonWaitObjectsWaitForAny</a>(wos, 1000, &amp;woidx, &amp;isReady );</div><div class="line">            CHECK(res);</div><div class="line">            <span class="keywordflow">if</span> ( !isReady )</div><div class="line">            {</div><div class="line">                <span class="comment">/* Timeout occurred. */</span></div><div class="line">                fputs(<span class="stringliteral">&quot;Grab timeout occurred.\n&quot;</span>, stderr);</div><div class="line">                <span class="keywordflow">break</span>; <span class="comment">/* Stop grabbing. */</span></div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* If the timer has expired, exit the grab loop */</span></div><div class="line">            <span class="keywordflow">if</span> (woidx == 0) {</div><div class="line">                fputs(<span class="stringliteral">&quot;Grabbing completed successfully.\n&quot;</span>, stderr);</div><div class="line">                <span class="keywordflow">break</span>;  <span class="comment">/* timer expired */</span></div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* Account for the timer. */</span></div><div class="line">            --woidx;</div><div class="line"></div><div class="line">            <span class="comment">/* Retrieve the grab result. */</span></div><div class="line">            res = <a class="code" href="group__pylon.html#ga09611f06841721829628143f91beef96">PylonStreamGrabberRetrieveResult</a>( hGrabber[woidx], &amp;grabResult, &amp;isReady );</div><div class="line">            CHECK(res);</div><div class="line">            <span class="keywordflow">if</span> ( !isReady )</div><div class="line">            {</div><div class="line">                <span class="comment">/* Oops. No grab result available? We should never have reached this point.</span></div><div class="line"><span class="comment">                   Since the wait operation above returned without a timeout, a grab result</span></div><div class="line"><span class="comment">                   should be available. */</span></div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Failed to retrieve a grab result\n&quot;</span>);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* Check to see if the image was grabbed successfully. */</span></div><div class="line">            <span class="keywordflow">if</span> ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3217646a22faa23c898dfdc892ca3aca">Status</a> == <a class="code" href="group__pylon.html#gga7ef7a5f4d132577498ce7206274046fea354b91f0a367f3779da75499a612147a">Grabbed</a> )</div><div class="line">            {</div><div class="line">                <span class="comment">/* Success. Perform image processing. Since we passed more than one buffer</span></div><div class="line"><span class="comment">                   to the stream grabber, the remaining buffers are filled while</span></div><div class="line"><span class="comment">                   we do the image processing. The processed buffer won&#39;t be touched by</span></div><div class="line"><span class="comment">                   the stream grabber until we pass it back to the stream grabber. */</span></div><div class="line"></div><div class="line">                <span class="comment">/* Pointer to the buffer attached to the grab result</span></div><div class="line"><span class="comment">                   Get the buffer pointer from the result structure. Since we also got the buffer index,</span></div><div class="line"><span class="comment">                   we could alternatively use buffers[bufferIndex]. */</span></div><div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) grabResult.<a class="code" href="struct_pylon_grab_result__t.html#aa24d463aa40da5523491da53b48eeaf1">pBuffer</a>;</div><div class="line"></div><div class="line">                <span class="comment">/* Perform processing. */</span></div><div class="line">                getMinMax( buffer, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a5de217563769a2fecc939a8803c0de49">SizeX</a>, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#ac53ad1519fff771ec8810fb5ffea222d">SizeY</a>, &amp;min, &amp;max );</div><div class="line">                printf(<span class="stringliteral">&quot;Grabbed frame #%2u from camera %2u into buffer %2p. Min. val=%3u, Max. val=%3u\n&quot;</span>,</div><div class="line">                       nGrabs, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) woidx, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3fa626bc45486a5b8561cbdfd3847ae4">Context</a>, min, max);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef GENAPIC_WIN_BUILD</span></div><div class="line">                <span class="comment">/* Display image */</span></div><div class="line">                res = PylonImageWindowDisplayImageGrabResult(woidx, &amp;grabResult);</div><div class="line">                CHECK(res);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3217646a22faa23c898dfdc892ca3aca">Status</a> == <a class="code" href="group__pylon.html#gga7ef7a5f4d132577498ce7206274046fea1f506c828f4945d6b5a7bf71445f7d54">Failed</a> )</div><div class="line">            {</div><div class="line">                fprintf( stderr,  <span class="stringliteral">&quot;Frame %u wasn&#39;t grabbed successfully.  Error code = 0x%08X\n&quot;</span>,</div><div class="line">                    nGrabs, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a597c9f0ddc8e7a63df7e108441e9bd78">ErrorCode</a> );</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* Once finished with the processing, requeue the buffer to be filled again. */</span></div><div class="line">            res = <a class="code" href="group__pylon.html#gaf60db059b9fb6185ebafb858ba22b87b">PylonStreamGrabberQueueBuffer</a>( hGrabber[woidx], grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a0dc087840e7dda694c92e8a54ac56838">hBuffer</a>, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3fa626bc45486a5b8561cbdfd3847ae4">Context</a> );</div><div class="line">            CHECK(res);</div><div class="line"></div><div class="line">            nGrabs++;</div><div class="line">        }</div></div><!-- fragment --><p>Finally, during cleanup the timer wait object is destroyed. This frees the timer handle included within it.</p>
<div class="fragment"><div class="line"><span class="comment">/* Remove all wait objects from waitobjects. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga47b8cc6b77fc52d35772d8a1bbc218b2">PylonWaitObjectsRemoveAll</a>(wos);</div><div class="line">CHECK(res);</div><div class="line">res = <a class="code" href="group__pylon.html#ga9d6f7c001d51813d528da4ffa0c12d13">PylonWaitObjectDestroy</a>(woTimer);</div><div class="line">CHECK(res);</div><div class="line">res = <a class="code" href="group__pylon.html#gacc38d5a8d53dc1b3bd4764727d31e6f1">PylonWaitObjectsDestroy</a>(wos);</div><div class="line">CHECK(res);</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_waitobjects_interruptible"></a>
Interruptible Wait Operation</h3>
<p>The <code><a class="el" href="group__pylon.html#ga7bed3ced9ef2d03fb9b84b857b04822b" title="Wait for any one object in a wait object set to become signaled. ">PylonWaitObjectsWaitForAnyEx()</a></code> and <code><a class="el" href="group__pylon.html#ga98272263637a30b4db6315a544dd7cfa" title="Wait for all objects in a wait object set to become signaled. ">PylonWaitObjectsWaitForAllEx()</a></code> functions, as well as <a class="el" href="group__pylon.html#ga604b2b67256d38b1b5b8a0916191c8f5" title="Extended wait on a wait object. ">PylonWaitObjectWaitEx()</a>, take an additional boolean argument <em>Alertable</em>, that allows the caller to specify whether the wait operation should be interruptible or not. An interruptible wait is terminated prematurely whenever a certain asynchronous system event (a user APC on Windows, or a signal on Unix) happens. This rarely-needed feature has special uses that are beyond the scope of this document.</p>
<h2><a class="anchor" id="pylonprog_event"></a>
Handling Camera Events</h2>
<p>Basler GigE Vision and USB3 Vision cameras used with Basler pylon software can send event messages. For example, when a sensor exposure has finished, the camera can send an end-of-exposure event to the computer. The event can be received by the computer before the image data for the finished exposure has been completely transferred. Retrieval and processing of event messages is described in this section.</p>
<h3><a class="anchor" id="pylonprog_event_grabber"></a>
Event Grabbers</h3>
<p>Receiving event data sent by a camera is accomplished in much the same way as receiving image data. While the latter involves use of a stream grabber, an <em>event grabber</em> is used for obtaining events.</p>
<h3><a class="anchor" id="pylonprog_event_grabber_get"></a>
Getting and Preparing Event Grabbers</h3>
<p>Event grabbers can be obtained by <code><a class="el" href="group__pylon.html#gad3969200f1e526b69c2e84c4dcd71e7f" title="Obtain an event grabber handle from a device. ">PylonDeviceGetEventGrabber()</a></code>.</p>
<div class="fragment"><div class="line"><span class="comment">/* Create and prepare an event grabber. */</span></div><div class="line"><span class="comment">/* ... Get a handle for the event grabber. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gad3969200f1e526b69c2e84c4dcd71e7f">PylonDeviceGetEventGrabber</a>( hDev, &amp;hEventGrabber );</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> ( hEventGrabber == PYLONC_INVALID_HANDLE )</div><div class="line">{</div><div class="line">    <span class="comment">/* The transport layer doesn&#39;t support event grabbers. */</span></div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;No event grabber supported.\n&quot;</span>);</div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">    pressEnterToExit();</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">}</div></div><!-- fragment --><p>The camera object owns event grabbers created this way and manages their lifetime.</p>
<p>Unlike stream grabbers, event grabbers use internal memory buffers for receiving event messages. The number of buffers can be parameterized through the <a class="el" href="group__pylon.html#gaca16fe8c54dc4fbebee0932b42869e42" title="Set the number of event buffers used by an event grabber. ">PylonEventGrabberSetNumBuffers()</a> function:</p>
<div class="fragment"><div class="line"><span class="comment">/* ... Tell the grabber how many buffers to use. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaca16fe8c54dc4fbebee0932b42869e42">PylonEventGrabberSetNumBuffers</a>( hEventGrabber, NUM_EVENT_BUFFERS );</div><div class="line">CHECK(res);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The number of buffers must be set before calling <code><a class="el" href="group__pylon.html#ga7834df8107cf7116c9b46db04f9953e7" title="Open an event grabber. ">PylonEventGrabberOpen()</a></code>.</dd></dl>
<p>A connection to the device and all resources required for receiving events are allocated by calling <code><a class="el" href="group__pylon.html#ga7834df8107cf7116c9b46db04f9953e7" title="Open an event grabber. ">PylonEventGrabberOpen()</a></code>. After that, a wait object handle can be obtained for the application to be notified of any occurring events.</p>
<div class="fragment"><div class="line"><span class="comment">/* ... Open the event grabber. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga7834df8107cf7116c9b46db04f9953e7">PylonEventGrabberOpen</a>( hEventGrabber );  <span class="comment">/* The event grabber is now ready</span></div><div class="line"><span class="comment">                                               for receiving events. */</span></div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Retrieve the wait object that is associated with the event grabber. The event</span></div><div class="line"><span class="comment">will be signaled when an event message has been received. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga6bc0e00806922b1053e4ce428173dcd4">PylonEventGrabberGetWaitObject</a>( hEventGrabber, &amp;hWaitEvent );</div><div class="line">CHECK(res);</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_event_enable"></a>
Enabling Events</h3>
<p>Sending of event messages must be explicitly enabled on the camera by setting its <code>EventSelector</code> parameter to the type of the desired event. In the following example the selector is set to the end-of-exposure event. After this, sending events of the desired type is enabled through the <code>EventNotification</code> parameter:</p>
<div class="fragment"><div class="line"><span class="comment">/* Enable camera event reporting. */</span></div><div class="line"><span class="comment">/* Select the end-of-exposure event reporting. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;EventSelector&quot;</span>, <span class="stringliteral">&quot;ExposureEnd&quot;</span> );</div><div class="line">CHECK(res);</div><div class="line"><span class="comment">/* Enable the event reporting.</span></div><div class="line"><span class="comment">Select the enumeration entry name depending on the SFNC version used by the camera device.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordflow">if</span> ( sfncVersionMajor &gt;= 2 )</div><div class="line">    res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;EventNotification&quot;</span>, <span class="stringliteral">&quot;On&quot;</span> );</div><div class="line"><span class="keywordflow">else</span></div><div class="line">    res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;EventNotification&quot;</span>, <span class="stringliteral">&quot;GenICamEvent&quot;</span> );</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>To be sure that no events are missed, the event grabber should be prepared before event messages are enabled (see the <a class="el" href="programmingguide.html#pylonprog_event_grabber_get">Getting and Preparing Event Grabbers</a> section above).</p>
<p>The following code snippet illustrates how to disable the sending of end-of-exposure events:</p>
<div class="fragment"><div class="line"><span class="comment">/* ... Switch-off the events. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;EventSelector&quot;</span>, <span class="stringliteral">&quot;ExposureEnd&quot;</span> );</div><div class="line">CHECK(res);</div><div class="line">res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;EventNotification&quot;</span>, <span class="stringliteral">&quot;Off&quot;</span> );</div><div class="line">CHECK(res);</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_event_receive"></a>
Receiving Event Messages</h3>
<p>Receiving event messages is very similar to grabbing images. The event grabber provides a wait object that is signaled whenever an event message becomes available. When an event message is available, it can be retrieved by calling <code><a class="el" href="group__pylon.html#ga38f586fc7aa2e9cda46a6050fd235326" title="Retrieve an event from an event grabber. ">PylonEventGrabberRetrieveEvent()</a></code>.</p>
<p>In typical applications, waiting for grabbed images and event messages is done in one common loop. This is demonstrated in the following code snippet:</p>
<div class="fragment"><div class="line"><span class="comment">/* Put the wait objects into a container. */</span></div><div class="line"><span class="comment">/* ... Create the container. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga353472a82bfd5779376c28d32844227a">PylonWaitObjectsCreate</a>( &amp;hWaitObjects );</div><div class="line">CHECK(res);</div><div class="line"><span class="comment">/* ... Add the wait objects&#39; handles. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga0f780d671614a6866865d881b1e6bb38">PylonWaitObjectsAddMany</a>( hWaitObjects, 2, hWaitEvent, hWaitStream);</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Start the image acquisition engine. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gad3f7e833b396daf05e44c54f3b951f84">PylonStreamGrabberStartStreamingIfMandatory</a>(hStreamGrabber);</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Let the camera acquire images. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga6dde7a627bdcc2405151c822fd2a9bb1">PylonDeviceExecuteCommandFeature</a>( hDev, <span class="stringliteral">&quot;AcquisitionStart&quot;</span>);</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Grab NUM_GRABS images. */</span></div><div class="line">nGrabs = 0;                         <span class="comment">/* Counts the number of images grabbed. */</span></div><div class="line"><span class="keywordflow">while</span> ( nGrabs &lt; NUM_GRABS )</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span> bufferIndex;              <span class="comment">/* Index of the buffer. */</span></div><div class="line">    <span class="keywordtype">size_t</span> waitObjectIndex;          <span class="comment">/* Index of the wait object that is signalled.*/</span></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> min, max;</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for either an image buffer grabbed or an event received. Wait up to 1000 ms. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#ga3650b45e8e45fd56f9775abb485f4e4a">PylonWaitObjectsWaitForAny</a>( hWaitObjects, 1000, &amp;waitObjectIndex, &amp;isReady );</div><div class="line">    CHECK(res);</div><div class="line">    <span class="keywordflow">if</span> ( ! isReady )</div><div class="line">    {</div><div class="line">        <span class="comment">/* Timeout occurred. */</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Timeout. Neither grabbed an image nor received an event.\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>; <span class="comment">/* Stop grabbing. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( 0 == waitObjectIndex )</div><div class="line">    {</div><div class="line">        <a class="code" href="struct_pylon_event_result__t.html">PylonEventResult_t</a> eventMsg;</div><div class="line">        <span class="comment">/* hWaitEvent has been signalled. At least one event message is available. Retrieve it. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#ga38f586fc7aa2e9cda46a6050fd235326">PylonEventGrabberRetrieveEvent</a>( hEventGrabber, &amp;eventMsg, &amp;isReady );</div><div class="line">        CHECK(res);</div><div class="line">        <span class="keywordflow">if</span> ( ! isReady )</div><div class="line">        {</div><div class="line">            <span class="comment">/* Oops. No event message available? We should never have reached this point.</span></div><div class="line"><span class="comment">            Since the wait operation above returned without a timeout, an event message</span></div><div class="line"><span class="comment">            should be available. */</span></div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Failed to retrieve an event\n&quot;</span>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">/* Check to see if the event was successfully received. */</span></div><div class="line">        <span class="keywordflow">if</span> ( 0 == eventMsg.<a class="code" href="struct_pylon_event_result__t.html#ad7fa25f406eda20ec22679caf86a6fb8">ErrorCode</a> )</div><div class="line">        {</div><div class="line">            <span class="comment">/* Successfully received an event message. */</span></div><div class="line">            <span class="comment">/* Pass the event message to the event adapter. The event adapter will</span></div><div class="line"><span class="comment">            update the parameters related to events and will fire the callbacks</span></div><div class="line"><span class="comment">            registered to event related parameters. */</span></div><div class="line">            res = <a class="code" href="group__pylon.html#ga23da44807ae787519a62ceccd4c53061">PylonEventAdapterDeliverMessage</a>( hEventAdapter, &amp;eventMsg );</div><div class="line">            CHECK(res);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Error when receiving an event: 0x%08x\n&quot;</span>, eventMsg.<a class="code" href="struct_pylon_event_result__t.html#ad7fa25f406eda20ec22679caf86a6fb8">ErrorCode</a> );</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( 1 == waitObjectIndex )</div><div class="line">    {</div><div class="line">        <span class="comment">/* hWaitStream has been signalled. The result of at least one grab</span></div><div class="line"><span class="comment">        operation is available. Retrieve it. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#ga09611f06841721829628143f91beef96">PylonStreamGrabberRetrieveResult</a>( hStreamGrabber, &amp;grabResult, &amp;isReady );</div><div class="line">        CHECK(res);</div><div class="line">        <span class="keywordflow">if</span> ( ! isReady )</div><div class="line">        {</div><div class="line">            <span class="comment">/* Oops. No grab result available? We should never have reached this point.</span></div><div class="line"><span class="comment">            Since the wait operation above returned without a timeout, a grab result</span></div><div class="line"><span class="comment">            should be available. */</span></div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Failed to retrieve a grab result\n&quot;</span>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        nGrabs++;</div><div class="line"></div><div class="line">        <span class="comment">/* Get the buffer index from the context information. */</span></div><div class="line">        bufferIndex = (size_t) grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3fa626bc45486a5b8561cbdfd3847ae4">Context</a>;</div><div class="line"></div><div class="line">        <span class="comment">/* Check to see if the image was grabbed successfully. */</span></div><div class="line">        if ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3217646a22faa23c898dfdc892ca3aca">Status</a> == <a class="code" href="group__pylon.html#gga7ef7a5f4d132577498ce7206274046fea354b91f0a367f3779da75499a612147a">Grabbed</a> )</div><div class="line">        {</div><div class="line">            <span class="comment">/*  Success. Perform image processing. Since we passed more than one buffer</span></div><div class="line"><span class="comment">            to the stream grabber, the remaining buffers are filled while</span></div><div class="line"><span class="comment">            we do the image processing. The processed buffer won&#39;t be touched by</span></div><div class="line"><span class="comment">            the stream grabber until we pass it back to the stream grabber. */</span></div><div class="line"></div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer;        <span class="comment">/* Pointer to the buffer attached to the grab result. */</span></div><div class="line"></div><div class="line">            <span class="comment">/* Get the buffer pointer from the result structure. Since we also got the buffer index,</span></div><div class="line"><span class="comment">            we could alternatively use buffers[bufferIndex]. */</span></div><div class="line">            buffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) grabResult.<a class="code" href="struct_pylon_grab_result__t.html#aa24d463aa40da5523491da53b48eeaf1">pBuffer</a>;</div><div class="line"></div><div class="line"></div><div class="line">            getMinMax( buffer, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a5de217563769a2fecc939a8803c0de49">SizeX</a>, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#ac53ad1519fff771ec8810fb5ffea222d">SizeY</a>, &amp;min, &amp;max );</div><div class="line">            printf(<span class="stringliteral">&quot;Grabbed frame #%2d into buffer %2d. Min. gray value = %3u, Max. gray value = %3u\n&quot;</span>,</div><div class="line">                nGrabs, (<span class="keywordtype">int</span>)bufferIndex, min, max);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a3217646a22faa23c898dfdc892ca3aca">Status</a> == <a class="code" href="group__pylon.html#gga7ef7a5f4d132577498ce7206274046fea1f506c828f4945d6b5a7bf71445f7d54">Failed</a> )</div><div class="line">        {</div><div class="line">            fprintf( stderr,  <span class="stringliteral">&quot;Frame %d wasn&#39;t grabbed successfully.  Error code = 0x%08X\n&quot;</span>,</div><div class="line">                nGrabs, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a597c9f0ddc8e7a63df7e108441e9bd78">ErrorCode</a> );</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Once finished with the processing, requeue the buffer to be filled again. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#gaf60db059b9fb6185ebafb858ba22b87b">PylonStreamGrabberQueueBuffer</a>( hStreamGrabber, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a0dc087840e7dda694c92e8a54ac56838">hBuffer</a>, (<span class="keywordtype">void</span>*) bufferIndex );</div><div class="line">        CHECK(res);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_event_dispatch"></a>
Parsing and Dispatching Event Messages</h3>
<p>While the previous section explained how to receive event messages, this section describes how to interpret them.</p>
<p>The specific layout of event messages depends on the event type and the camera type. The pylon&#160;C API uses support from GenICam for parsing event messages. This means that the message layout is described in the camera's XML description file.</p>
<p>As described in the <a class="el" href="programmingguide.html#advanced_genapinodemaps">Generic Parameter Access</a> section, a GenApi node map is created from the camera's XML description file. This node map contains node objects representing the elements of the XML file. Since the layout of event messages is also described in the camera description file, the information carried by the event messages is exposed as nodes in the node map. These can be accessed just like any other node.</p>
<p>For example, an end-of-exposure event carries the following information: </p><ul>
<li>ExposureEndEventFrameID: holds an identification number for the image frame that the event is related to </li>
<li>ExposureEndEventTimestamp: creation time of the event </li>
<li>ExposureEndEventStreamChannelIndex: the number of the image data stream used to transfer the image that the event is related to</li>
</ul>
<p>An <em>event adapter</em> is used to update the event-related nodes of the camera's node map. Updating the nodes is done by passing the event message to an event adapter.</p>
<p>Event adapters are created by camera objects:</p>
<div class="fragment"><div class="line"><span class="comment">/* For extracting the event data from an event message, an event adapter is used. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga1dafaf6831e3cf292757590b6975b069">PylonDeviceCreateEventAdapter</a>( hDev, &amp;hEventAdapter );</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> ( hEventAdapter == PYLONC_INVALID_HANDLE )</div><div class="line">{</div><div class="line">    <span class="comment">/* The transport layer doesn&#39;t support event grabbers. */</span></div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;No event adapter supported.\n&quot;</span>);</div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">    pressEnterToExit();</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">}</div></div><!-- fragment --><p>To update any event-related nodes, call <code><a class="el" href="group__pylon.html#ga23da44807ae787519a62ceccd4c53061" title="Process event messages. ">PylonEventAdapterDeliverMessage()</a></code> for every event message received:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_pylon_event_result__t.html">PylonEventResult_t</a> eventMsg;</div><div class="line"><span class="comment">/* hWaitEvent has been signalled. At least one event message is available. Retrieve it. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga38f586fc7aa2e9cda46a6050fd235326">PylonEventGrabberRetrieveEvent</a>( hEventGrabber, &amp;eventMsg, &amp;isReady );</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> ( ! isReady )</div><div class="line">{</div><div class="line">    <span class="comment">/* Oops. No event message available? We should never have reached this point.</span></div><div class="line"><span class="comment">    Since the wait operation above returned without a timeout, an event message</span></div><div class="line"><span class="comment">    should be available. */</span></div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Failed to retrieve an event\n&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">}</div><div class="line"><span class="comment">/* Check to see if the event was successfully received. */</span></div><div class="line"><span class="keywordflow">if</span> ( 0 == eventMsg.<a class="code" href="struct_pylon_event_result__t.html#ad7fa25f406eda20ec22679caf86a6fb8">ErrorCode</a> )</div><div class="line">{</div><div class="line">    <span class="comment">/* Successfully received an event message. */</span></div><div class="line">    <span class="comment">/* Pass the event message to the event adapter. The event adapter will</span></div><div class="line"><span class="comment">    update the parameters related to events and will fire the callbacks</span></div><div class="line"><span class="comment">    registered to event related parameters. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#ga23da44807ae787519a62ceccd4c53061">PylonEventAdapterDeliverMessage</a>( hEventAdapter, &amp;eventMsg );</div><div class="line">    CHECK(res);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Error when receiving an event: 0x%08x\n&quot;</span>, eventMsg.<a class="code" href="struct_pylon_event_result__t.html#ad7fa25f406eda20ec22679caf86a6fb8">ErrorCode</a> );</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_event_callback"></a>
Event Callbacks</h3>
<p>The previous section described how event adapters are used to push the contents of event messages into a camera object's node map. The <code><a class="el" href="group__pylon.html#ga23da44807ae787519a62ceccd4c53061" title="Process event messages. ">PylonEventAdapterDeliverMessage()</a></code> function updates all nodes related to events contained in the message passed in.</p>
<p>As described in the <a class="el" href="programmingguide.html#advanced_paramchange">Getting Notified About Parameter Changes</a> section, it is possible to register callback functions that are called when nodes may have been changed. These callbacks can be used to determine if an event message contains a particular kind of event. For example, to get informed about end-of-exposure events, a callback for one of the end-of-exposure event-related nodes must be installed. The following code snippet illustrates how to install a callback function for the ExposureEndFrameId node:</p>
<div class="fragment"><div class="line"><span class="comment">/* Register the callback function for ExposureEndEventFrameID parameter. */</span></div><div class="line"><span class="comment">/*... Get the node map containing all parameters. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga44d55a65e0dd34dca90ca696beda5bf3">PylonDeviceGetNodeMap</a>( hDev, &amp;hNodeMap );</div><div class="line">CHECK(res);</div><div class="line"><span class="comment">/* Get the ExposureEndEventFrameID parameter.</span></div><div class="line"><span class="comment">Select the parameter name depending on the SFNC version used by the camera device.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordflow">if</span> ( sfncVersionMajor &gt;= 2 )</div><div class="line">    res = <a class="code" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec">GenApiNodeMapGetNode</a>( hNodeMap, <span class="stringliteral">&quot;EventExposureEndFrameID&quot;</span>, &amp;hNode );</div><div class="line"><span class="keywordflow">else</span></div><div class="line">    res = <a class="code" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec">GenApiNodeMapGetNode</a>( hNodeMap, <span class="stringliteral">&quot;ExposureEndEventFrameID&quot;</span>, &amp;hNode );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="group__genapi.html#gabafd031e272a150976caa09a8ef73258">GENAPIC_INVALID_HANDLE</a> == hNode )</div><div class="line">{</div><div class="line">    <span class="comment">/* There is no ExposureEndEventFrameID parameter. */</span></div><div class="line">    fprintf( stderr, <span class="stringliteral">&quot;There is no ExposureEndEventFrameID or EventExposureEndFrameID parameter.\n&quot;</span>);</div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">    pressEnterToExit();</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* ... Register the callback function. */</span></div><div class="line">res = <a class="code" href="group__genapi.html#ga0c20a5329a48f950d9459acdb8e775c8">GenApiNodeRegisterCallback</a>( hNode, endOfExposureCallback, &amp;hCallback );</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>The registered callback will be called by pylon&#160;C from the context of the <code><a class="el" href="group__pylon.html#ga23da44807ae787519a62ceccd4c53061" title="Process event messages. ">PylonEventAdapterDeliverMessage()</a></code> function. </p><dl class="section note"><dt>Note</dt><dd>Since one event message can aggregate multiple events, <code><a class="el" href="group__pylon.html#ga23da44807ae787519a62ceccd4c53061" title="Process event messages. ">PylonEventAdapterDeliverMessage()</a></code> can issue multiple calls to a callback function when multiple events of the same type are contained in the message.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">/* Callback will be fired when an event message contains an end-of-exposure event. */</span></div><div class="line"><span class="keywordtype">void</span> GENAPIC_CC endOfExposureCallback( <a class="code" href="group__genapi.html#ga9a893906c491cef62e73124d1ddae198">NODE_HANDLE</a> hNode )</div><div class="line">{</div><div class="line">    int64_t frame;</div><div class="line">    GENAPIC_RESULT res;</div><div class="line">    res = <a class="code" href="group__genapi.html#ga20bf17967c93dfb9fe63abec04423bd0">GenApiIntegerGetValue</a>( hNode, &amp;frame );</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line"><span class="preprocessor">#if __STDC_VERSION__ &gt;= 199901L || defined(__GNUC__)</span></div><div class="line">    printf(<span class="stringliteral">&quot;Got end-of-exposure event. Frame number: %lld\n&quot;</span>, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>) frame );</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    printf(<span class="stringliteral">&quot;Got end-of-exposure event. Frame number: %I64d\n&quot;</span>, frame );</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_event_cleanup"></a>
Cleanup</h3>
<p>Before closing and destroying the camera object, the event-related objects must be closed as illustrated in the following code snippet:</p>
<div class="fragment"><div class="line"><span class="comment">/* ... Deregister the callback. */</span></div><div class="line">res = <a class="code" href="group__genapi.html#gaed1aeeddf96dd7e0ab8dd29f0fdc174c">GenApiNodeDeregisterCallback</a>( hNode, hCallback );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* ... Close the event grabber.*/</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga77f7b0a9255e8b5f505e149cec5cd2a1">PylonEventGrabberClose</a>( hEventGrabber );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* ... Release the event adapter. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaac18632f3379948ef88c1c38836fc9a9">PylonDeviceDestroyEventAdapter</a>( hDev, hEventAdapter );</div><div class="line">CHECK(res);</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_event_sample"></a>
Sample Program</h3>
<p>The code snippets in this chapter are taken from the 'Events' sample program (see <a class="el" href="samples.html#samples_events">Events Sample</a>) included in the installation archive in Samples/C/Events.</p>
<h2><a class="anchor" id="pylonprog_chunk"></a>
Chunk Parser: Accessing Chunk Features</h2>
<p>Basler cameras are capable of sending additional information appended to the image data as chunks of data, such as frame counters, time stamps, and CRC checksums. The information included in the chunk data is presented to an application in the form of parameters that receive their values from the chunk parsing mechanism. This section explains how to enable the <em>chunk features</em> and how to access the chunk data.</p>
<h3><a class="anchor" id="pylonprog_chunk_enable"></a>
Enabling Chunks</h3>
<p>Before a feature producing chunk data can be enabled, the camera's chunk mode must be enabled:</p>
<div class="fragment"><div class="line"><span class="comment">/* Before enabling individual chunks, the chunk mode in general must be activated. */</span></div><div class="line">isAvail = <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>(hDev, <span class="stringliteral">&quot;ChunkModeActive&quot;</span>) ;</div><div class="line"><span class="keywordflow">if</span> ( ! isAvail )</div><div class="line">{</div><div class="line">    fprintf( stderr, <span class="stringliteral">&quot;The device doesn&#39;t support the chunk mode.\n&quot;</span>);</div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">    pressEnterToExit();</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Activate the chunk mode. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gab566c93ad19a2aa3f0e4ae9589c54c47">PylonDeviceSetBooleanFeature</a>( hDev, <span class="stringliteral">&quot;ChunkModeActive&quot;</span>, 1);</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>After having been set to chunk mode, the camera transfers data blocks that are partitioned into a sequence of chunks. The first chunk is always the image data. When chunk features are enabled, the image data chunk is followed by chunks containing the information generated by the chunk features.</p>
<p>Once chunk mode is enabled, chunk features can be enabled:</p>
<div class="fragment"><div class="line"><span class="comment">/* Enable some individual chunks... */</span></div><div class="line"></div><div class="line"><span class="comment">/* ... The frame counter chunk feature. */</span></div><div class="line"><span class="comment">/* Is the chunk available? */</span></div><div class="line">isAvail = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;EnumEntry_ChunkSelector_Framecounter&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> ( isAvail )</div><div class="line">{</div><div class="line">    <span class="comment">/* Select the frame counter chunk feature. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;ChunkSelector&quot;</span>, <span class="stringliteral">&quot;Framecounter&quot;</span> );</div><div class="line">    CHECK(res);</div><div class="line">    <span class="comment">/* Can the chunk feature be activated? */</span></div><div class="line">    isAvail = <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>(hDev, <span class="stringliteral">&quot;ChunkEnable&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> ( isAvail )</div><div class="line">    {</div><div class="line">        <span class="comment">/* Activate the chunk feature. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#gab566c93ad19a2aa3f0e4ae9589c54c47">PylonDeviceSetBooleanFeature</a>( hDev, <span class="stringliteral">&quot;ChunkEnable&quot;</span>, 1);</div><div class="line">        CHECK(res);</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">/* ... The CRC checksum chunk feature. */</span></div><div class="line"><span class="comment">/*  Note: Enabling the CRC chunk feature is not a prerequisite for using</span></div><div class="line"><span class="comment">    chunks. Chunks can also be handled when the CRC feature is disabled. */</span></div><div class="line">isAvail = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;EnumEntry_ChunkSelector_PayloadCRC16&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> ( isAvail )</div><div class="line">{</div><div class="line">    <span class="comment">/* Select the CRC chunk feature. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;ChunkSelector&quot;</span>, <span class="stringliteral">&quot;PayloadCRC16&quot;</span> );</div><div class="line">    CHECK(res);</div><div class="line">    <span class="comment">/* Can the chunk feature be activated? */</span></div><div class="line">    isAvail = <a class="code" href="group__pylon.html#ga0c098c66dbf69f8d9c214620818ffa88">PylonDeviceFeatureIsWritable</a>(hDev, <span class="stringliteral">&quot;ChunkEnable&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> ( isAvail )</div><div class="line">    {</div><div class="line">        <span class="comment">/* Activate the chunk feature. */</span></div><div class="line">        res = <a class="code" href="group__pylon.html#gab566c93ad19a2aa3f0e4ae9589c54c47">PylonDeviceSetBooleanFeature</a>( hDev, <span class="stringliteral">&quot;ChunkEnable&quot;</span>, 1);</div><div class="line">        CHECK(res);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_chunk_grab"></a>
Grabbing Buffers</h3>
<p>Grabbing from an image stream with chunks is very similar to grabbing from an image stream without chunks. Memory buffers must be provided that are large enough to store both the image data and the added chunk data.</p>
<p>The camera's <code>PayloadSize</code> parameter reports the necessary buffersize (in bytes):</p>
<div class="fragment"><div class="line"><span class="comment">/* Determine the required size of the grab buffer. Since activating chunks will increase the</span></div><div class="line"><span class="comment">   payload size and thus the required buffer size, do this after enabling the chunks. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga24f157b352652e4e031b748160cede56">PylonStreamGrabberGetPayloadSize</a>( hDev, hGrabber, &amp;payloadSize );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">/* Allocate memory for grabbing.  */</span></div><div class="line"><span class="keywordflow">for</span> ( i = 0; i &lt; NUM_BUFFERS; ++i )</div><div class="line">{</div><div class="line">    buffers[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) malloc ( payloadSize );</div><div class="line">    <span class="keywordflow">if</span> ( NULL == buffers[i] )</div><div class="line">    {</div><div class="line">        fprintf( stderr, <span class="stringliteral">&quot;Out of memory.\n&quot;</span> );</div><div class="line">        <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">        pressEnterToExit();</div><div class="line">        exit(EXIT_FAILURE);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* We must tell the stream grabber the number and size of the buffers</span></div><div class="line"><span class="comment">   we are using. */</span></div><div class="line"><span class="comment">/* .. We will not use more than NUM_BUFFERS for grabbing. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga95bd2bdbbda3ec1029ff221d063ed81e">PylonStreamGrabberSetMaxNumBuffer</a>( hGrabber, NUM_BUFFERS );</div><div class="line">CHECK(res);</div><div class="line"><span class="comment">/* .. We will not use buffers bigger than payloadSize bytes. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga8eac300db1f6ee57bd3cb9a9ce44e1fd">PylonStreamGrabberSetMaxBufferSize</a>( hGrabber, payloadSize );</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>Once the camera has been set to produce chunk data, and data buffers have been set up taking into account the additional buffer space required to hold the chunk data, grabbing works exactly the same as in the 'no chunks' case.</p>
<h3><a class="anchor" id="pylonprog_chunk_parse"></a>
Accessing the Chunk Data</h3>
<p>The data block containing the image chunk and the other chunks has a self-descriptive layout. Before accessing the data contained in the appended chunks, the data block must be parsed by a <em>chunk parser</em>.</p>
<p>The camera object is responsible for creating a chunk parser:</p>
<div class="fragment"><div class="line"><span class="comment">/* The data block containing the image chunk and the other chunks has a self-descriptive layout.</span></div><div class="line"><span class="comment">   A chunk parser is used to extract the appended chunk data from the grabbed image frame.</span></div><div class="line"><span class="comment">   Create a chunk parser. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaaf8c726b5d979510ad90609c3ea54442">PylonDeviceCreateChunkParser</a>( hDev, &amp;hChunkParser );</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> ( hChunkParser == PYLONC_INVALID_HANDLE )</div><div class="line">{</div><div class="line">    <span class="comment">/* The transport layer doesn&#39;t provide a chunk parser. */</span></div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;No chunk parser available.\n&quot;</span>);</div><div class="line">    <span class="keywordflow">goto</span> exit;</div><div class="line">}</div></div><!-- fragment --><p>Once a chunk parser is created, grabbed buffers can be attached to it. When a buffer is attached to a chunk parser, it is parsed and access to its data is provided through camera parameters.</p>
<div class="fragment"><div class="line">            <span class="comment">/* Check to see if we really got image data plus chunk data. */</span></div><div class="line">            <span class="keywordflow">if</span> ( grabResult.<a class="code" href="struct_pylon_grab_result__t.html#aa25e070149bff5b1fc6a0de3c672da09">PayloadType</a> != <a class="code" href="group__pylon.html#ggae045660cc6522c7dcabd1cf0ff24bb86aa8e019409eb7db7dc91bd65498d7cfeb">PayloadType_ChunkData</a> )</div><div class="line">            {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Received a buffer not containing chunk data?\n&quot;</span>);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="comment">/* Process the chunk data. This is done by passing the grabbed image buffer</span></div><div class="line"><span class="comment">                   to the chunk parser. When the chunk parser has processed the buffer, the chunk</span></div><div class="line"><span class="comment">                   data can be accessed in the same manner as &quot;normal&quot; camera parameters.</span></div><div class="line"><span class="comment">                   The only exception is the CRC feature. There are dedicated functions for</span></div><div class="line"><span class="comment">                   checking the CRC checksum. */</span></div><div class="line"></div><div class="line">                _Bool hasCRC;</div><div class="line"></div><div class="line">                <span class="comment">/* Let the parser extract the data. */</span></div><div class="line">                res = <a class="code" href="group__pylon.html#ga2a53e66be5fba0d25b93b665bd9d6cd6">PylonChunkParserAttachBuffer</a>( hChunkParser, grabResult.<a class="code" href="struct_pylon_grab_result__t.html#aa24d463aa40da5523491da53b48eeaf1">pBuffer</a>, (<span class="keywordtype">size_t</span>) grabResult.<a class="code" href="struct_pylon_grab_result__t.html#a2f8ea337e9d30be53269e73285989024">PayloadSize</a>  );</div><div class="line">                CHECK(res);</div><div class="line"></div><div class="line">                <span class="comment">/* Check the CRC. */</span></div><div class="line">                res = <a class="code" href="group__pylon.html#ga5c56514210b91c184c07ae648d704b88">PylonChunkParserHasCRC</a>( hChunkParser, &amp;hasCRC );</div><div class="line">                CHECK(res);</div><div class="line">                <span class="keywordflow">if</span> ( hasCRC )</div><div class="line">                {</div><div class="line">                    _Bool isOk;</div><div class="line">                    res = <a class="code" href="group__pylon.html#ga8f1e027f014c42b50fdd5662c784b9de">PylonChunkParserCheckCRC</a>( hChunkParser, &amp;isOk );</div><div class="line">                    CHECK(res);</div><div class="line">                    printf(<span class="stringliteral">&quot;Frame %d contains a CRC checksum. The checksum %s ok.\n&quot;</span>, nGrabs, isOk ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;is not&quot;</span>);</div><div class="line">                }</div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">/* Retrieve the frame counter value. */</span></div><div class="line">                <span class="comment">/* ... Check the availability. */</span></div><div class="line">                isAvail = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;ChunkFramecounter&quot;</span>);</div><div class="line">                printf(<span class="stringliteral">&quot;Frame %d %s a frame counter chunk.\n&quot;</span>, nGrabs, isAvail ? <span class="stringliteral">&quot;contains&quot;</span> : <span class="stringliteral">&quot;doesn&#39;t contain&quot;</span> );</div><div class="line">                <span class="keywordflow">if</span> ( isAvail )</div><div class="line">                {</div><div class="line">                    <span class="comment">/* ... Get the value. */</span></div><div class="line">                    int64_t counter;</div><div class="line">                    res = <a class="code" href="group__pylon.html#gae91b560e639a7ad3182f388c3b57c185">PylonDeviceGetIntegerFeature</a>( hDev, <span class="stringliteral">&quot;ChunkFramecounter&quot;</span>, &amp;counter );</div><div class="line">                    CHECK(res);</div><div class="line"><span class="preprocessor">#if __STDC_VERSION__ &gt;= 199901L || defined(__GNUC__)</span></div><div class="line">                    printf(<span class="stringliteral">&quot;Frame counter of frame %d: %lld.\n&quot;</span>, nGrabs, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>) counter );</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">                    printf(<span class="stringliteral">&quot;Frame counter of frame %d: %I64d.\n&quot;</span>, nGrabs, counter );</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">/* Retrieve the frame width value. */</span></div><div class="line">                <span class="comment">/* ... Check the availability. */</span></div><div class="line">                isAvail = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;ChunkWidth&quot;</span>);</div><div class="line">                printf(<span class="stringliteral">&quot;Frame %d %s a width chunk.\n&quot;</span>, nGrabs, isAvail ? <span class="stringliteral">&quot;contains&quot;</span> : <span class="stringliteral">&quot;doesn&#39;t contain&quot;</span> );</div><div class="line">                <span class="keywordflow">if</span> ( isAvail )</div><div class="line">                {</div><div class="line">                    <span class="comment">/* ... Get the value. */</span></div><div class="line">                    res = PylonDeviceGetIntegerFeatureInt32( hDev, <span class="stringliteral">&quot;ChunkWidth&quot;</span>, &amp;chunkWidth );</div><div class="line">                    CHECK(res);</div><div class="line">                    printf(<span class="stringliteral">&quot;Width of frame %d: %d.\n&quot;</span>, nGrabs, chunkWidth );</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">/* Retrieve the frame height value. */</span></div><div class="line">                <span class="comment">/* ... Check the availability. */</span></div><div class="line">                isAvail = <a class="code" href="group__pylon.html#gaf6282be053e2f24b16b7abd93c46b989">PylonDeviceFeatureIsAvailable</a>(hDev, <span class="stringliteral">&quot;ChunkHeight&quot;</span>);</div><div class="line">                CHECK(res);</div><div class="line">                printf(<span class="stringliteral">&quot;Frame %d %s a height chunk.\n&quot;</span>, nGrabs, isAvail ? <span class="stringliteral">&quot;contains&quot;</span> : <span class="stringliteral">&quot;doesn&#39;t contain&quot;</span> );</div><div class="line">                <span class="keywordflow">if</span> ( isAvail )</div><div class="line">                {</div><div class="line">                    <span class="comment">/* ... Get the value. */</span></div><div class="line">                    res = PylonDeviceGetIntegerFeatureInt32( hDev, <span class="stringliteral">&quot;ChunkHeight&quot;</span>, &amp;chunkHeight );</div><div class="line">                    CHECK(res);</div><div class="line">                    printf(<span class="stringliteral">&quot;Height of frame %d: %d.\n&quot;</span>, nGrabs, chunkHeight );</div><div class="line">                }</div><div class="line">            }</div></div><!-- fragment --><p>Chunk data integrity may be protected by an optional checksum. To check for its presence, use <code><a class="el" href="group__pylon.html#ga5c56514210b91c184c07ae648d704b88" title="Return true if CRC checksum chunk data is present. ">PylonChunkParserHasCRC()</a></code>.</p>
<div class="fragment"><div class="line"><span class="comment">/* Check the CRC. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga5c56514210b91c184c07ae648d704b88">PylonChunkParserHasCRC</a>( hChunkParser, &amp;hasCRC );</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> ( hasCRC )</div><div class="line">{</div><div class="line">    _Bool isOk;</div><div class="line">    res = <a class="code" href="group__pylon.html#ga8f1e027f014c42b50fdd5662c784b9de">PylonChunkParserCheckCRC</a>( hChunkParser, &amp;isOk );</div><div class="line">    CHECK(res);</div><div class="line">    printf(<span class="stringliteral">&quot;Frame %d contains a CRC checksum. The checksum %s ok.\n&quot;</span>, nGrabs, isOk ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;is not&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>Before re-using a buffer for grabbing, the buffer must be detached from the chunk parser.</p>
<div class="fragment"><div class="line"><span class="comment">/* Before requeueing the buffer, you should detach it from the chunk parser. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga2c1dc736e7d3dcb2515b2f70577c625b">PylonChunkParserDetachBuffer</a>( hChunkParser );  <span class="comment">/* The chunk data in the buffer is now no longer accessible. */</span></div><div class="line">CHECK(res);</div></div><!-- fragment --><p>After detaching a buffer, the next grabbed buffer can be attached and the included chunk data can be read.</p>
<p>After grabbing is finished, the chunk parser must be deleted:</p>
<div class="fragment"><div class="line"><span class="comment">/* ... Release the chunk parser. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga5a623aaae018e600bf6c7a5fff68dedb">PylonDeviceDestroyChunkParser</a>( hDev, hChunkParser );</div><div class="line">CHECK(res);</div></div><!-- fragment --><h3><a class="anchor" id="pylonprog_chunk_sample"></a>
Sample Program</h3>
<p>The code snippets in this chapter are taken from the 'Chunks' sample program (see <a class="el" href="samples.html#samples_chunks">Chunks Sample</a>) included in the installation archive in Samples/C/Chunks.</p>
<h2><a class="anchor" id="pylonprog_pnp"></a>
Getting Informed About Device Removal</h2>
<p>Callback functions can be installed that are called whenever a camera device is removed. As soon as the <code><a class="el" href="group__pylon.html#gaa90f00f56a23d31abe6634ff33fb981d" title="Open a device. ">PylonDeviceOpen()</a></code> function has been called, callback functions of the <code>PylonDeviceRemCb_t</code> type can be installed for it.</p>
<p>Installing a callback function:</p>
<div class="fragment"><div class="line"><span class="comment">/* Register the callback function. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gae4e7a3fc641dd79dfc38ca8acdf0436d">PylonDeviceRegisterRemovalCallback</a>( hDev, removalCallbackFunction, &amp;hCb );</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>All registered callbacks must be deregistered before calling <code><a class="el" href="group__pylon.html#ga41878ee7b3ba7064553a6aac3ca37bcd" title="Close a device. ">PylonDeviceClose()</a></code>.</p>
<div class="fragment"><div class="line"><span class="comment">/* ... Deregister the removal callback. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga137b49e403c32bb666d18f8237cf7002">PylonDeviceDeregisterRemovalCallback</a>( hDev, hCb );</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>This is the actual callback function. It does nothing besides incrementing a counter.</p>
<div class="fragment"><div class="line"><span class="comment">/* The function to be called when the removal of an opened device is detected. */</span></div><div class="line"><span class="keywordtype">void</span> GENAPIC_CC removalCallbackFunction(<a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDevice )</div><div class="line">{</div><div class="line">    <a class="code" href="struct_pylon_device_info__t.html">PylonDeviceInfo_t</a>   di;</div><div class="line">    GENAPIC_RESULT      res;</div><div class="line"></div><div class="line">    <span class="comment">/* Print out the name of the device. It is not possible to read the name</span></div><div class="line"><span class="comment">    from the camera since it has been removed. Use the device&#39;s device</span></div><div class="line"><span class="comment">    information instead. For accessing the device information, no reading from</span></div><div class="line"><span class="comment">    the device is required. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Retrieve the device information for the removed device. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#gaecd6211310dd30bd56c1826d1d173899">PylonDeviceGetDeviceInfo</a>( hDevice, &amp;di );</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Print out the name. */</span></div><div class="line">    printf( <span class="stringliteral">&quot;\nCallback function for removal of device %s (%s).\n&quot;</span>, di.<a class="code" href="struct_pylon_device_info__t.html#a8a61332f81f9f4fd7ee26c25dcfbfa0e">FriendlyName</a>, di.<a class="code" href="struct_pylon_device_info__t.html#a31918f34454cab1350e39ece08569f78">FullName</a> );</div><div class="line"></div><div class="line">    <span class="comment">/* Increment the counter to indicate that the callback has been fired. */</span></div><div class="line">    callbackCounter++;</div><div class="line">}</div></div><!-- fragment --><p>The code snippets in this section are taken from the 'SurpriseRemoval' sample program (see <a class="el" href="samples.html#samples_surpriseremoval">SurpriseRemoval Sample</a>) included in the installation archive in Samples/C/SurpriseRemoval.</p>
<h1><a class="anchor" id="advanced"></a>
Advanced Topics</h1>
<h2><a class="anchor" id="advanced_genapinodemaps"></a>
Generic Parameter Access</h2>
<p>For camera configuration and for accessing other parameters, the pylon API uses the technologies defined by the GenICam standard hosted by the European Machine Vision Association (EMVA). The GenICam specification (<a href="http://www.GenICam.org">http://www.GenICam.org</a>) defines a format for camera description files. These files describe the configuration interface of GenICam compliant cameras. The description files are written in XML (eXtensible Markup Language) and describe camera registers, their interdependencies, and all other information needed to access high-level features such as <code>Gain</code>, <code>Exposure</code> <code>Time</code>, or <code>Image</code> <code>Format</code> by means of low-level register read and write operations.</p>
<p>The elements of a camera description file are represented as software objects called <em>nodes</em>. For example, a node can represent a single camera register, a camera parameter such as Gain, a set of available parameter values, etc. Nodes are represented as handles of the <code>NODE_HANDLE</code> type.</p>
<p>Nodes are linked together by different relationships as explained in the GenICam standard document available at www.GenICam.org. The complete set of nodes is stored in a data structure called a <em>node map</em>. At runtime, a node map is instantiated from an XML description, which may exist as a disk file on the computer connected to a camera, or may be read from the camera itself. Node map objects are represented by handles of the <code>NODEMAP_HANDLE</code> type.</p>
<p>Every node has a name, which is a text string. Node names are unique within a node map, and any node can be looked up by its name. All parameter access functions presented so far are actually shortcuts that get a node map handle from an object, look up a node that implements a named parameter, and finally perform the desired action on the node, such as assigning a new value, for example. The sample code below demonstrates how to look up a parameter node with a known name. If no such node exists, <code><a class="el" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec" title="Find a node by its name. ">GenApiNodeMapGetNode()</a></code> returns an invalid handle. This case needs to be handled by the program like in the sample code below, but a real program may want to handle this case differently.</p>
<div class="fragment"><div class="line"><span class="comment">/* Look up the feature node */</span></div><div class="line">res = <a class="code" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec">GenApiNodeMapGetNode</a>(hNodeMap, featureName, &amp;hNode);</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__genapi.html#gabafd031e272a150976caa09a8ef73258">GENAPIC_INVALID_HANDLE</a> == hNode)</div><div class="line">{</div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;There is no feature named &#39;%s&#39;\n&quot;</span>, featureName);</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div></div><!-- fragment --><p>Nodes are generally grouped into categories, which themselves are represented as nodes of the <em>Category</em> type. A category node is an abstraction for a certain functional aspect of a camera, and all parameter nodes grouped under it are related to this aspect. For example, the 'AOI Controls' category might contain an 'X Offset, a 'Y Offset', a 'Width', and a 'Height' parameter node. The topological structure of a node map is that of a tree, with parameter nodes as leaves and category nodes as junctions. The sample code below traverses the tree, displaying every node found:</p>
<div class="fragment"><div class="line"><span class="comment">/* Traverse the feature tree, displaying all categories and all features. */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">handleCategory(<a class="code" href="group__genapi.html#ga9a893906c491cef62e73124d1ddae198">NODE_HANDLE</a> hRoot, <span class="keywordtype">char</span> * buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> depth)</div><div class="line">{</div><div class="line">    GENAPIC_RESULT      res;</div><div class="line">    <span class="keywordtype">size_t</span>              bufsiz, siz, numfeat, i;</div><div class="line"></div><div class="line">    <span class="comment">/* Write out node name. */</span></div><div class="line">    siz = bufsiz = STRING_BUFFER_SIZE - depth * 2;</div><div class="line">    res = <a class="code" href="group__genapi.html#gad7d8ea46ffe207f8a27013ea1da98091">GenApiNodeGetName</a>(hRoot, buf, &amp;siz);</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line">    <span class="comment">/* Get the number of feature nodes in this category. */</span></div><div class="line">    res = <a class="code" href="group__genapi.html#ga09f246d6d86aa6c1c31fdc1ce3bdd0e3">GenApiCategoryGetNumFeatures</a>(hRoot, &amp;numfeat);</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;%s category has %u children\n&quot;</span>, buf - depth * 2, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) numfeat);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Increase indentation. */</span></div><div class="line">    *buf++ = <span class="charliteral">&#39; &#39;</span>;</div><div class="line">    *buf++ = <span class="charliteral">&#39; &#39;</span>;</div><div class="line">    bufsiz -= 2;</div><div class="line">    ++depth;</div><div class="line"></div><div class="line">    <span class="comment">/* Now loop over all feature nodes. */</span></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; numfeat; ++i)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__genapi.html#ga9a893906c491cef62e73124d1ddae198">NODE_HANDLE</a>         hNode;</div><div class="line">        <a class="code" href="group__genapi.html#ga71b037111b67ab501e3cf0fabc97685f">EGenApiNodeType</a>     nodeType;</div><div class="line"></div><div class="line">        <span class="comment">/* Get next feature node and check its type. */</span></div><div class="line">        res = <a class="code" href="group__genapi.html#ga6db8d5ef0448213539baf0f04b44c6e2">GenApiCategoryGetFeatureByIndex</a>(hRoot, i, &amp;hNode);</div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__genapi.html#ga9494f3c1973aa7768ddd7b65283f048f">GenApiNodeGetType</a>(hNode, &amp;nodeType);</div><div class="line">        CHECK(res);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__genapi.html#gga71b037111b67ab501e3cf0fabc97685fa50b0d16e6ab8a004634e95a13d197c86">Category</a> != nodeType)</div><div class="line">        {</div><div class="line">            <span class="comment">/* A regular feature. */</span></div><div class="line">            <a class="code" href="group__genapi.html#ga0722c4c9851710e9c198ec47d287b0c5">EGenApiAccessMode</a> am;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span> *amode;</div><div class="line"></div><div class="line">            siz = bufsiz;</div><div class="line">            res = <a class="code" href="group__genapi.html#gad7d8ea46ffe207f8a27013ea1da98091">GenApiNodeGetName</a>(hNode, buf, &amp;siz);</div><div class="line">            CHECK(res);</div><div class="line">            res = <a class="code" href="group__genapi.html#ga7d193a5396e518378a6313222ed3e0c3">GenApiNodeGetAccessMode</a>(hNode, &amp;am);</div><div class="line">            CHECK(res);</div><div class="line"></div><div class="line">            <span class="keywordflow">switch</span> (am)</div><div class="line">            {</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__genapi.html#gga0722c4c9851710e9c198ec47d287b0c5a26d79910e64c12e79ffb16d6d4347e1c">NI</a>:</div><div class="line">                amode = <span class="stringliteral">&quot;not implemented&quot;</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__genapi.html#gga0722c4c9851710e9c198ec47d287b0c5ac75245149c3f64d74430b8996b1e0558">NA</a>:</div><div class="line">                amode = <span class="stringliteral">&quot;not available&quot;</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__genapi.html#gga0722c4c9851710e9c198ec47d287b0c5a60d1a52f84d34da6f6537317a1775929">WO</a>:</div><div class="line">                amode = <span class="stringliteral">&quot;write only&quot;</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__genapi.html#gga0722c4c9851710e9c198ec47d287b0c5a42e9aa764b9ee7ecf7e668462de6f96d">RO</a>:</div><div class="line">                amode = <span class="stringliteral">&quot;read only&quot;</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__genapi.html#gga0722c4c9851710e9c198ec47d287b0c5aec2497e0c8af01c04bec31ec0d1d7847">RW</a>:</div><div class="line">                amode = <span class="stringliteral">&quot;read and write&quot;</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">                amode = <span class="stringliteral">&quot;undefined&quot;</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            printf(<span class="stringliteral">&quot;%s feature - access: %s\n&quot;</span>, buf - depth * 2, amode);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            <span class="comment">/* Another category node. */</span></div><div class="line">            handleCategory(hNode, buf, depth);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">demonstrateCategory(<a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev)</div><div class="line">{</div><div class="line">    <a class="code" href="group__genapi.html#ga3db34c6a854e89e2551d4c1e8a8afe56">NODEMAP_HANDLE</a>      hNodeMap;</div><div class="line">    <a class="code" href="group__genapi.html#ga9a893906c491cef62e73124d1ddae198">NODE_HANDLE</a>         hNode;</div><div class="line">    <span class="keywordtype">char</span>                buf[512];</div><div class="line">    GENAPIC_RESULT      res;</div><div class="line"></div><div class="line">    <span class="comment">/* Get a handle for the device&#39;s node map. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#ga44d55a65e0dd34dca90ca696beda5bf3">PylonDeviceGetNodeMap</a>(hDev, &amp;hNodeMap);</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line">    <span class="comment">/* Look up the root node. */</span></div><div class="line">    res = <a class="code" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec">GenApiNodeMapGetNode</a>(hNodeMap, <span class="stringliteral">&quot;Root&quot;</span>, &amp;hNode);</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line">    handleCategory(hNode, buf, 0);</div><div class="line">}</div></div><!-- fragment --><p>In order to access a parameters value, a handle for the corresponding parameter node must be obtained first, as demonstrated in the example below for an integer feature:</p>
<div class="fragment"><div class="line"><span class="comment">/* This function demonstrates how to handle integer camera parameters. */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">demonstrateIntFeature(<a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a> hDev)</div><div class="line">{</div><div class="line">    <a class="code" href="group__genapi.html#ga3db34c6a854e89e2551d4c1e8a8afe56">NODEMAP_HANDLE</a>      hNodeMap;</div><div class="line">    <a class="code" href="group__genapi.html#ga9a893906c491cef62e73124d1ddae198">NODE_HANDLE</a>         hNode;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>   featureName[] = <span class="stringliteral">&quot;Width&quot;</span>;  <span class="comment">/* Name of the feature used in this sample: AOI Width. */</span></div><div class="line">    int64_t             val, min, max, incr;      <span class="comment">/* Properties of the feature. */</span></div><div class="line">    GENAPIC_RESULT      res;                      <span class="comment">/* Return value. */</span></div><div class="line">    <a class="code" href="group__genapi.html#ga71b037111b67ab501e3cf0fabc97685f">EGenApiNodeType</a>     nodeType;</div><div class="line">    _Bool                bval;</div><div class="line"></div><div class="line">    <span class="comment">/* Get a handle for the device&#39;s node map. */</span></div><div class="line">    res = <a class="code" href="group__pylon.html#ga44d55a65e0dd34dca90ca696beda5bf3">PylonDeviceGetNodeMap</a>(hDev, &amp;hNodeMap);</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line">    <span class="comment">/* Look up the feature node */</span></div><div class="line">    res = <a class="code" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec">GenApiNodeMapGetNode</a>(hNodeMap, featureName, &amp;hNode);</div><div class="line">    CHECK(res);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__genapi.html#gabafd031e272a150976caa09a8ef73258">GENAPIC_INVALID_HANDLE</a> == hNode)</div><div class="line">    {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;There is no feature named &#39;%s&#39;\n&quot;</span>, featureName);</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* We want an integer feature node. */</span></div><div class="line">    res = <a class="code" href="group__genapi.html#ga9494f3c1973aa7768ddd7b65283f048f">GenApiNodeGetType</a>(hNode, &amp;nodeType);</div><div class="line">    CHECK(res);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__genapi.html#gga71b037111b67ab501e3cf0fabc97685fa1da780bf3139bd8e8c1415edf109f2fe">IntegerNode</a> != nodeType)</div><div class="line">    {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;&#39;%s&#39; is not an integer feature\n&quot;</span>, featureName);</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">       Query the current value, the range of allowed values, and the increment of the feature.</span></div><div class="line"><span class="comment">       For some integer features, you are not allowed to set every value within the</span></div><div class="line"><span class="comment">       value range. For example, for some cameras the Width parameter must be a multiple</span></div><div class="line"><span class="comment">       of 2. These constraints are expressed by the increment value. Valid values</span></div><div class="line"><span class="comment">       follow the rule: val &gt;= min &amp;&amp; val &lt;= max &amp;&amp; val == min + n * inc.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    res = <a class="code" href="group__genapi.html#ga1aa1911e20805459c37f6b0d02f7aed7">GenApiNodeIsReadable</a>(hNode, &amp;bval);</div><div class="line">    CHECK(res);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (bval)</div><div class="line">    {</div><div class="line">        res = <a class="code" href="group__genapi.html#gacc9955c1df6daeaf6f9a5d079e019785">GenApiIntegerGetMin</a>(hNode, &amp;min);       <span class="comment">/* Get the minimum value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__genapi.html#ga0282fe15bd20ae5067ce0f2dac93c04d">GenApiIntegerGetMax</a>(hNode, &amp;max);       <span class="comment">/* Get the maximum value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__genapi.html#gacb7dd1eee58c4b822b9501913d255c64">GenApiIntegerGetInc</a>(hNode, &amp;incr);       <span class="comment">/* Get the increment value. */</span></div><div class="line">        CHECK(res);</div><div class="line">        res = <a class="code" href="group__genapi.html#ga20bf17967c93dfb9fe63abec04423bd0">GenApiIntegerGetValue</a>(hNode, &amp;val);     <span class="comment">/* Get the current value. */</span></div><div class="line">        CHECK(res);</div><div class="line"></div><div class="line"><span class="preprocessor">#if __STDC_VERSION__ &gt;= 199901L || defined(__GNUC__)</span></div><div class="line">        printf(<span class="stringliteral">&quot;%s: min= %lld  max= %lld  incr=%lld  Value=%lld\n&quot;</span>, featureName, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>) min, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>) max, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>) incr, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>) val);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        printf(<span class="stringliteral">&quot;%s: min= %I64d  max= %I64d  incr=%I64d  Value=%I64d\n&quot;</span>, featureName, min, max, incr, val);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        res = <a class="code" href="group__genapi.html#gacfed6478a76075e94c259e45a3516367">GenApiNodeIsWritable</a>(hNode, &amp;bval);</div><div class="line">        CHECK(res);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (bval)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Set the Width half-way between minimum and maximum. */</span></div><div class="line">            res = <a class="code" href="group__genapi.html#gac50b79c0b5285b9552966fa7049c1d81">GenApiIntegerSetValue</a>(hNode, min + (max - min) / incr / 2 * incr);</div><div class="line">            CHECK(res);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Cannot set value for feature &#39;%s&#39; - node not writable\n&quot;</span>, featureName);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Cannot read feature &#39;%s&#39; - node not readable\n&quot;</span>, featureName);</div><div class="line">}</div></div><!-- fragment --><p>So far, only camera node maps have been considered. However, there are more objects that expose parameters through node maps: </p><ul>
<li>The <code><a class="el" href="group__pylon.html#gad12c9521b848016cb6cc5b48453701c2" title="Obtain a transport layer parameter node map from a device. ">PylonDeviceGetTLNodeMap()</a></code> function returns the node map for a device's transport layer. </li>
<li>The <code><a class="el" href="group__pylon.html#ga2e13feb8a0a579eaa787d8673a21f8fc" title="Return the node map for a stream grabber. ">PylonStreamGrabberGetNodeMap()</a></code> function is used to access a stream grabber's parameters. </li>
<li>The <code><a class="el" href="group__pylon.html#gabde1f183c2963a75c05359ed09e7448c" title="Return an event grabber&#39;s parameter node map. ">PylonEventGrabberGetNodeMap()</a></code> function is used to access an event grabber's parameters. Parameter access works identical for all types of node maps, and the same set of functions is used as for camera node maps. It should be noted, however, that the objects listed above, transport layers in particular, may not have any parameters at all. In this case, a call to the corresponding function would return <code>GENAPIC_INVALID_HANDLE</code>.</li>
</ul>
<h2><a class="anchor" id="advanced_parambrowse"></a>
Browsing Parameters</h2>
<p>The <em>pylon Viewer</em> tool provides an easy way of browsing camera parameters, their names, values, and ranges. Besides grabbing images (not available for Camera Link cameras ) it is capable of displaying all node maps for a camera device, and all parameter nodes contained therein. The <em>pylon Viewer</em> tool has a <em>Features</em> window that displays a tree view of node maps, categories, and parameter nodes. Selecting a node in this view opens a dialog that displays the node's current value (if applicable), and may also allow to change it, subject to accessibility. There is also a <em>Feature Documentation</em> window, located at the very bottom of the display unless the layout was changed from the standard layout. The Feature Documentation window displays detailed information about the currently selected node.</p>
<h2><a class="anchor" id="advanced_paramchange"></a>
Getting Notified About Parameter Changes</h2>
<p>The pylon&#160;C API provides the functionality for installing callback functions that will be called when a parameter's value or state (e.g. the access mode or value range) was changed.</p>
<p>Every callback is installed for a specific parameter. If the parameter itself has been touched or if another parameter that could possibly influence the state of the parameter has been changed, the callback will be invoked.</p>
<p>The example below illustrates how to find a parameter node and register a callback:</p>
<div class="fragment"><div class="line"><span class="comment">/* Register the callback function for ExposureEndEventFrameID parameter. */</span></div><div class="line"><span class="comment">/*... Get the node map containing all parameters. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#ga44d55a65e0dd34dca90ca696beda5bf3">PylonDeviceGetNodeMap</a>( hDev, &amp;hNodeMap );</div><div class="line">CHECK(res);</div><div class="line"><span class="comment">/* Get the ExposureEndEventFrameID parameter.</span></div><div class="line"><span class="comment">Select the parameter name depending on the SFNC version used by the camera device.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordflow">if</span> ( sfncVersionMajor &gt;= 2 )</div><div class="line">    res = <a class="code" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec">GenApiNodeMapGetNode</a>( hNodeMap, <span class="stringliteral">&quot;EventExposureEndFrameID&quot;</span>, &amp;hNode );</div><div class="line"><span class="keywordflow">else</span></div><div class="line">    res = <a class="code" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec">GenApiNodeMapGetNode</a>( hNodeMap, <span class="stringliteral">&quot;ExposureEndEventFrameID&quot;</span>, &amp;hNode );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="group__genapi.html#gabafd031e272a150976caa09a8ef73258">GENAPIC_INVALID_HANDLE</a> == hNode )</div><div class="line">{</div><div class="line">    <span class="comment">/* There is no ExposureEndEventFrameID parameter. */</span></div><div class="line">    fprintf( stderr, <span class="stringliteral">&quot;There is no ExposureEndEventFrameID or EventExposureEndFrameID parameter.\n&quot;</span>);</div><div class="line">    <a class="code" href="group__pylon.html#ga2879c3121624d1f2ab48171a92f12503">PylonTerminate</a>();</div><div class="line">    pressEnterToExit();</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* ... Register the callback function. */</span></div><div class="line">res = <a class="code" href="group__genapi.html#ga0c20a5329a48f950d9459acdb8e775c8">GenApiNodeRegisterCallback</a>( hNode, endOfExposureCallback, &amp;hCallback );</div><div class="line">CHECK(res);</div></div><!-- fragment --><p>As an optimization, nodes that can only change their values as a direct result of some user action (an application writing a new value) can have their values cached on the computer to speed up read access. Other nodes can change their values asynchronously, e. g. as a result of some operation performed by a camera internally. These nodes obviously cannot be cached. An application should call the function <code><a class="el" href="group__genapi.html#gafe4f7261d627f1072fafda6e89c89658" title="Poll all nodes in a node map. ">GenApiNodeMapPoll()</a></code> at regular intervals. This results in the values of non-cachable nodes being updated in the node map, which in turn may cause callbacks to be executed as explained above.</p>
<h2><a class="anchor" id="advanced_mcgrab"></a>
GigE Multicast/Broadcast: Grab Images of One Camera on Multiple PCs</h2>
<p>Basler GigE cameras can be set to send the image data stream to multiple destinations. More information on this subject can be found in the pylon C++ Programmer's Guide.</p>
<h2><a class="anchor" id="advanced_action"></a>
GigE Action Commands</h2>
<p>The action command feature lets you trigger actions in multiple GigE devices (e.g. cameras) at roughly the same time or at a defined point in time (scheduled action command) by using a single broadcast protocol message (without extra cabling). Action commands are used in cameras in the same way as for example the digital input lines.</p>
<p>After setting up the camera parameters required for action commands the methods <a class="el" href="group__pylon.html#gac715eb52d896f104f3a3f21bc6a1c9c4" title="Issue an action command via broadcast. ">PylonGigEIssueActionCommand()</a> or <a class="el" href="group__pylon.html#ga3cc32e23955dd14c3d26a70f3394ead9" title="Issue a scheduled action command via broadcast. ">PylonGigEIssueScheduledActionCommand()</a> can be used to trigger action commands.</p>
<p>This is shown in the sample <a class="el" href="samples.html#samples_triggeredgrab">ActionCommands Sample</a>.</p>
<p>Consult the the camera User's Manual for more detailed information on action commands.</p>
<h2><a class="anchor" id="migration_to_sfnc2"></a>
Migrating Existing Code for Using SFNC 2.X-Based Camera Devices</h2>
<h3><a class="anchor" id="sfnc_parameter_name_changes"></a>
Changes of Parameter Names and Behavior</h3>
<p>Most features, e.g., Gain, are named according to the GenICam Standard Feature Naming Convention (SFNC). The SFNC defines a common set of features, their behavior, and the related parameter names. All Basler USB 3.0 and CoaXPress as well as most GigE, e.g., ace 2 GigE, cameras are based on the SFNC version 2.0 or later. Older Basler GigE camera models, however, are based on previous SFNC versions. Accordingly, the behavior of these cameras and some parameter names will be different.</p>
<p>Additionally, parameters that are not covered by the SFNC have been prefixed with Bsl for some camera models, e.g., for all ace 2 camera models. This has been done to be able to clearly distinguish these parameter names from SFNC parameter names.</p>
<p>Code working with multiple camera device types that are compatible with different SFNC versions can read the SFNC version from a camera device to select the correct parameter names. The SFNC version can be read from the camera node map using the integer nodes DeviceSFNCVersionMajor, DeviceSFNCVersionMinor, and DeviceSFNCVersionSubMinor.</p>
<p>Example for selecting the parameter name depending on the SFNC version:</p>
<div class="fragment"><div class="line"><span class="comment">/* Determine the major number of the SFNC version used by the camera device. */</span></div><div class="line"><span class="keywordflow">if</span> ( PylonDeviceGetIntegerFeatureInt32( hDev, <span class="stringliteral">&quot;DeviceSFNCVersionMajor&quot;</span>, &amp;sfncVersionMajor ) != <a class="code" href="group__errorcodes.html#gac7281a9a8cebe48fa600a002fbd3b598">GENAPI_E_OK</a> )</div><div class="line">{</div><div class="line">    <span class="comment">/* No SFNC version information is provided by the camera device. */</span></div><div class="line">    sfncVersionMajor = 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Enable camera event reporting. */</span></div><div class="line"><span class="comment">/* Select the end-of-exposure event reporting. */</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;EventSelector&quot;</span>, <span class="stringliteral">&quot;ExposureEnd&quot;</span> );</div><div class="line">CHECK(res);</div><div class="line"><span class="comment">/* Enable the event reporting.</span></div><div class="line"><span class="comment">Select the enumeration entry name depending on the SFNC version used by the camera device.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordflow">if</span> ( sfncVersionMajor &gt;= 2 )</div><div class="line">    res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;EventNotification&quot;</span>, <span class="stringliteral">&quot;On&quot;</span> );</div><div class="line"><span class="keywordflow">else</span></div><div class="line">    res = <a class="code" href="group__pylon.html#gaff15e9141876f4cc9879ac36dbb69383">PylonDeviceFeatureFromString</a>( hDev, <span class="stringliteral">&quot;EventNotification&quot;</span>, <span class="stringliteral">&quot;GenICamEvent&quot;</span> );</div><div class="line">CHECK(res);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The above sample code snippet uses convenience methods for accessing camera device parameters. After getting the node map handle from the device using <a class="el" href="group__pylon.html#ga44d55a65e0dd34dca90ca696beda5bf3" title="Return the parameter node map for a device. ">PylonDeviceGetNodeMap()</a>, the camera parameters can also be accessed using the GenApi methods, e.g. <a class="el" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec" title="Find a node by its name. ">GenApiNodeMapGetNode()</a>, <a class="el" href="group__genapi.html#ga20bf17967c93dfb9fe63abec04423bd0" title="Get a node&#39;s integer value without validation. ">GenApiIntegerGetValue()</a>, and others.</dd></dl>
<p>The following tables show how to map previous parameter names to their equivalents defined in SFNC 2.X. Some previous parameters have no direct equivalents. There are previous parameters, however, that can still be accessed using the so-called alias that is provided via the <a class="el" href="group__genapi.html#gaceb3c01ddc8ac06a5ab5c8891647b7d0" title="Get a node&#39;s alias. ">GenApiNodeGetAlias()</a> function. The alias is another representation of the original parameter. Usually, the alias provides an Integer representation of a Float parameter.</p>
<dl class="section attention"><dt>Attention</dt><dd>Depending on the camera device model the alias does not provide a proper name, display name, tool tip, or description. The value range of an alias node can change when updating the camera firmware.</dd></dl>
<p>The following table shows how to map changes for parameters:</p>
<dl class="section attention"><dt>Attention</dt><dd>The actual changes between previous cameras and SFNC 2.X compliant cameras depend on the used models and the used camera firmware versions. It is possible that changes are not listed in the tables below. Other sources of information regarding changes between camera models are the Camera User's Manuals or the information shown in the Pylon Viewer tool.</dd></dl>
<table  border="1" class="table" frame="void" cellspacing="6" cellpadding="7">
<tr>
<th>Previous Parameter Name </th><th>SFNC 2.x or Equivalent with Bsl Prefix </th><th>Parameter Type </th><th>Comments  </th></tr>
<tr>
<td>AcquisitionFrameCount </td><td>AcquisitionBurstFrameCount </td><td>Integer </td><td></td></tr>
<tr>
<td>AcquisitionFrameRateAbs </td><td>AcquisitionFrameRate </td><td>Float </td><td></td></tr>
<tr>
<td>AcquisitionStartEventFrameID </td><td>EventFrameBurstStartFrameID </td><td>Integer </td><td></td></tr>
<tr>
<td>AcquisitionStartEventTimestamp </td><td>EventFrameBurstStartTimestamp </td><td>Integer </td><td></td></tr>
<tr>
<td>AcquisitionStartOvertriggerEventFrameID </td><td>EventFrameBurstStartOvertriggerFrameID </td><td>Integer </td><td></td></tr>
<tr>
<td>AcquisitionStartOvertriggerEventTimestamp </td><td>EventFrameBurstStartOvertriggerTimestamp </td><td>Integer </td><td></td></tr>
<tr>
<td>AutoExposureTimeAbsLowerLimit </td><td>AutoExposureTimeLowerLimit </td><td>Float </td><td></td></tr>
<tr>
<td>AutoExposureTimeAbsUpperLimit </td><td>AutoExposureTimeUpperLimit </td><td>Float </td><td></td></tr>
<tr>
<td>AutoFunctionAOIUsageIntensity </td><td>AutoFunctionAOIUseBrightness </td><td>Boolean </td><td></td></tr>
<tr>
<td>AutoFunctionAOIUsageWhiteBalance </td><td>AutoFunctionAOIUseWhiteBalance </td><td>Boolean </td><td></td></tr>
<tr>
<td>AutoGainRawLowerLimit </td><td>Alias of AutoGainLowerLimit </td><td>Integer </td><td></td></tr>
<tr>
<td>AutoGainRawUpperLimit </td><td>Alias of AutoGainUpperLimit </td><td>Integer </td><td></td></tr>
<tr>
<td>AutoTargetValue </td><td>Alias of AutoTargetBrightness </td><td>Integer </td><td></td></tr>
<tr>
<td>BalanceRatioAbs </td><td>BalanceRatio </td><td>Float </td><td></td></tr>
<tr>
<td>BalanceRatioRaw </td><td>Alias of BalanceRatio </td><td>Integer </td><td></td></tr>
<tr>
<td>BlackLevelAbs </td><td>BlackLevel </td><td>Float </td><td></td></tr>
<tr>
<td>BlackLevelRaw </td><td>Alias of BlackLevel </td><td>Integer </td><td></td></tr>
<tr>
<td>ChunkExposureTimeRaw </td><td></td><td>Integer </td><td>ChunkExposureTimeRaw has been replaced with ChunkExposureTime. ChunkExposureTime is of type float.  </td></tr>
<tr>
<td>ChunkFrameCounter </td><td></td><td>Integer </td><td>ChunkFrameCounter has been replaced with ChunkCounterSelector and ChunkCounterValue.  </td></tr>
<tr>
<td>ChunkGainAll </td><td></td><td>Integer </td><td>ChunkGainAll has been replaced with ChunkGain. ChunkGain is of type float.  </td></tr>
<tr>
<td>ColorAdjustmentEnable </td><td></td><td>Boolean </td><td>ColorAdjustmentEnable has been removed. The color adjustment is always enabled.  </td></tr>
<tr>
<td>ColorAdjustmentEnable </td><td>BslColorAdjustmentEnable </td><td>Boolean </td><td></td></tr>
<tr>
<td>ColorAdjustmentHue </td><td>BslColorAdjustmentHue </td><td>Float </td><td></td></tr>
<tr>
<td>ColorAdjustmentHueRaw </td><td>Alias of ColorAdjustmentHue or BslColorAdjustmentHue </td><td>Integer </td><td></td></tr>
<tr>
<td>ColorAdjustmentReset </td><td></td><td>Command </td><td>ColorAdjustmentReset has been removed.  </td></tr>
<tr>
<td>ColorAdjustmentSaturation </td><td>BslColorAdjustmentSaturation </td><td>Float </td><td></td></tr>
<tr>
<td>ColorAdjustmentSaturationRaw </td><td>Alias of ColorAdjustmentSaturation or BslColorAdjustmentSaturation </td><td>Integer </td><td></td></tr>
<tr>
<td>ColorAdjustmentSelector </td><td>BslColorAdjustmentSelector </td><td>Enumeration </td><td></td></tr>
<tr>
<td>ColorSpace </td><td>BslColorSpace </td><td>Enumeration </td><td></td></tr>
<tr>
<td>ColorTransformationValueRaw </td><td>Alias of ColorTransformationValue </td><td>Integer </td><td></td></tr>
<tr>
<td>ContrastMode </td><td>BslContrastMode </td><td>Enumeration </td><td></td></tr>
<tr>
<td>DefaultSetSelector </td><td></td><td>Enumeration </td><td>See additional entries in UserSetSelector.  </td></tr>
<tr>
<td>ExposureEndEventFrameID </td><td>EventExposureEndFrameID </td><td>Integer </td><td></td></tr>
<tr>
<td>ExposureEndEventTimestamp </td><td>EventExposureEndTimestamp </td><td>Integer </td><td></td></tr>
<tr>
<td>ExposureTimeAbs </td><td>ExposureTime </td><td>Float </td><td></td></tr>
<tr>
<td>ExposureTimeMode </td><td>BslExposureTimeMode </td><td>Enumeration </td><td></td></tr>
<tr>
<td>ExposureTimeRaw </td><td>Alias of ExposureTime </td><td>Integer </td><td></td></tr>
<tr>
<td>FrameStartEventFrameID </td><td>EventFrameStartFrameID </td><td>Integer </td><td></td></tr>
<tr>
<td>FrameStartEventTimestamp </td><td>EventFrameStartTimestamp </td><td>Integer </td><td></td></tr>
<tr>
<td>FrameStartOvertriggerEventFrameID </td><td>EventFrameStartOvertriggerFrameID </td><td>Integer </td><td></td></tr>
<tr>
<td>FrameStartOvertriggerEventTimestamp </td><td>EventFrameStartOvertriggerTimestamp </td><td>Integer </td><td></td></tr>
<tr>
<td>GainAbs </td><td>Gain </td><td>Float </td><td></td></tr>
<tr>
<td>GainRaw </td><td>Alias of Gain </td><td>Integer </td><td></td></tr>
<tr>
<td>GammaEnable </td><td></td><td>Boolean </td><td>GammaEnable has been removed. Gamma is always enabled.  </td></tr>
<tr>
<td>GammaSelector </td><td></td><td>Enumeration </td><td>The sRGB setting is automatically applied when LineSourcePreset is set to any other value than Off.  </td></tr>
<tr>
<td>GevIEEE1588 </td><td>PtpEnable </td><td>Boolean </td><td></td></tr>
<tr>
<td>GevIEEE1588ClockId </td><td>PtpClockID </td><td>Integer </td><td></td></tr>
<tr>
<td>GevIEEE1588DataSetLatch </td><td>PtpDataSetLatch </td><td>Command </td><td></td></tr>
<tr>
<td>GevIEEE1588OffsetFromMaster </td><td>PtpOffsetFromMaster </td><td>Integer </td><td></td></tr>
<tr>
<td>GevIEEE1588ParentClockId </td><td>PtpParentClockID </td><td>Integer </td><td></td></tr>
<tr>
<td>GevIEEE1588Status </td><td></td><td>Enumeration </td><td>GevIEEE1588Status has been removed. Use PtpDataSetLatch and then PtpStatus instead.  </td></tr>
<tr>
<td>GevIEEE1588StatusLatched </td><td>PtpStatus </td><td>Enumeration </td><td></td></tr>
<tr>
<td>GevTimestampControlLatch </td><td>TimestampLatch </td><td>Command </td><td></td></tr>
<tr>
<td>GevTimestampControlLatchReset </td><td></td><td>Command </td><td></td></tr>
<tr>
<td>GevTimestampControlReset </td><td>TimestampReset </td><td>Command </td><td></td></tr>
<tr>
<td>GevTimestampValue </td><td>TimestampLatchValue </td><td>Integer </td><td></td></tr>
<tr>
<td>GlobalResetReleaseModeEnable </td><td></td><td>Boolean </td><td>GlobalResetReleaseModeEnable has been replaced with the enumeration ShutterMode.  </td></tr>
<tr>
<td>LightSourcePreset </td><td>BslLightSourcePreset </td><td>Enumeration </td><td></td></tr>
<tr>
<td>LightSourceSelector </td><td>LightSourcePreset </td><td>Enumeration </td><td></td></tr>
<tr>
<td>LineDebouncerTimeAbs </td><td>LineDebouncerTime </td><td>Float </td><td></td></tr>
<tr>
<td>LineOverloadStatus </td><td>BslLineOverloadStatus </td><td>Boolean </td><td></td></tr>
<tr>
<td>MinOutPulseWidthAbs </td><td>LineMinimumOutputPulseWidth </td><td>Float </td><td></td></tr>
<tr>
<td>MinOutPulseWidthRaw </td><td>Alias of LineMinimumOutputPulseWidth </td><td>Integer </td><td></td></tr>
<tr>
<td>ParameterSelector </td><td>RemoveParameterLimitSelector </td><td>Enumeration </td><td></td></tr>
<tr>
<td>ProcessedRawEnable </td><td></td><td>Boolean </td><td>ProcessedRawEnable has been removed because it is not needed anymore. The camera uses nondestructive Bayer demosaicing now.  </td></tr>
<tr>
<td>ReadoutTimeAbs </td><td>SensorReadoutTime </td><td>Float </td><td></td></tr>
<tr>
<td>ResultingFrameRateAbs </td><td>ResultingFrameRate </td><td>Float </td><td></td></tr>
<tr>
<td>SensorBitDepth </td><td>BslSensorBitDepth </td><td>Enumeration </td><td></td></tr>
<tr>
<td>SequenceAddressBitSelector </td><td></td><td>Enumeration </td><td></td></tr>
<tr>
<td>SequenceAdvanceMode </td><td></td><td>Enumeration </td><td></td></tr>
<tr>
<td>SequenceAsyncAdvance </td><td></td><td>Command </td><td>Configure a asynchronous signal as trigger source of path 1.  </td></tr>
<tr>
<td>SequenceAsyncRestart </td><td></td><td>Command </td><td>Configure a asynchronous signal as trigger source of path 0.  </td></tr>
<tr>
<td>SequenceBitSource </td><td></td><td>Enumeration </td><td></td></tr>
<tr>
<td>SequenceControlConfig </td><td></td><td>Category </td><td></td></tr>
<tr>
<td>SequenceControlSelector </td><td></td><td>Enumeration </td><td></td></tr>
<tr>
<td>SequenceControlSource </td><td></td><td>Enumeration </td><td></td></tr>
<tr>
<td>SequenceCurrentSet </td><td>SequencerSetActive </td><td>Integer </td><td></td></tr>
<tr>
<td>SequenceEnable </td><td></td><td>Boolean </td><td>Replaced by SequencerConfigurationMode and SequencerMode.  </td></tr>
<tr>
<td>SequenceSetExecutions </td><td></td><td>Integer </td><td></td></tr>
<tr>
<td>SequenceSetIndex </td><td>SequencerSetSelector </td><td>Integer </td><td></td></tr>
<tr>
<td>SequenceSetLoad </td><td>SequencerSetLoad </td><td>Command </td><td></td></tr>
<tr>
<td>SequenceSetStore </td><td>SequencerSetSave </td><td>Command </td><td></td></tr>
<tr>
<td>SequenceSetTotalNumber </td><td></td><td>Integer </td><td>Use the range of the SequencerSetSelector.  </td></tr>
<tr>
<td>TemperatureState </td><td>BslTemperatureStatus </td><td>Enumeration </td><td></td></tr>
<tr>
<td>TestImageSelector </td><td>TestPattern </td><td>Enumeration </td><td>TestPattern instead of TestImageSelector is used for dart and pulse camera models.  </td></tr>
<tr>
<td>TimerDelayAbs </td><td>TimerDelay </td><td>Float </td><td></td></tr>
<tr>
<td>TimerDelayRaw </td><td>Alias of TimerDelay </td><td>Integer </td><td></td></tr>
<tr>
<td>TimerDelayTimebaseAbs </td><td></td><td>Float </td><td>The time base is always 1us.  </td></tr>
<tr>
<td>TimerDurationAbs </td><td>TimerDuration </td><td>Float </td><td></td></tr>
<tr>
<td>TimerDurationRaw </td><td>Alias of TimerDuration </td><td>Integer </td><td></td></tr>
<tr>
<td>TimerDurationTimebaseAbs </td><td></td><td>Float </td><td>The time base is always 1us.  </td></tr>
<tr>
<td>TriggerDelayAbs </td><td>TriggerDelay </td><td>Float </td><td></td></tr>
<tr>
<td>UserSetDefaultSelector </td><td>UserSetDefault </td><td>Enumeration </td><td></td></tr>
<tr>
<td>VignettingCorrectionLoad </td><td>BslVignettingCorrectionLoad </td><td>Command </td><td></td></tr>
<tr>
<td>VignettingCorrectionMode </td><td>BslVignettingCorrectionMode </td><td>Enumeration </td><td></td></tr>
</table>
<p>The following table shows how to map changes for enumeration values:</p>
<table  border="1" class="table" frame="void" cellspacing="6" cellpadding="7">
<tr>
<th>Previous Enumeration Name </th><th>Previous Enumeration Value Name </th><th>Value Name SFNC 2.X </th><th>Comments  </th></tr>
<tr>
<td>AcquisitionStatusSelector </td><td>AcquisitionTriggerWait </td><td>FrameBurstTriggerWait </td><td></td></tr>
<tr>
<td>AutoFunctionProfile </td><td>ExposureMinimum </td><td>MinimizeExposureTime </td><td></td></tr>
<tr>
<td>AutoFunctionProfile </td><td>GainMinimum </td><td>MinimizeGain </td><td></td></tr>
<tr>
<td>ChunkSelector </td><td>GainAll </td><td>Gain </td><td>The gain value is reported via the ChunkGain node as float.  </td></tr>
<tr>
<td>ChunkSelector </td><td>Height </td><td></td><td>Height is part of the image information regardless of the chunk mode setting.  </td></tr>
<tr>
<td>ChunkSelector </td><td>OffsetX </td><td></td><td>OffsetX is part of the image information regardless of the chunk mode setting.  </td></tr>
<tr>
<td>ChunkSelector </td><td>OffsetY </td><td></td><td>OffsetY is part of the image information regardless of the chunk mode setting.  </td></tr>
<tr>
<td>ChunkSelector </td><td>PixelFormat </td><td></td><td>PixelFormat is part of the image information regardless of the chunk mode setting.  </td></tr>
<tr>
<td>ChunkSelector </td><td>Stride </td><td></td><td>Stride is part of the image information regardless of the chunk mode setting.  </td></tr>
<tr>
<td>ChunkSelector </td><td>Width </td><td></td><td>Width is part of the image information regardless of the chunk mode setting.  </td></tr>
<tr>
<td>EventNotification </td><td>GenICamEvent </td><td>On </td><td></td></tr>
<tr>
<td>EventSelector </td><td>AcquisitionStartOvertrigger </td><td>FrameBurstStartOvertrigger </td><td></td></tr>
<tr>
<td>EventSelector </td><td>AcquisitionStart </td><td>FrameBurstStart </td><td></td></tr>
<tr>
<td>LightSourceSelector </td><td>Daylight </td><td>Daylight5000K </td><td></td></tr>
<tr>
<td>LightSourceSelector </td><td>Tungsten </td><td>Tungsten2800K </td><td></td></tr>
<tr>
<td>LineSelector </td><td>Out1 </td><td></td><td>The operation mode of an I/O-Pin is chosen using the LineMode Selector.  </td></tr>
<tr>
<td>LineSelector </td><td>Out2 </td><td></td><td>The operation mode of an I/O-Pin is chosen using the LineMode Selector.  </td></tr>
<tr>
<td>LineSelector </td><td>Out3 </td><td></td><td>The operation mode of an I/O-Pin is chosen using the LineMode Selector.  </td></tr>
<tr>
<td>LineSelector </td><td>Out4 </td><td></td><td>The operation mode of an I/O-Pin is chosen using the LineMode Selector.  </td></tr>
<tr>
<td>LineSource </td><td>AcquisitionTriggerWait </td><td>FrameBurstTriggerWait </td><td></td></tr>
<tr>
<td>LineSource </td><td>UserOutput </td><td></td><td>Use UserOutput1, UserOutput2, or UserOutput3 etc. instead.  </td></tr>
<tr>
<td>PixelFormat </td><td>BayerBG12Packed </td><td></td><td>The pixel format BayerBG12p is provided by USB camera devices. The memory layout of pixel format BayerBG12Packed and pixel format BayerBG12p is different. See the camera User's Manuals for more information on pixel formats.  </td></tr>
<tr>
<td>PixelFormat </td><td>BayerGB12Packed </td><td></td><td>The pixel format BayerGB12p is provided by USB camera devices. The memory layout of pixel format BayerGB12Packed and pixel format BayerGB12p is different. See the camera User's Manuals for more information on pixel formats.  </td></tr>
<tr>
<td>PixelFormat </td><td>BayerGR12Packed </td><td></td><td>The pixel format BayerGR12p is provided by USB camera devices. The memory layout of pixel format BayerGR12Packed and pixel format BayerGR12p is different. See the camera User's Manuals for more information on pixel formats.  </td></tr>
<tr>
<td>PixelFormat </td><td>BayerRG12Packed </td><td></td><td>The pixel format BayerRG12p is provided by USB camera devices. The memory layout of pixel format BayerRG12Packed and pixel format BayerRG12p is different. See the camera User's Manuals for more information on pixel formats.  </td></tr>
<tr>
<td>PixelFormat </td><td>BGR10Packed </td><td>BGR10 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>BGR12Packed </td><td>BGR12 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>BGR8Packed </td><td>BGR8 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>BGRA8Packed </td><td>BGRa8 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>Mono10Packed </td><td></td><td>The pixel format Mono10p is provided by USB camera devices. The memory layout of pixel format Mono10Packed and pixel format Mono10p is different. See the camera User's Manuals for more information on pixel formats.  </td></tr>
<tr>
<td>PixelFormat </td><td>Mono12Packed </td><td></td><td>The pixel format Mono12p is provided by USB camera devices. The memory layout of pixel format Mono12Packed and pixel format Mono12p is different. See the camera User's Manuals for more information on pixel formats.  </td></tr>
<tr>
<td>PixelFormat </td><td>Mono1Packed </td><td>Mono1p </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>Mono2Packed </td><td>Mono2p </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>Mono4Packed </td><td>Mono4p </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>RGB10Packed </td><td>RGB10 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>RGB12Packed </td><td>RGB12 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>RGB16Packed </td><td>RGB16 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>RGB8Packed </td><td>RGB8 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>RGBA8Packed </td><td>RGBa8 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>YUV411Packed </td><td>YCbCr411_8 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>YUV422_YUYV_Packed </td><td>YCbCr422_8 </td><td></td></tr>
<tr>
<td>PixelFormat </td><td>YUV444Packed </td><td>YCbCr8 </td><td></td></tr>
<tr>
<td>TestImageSelector </td><td>Testimage1 </td><td>GreyDiagonalSawtooth8 </td><td>GreyDiagonalSawtooth8 instead of Testimage1 is used for dart and pulse camera models.  </td></tr>
<tr>
<td>TriggerSelector </td><td>AcquisitionStart </td><td>FrameBurstStart </td><td></td></tr>
</table>
<h2><a class="anchor" id="sfnc_parameter_name_changes_cm"></a>
Migration Mode</h2>
<p>pylon USB and GigE devices offer a convenient migration mode that allows you to work with camera devices that are based on different SFNC versions by automatically adapting your application code accordingly. If the migration mode is enabled, the changes shown in the tables above are automatically reflected in your code where appropriate. If you are only working with SFNC 2.x-based cameras, however, Basler strongly recommends rewriting existing code to be SFNC 2.x-compliant instead of using the migration mode. How to use the migration mode is also shown in the <a class="el" href="samples.html#samples_genapiparam">GenApiParam Sample</a> sample.</p>
<dl class="section attention"><dt>Attention</dt><dd>Existing applications may use features that can't be mapped automatically. In this case, the application code needs to adapted before it can be used with SFNC 2.x-based cameras. The behavior of a parameter may have changed as well, e.g., its value range. Check this carefully. Furthermore, automatically mapped alias nodes don't provide a proper name, display name, tooltip, or description. The value range of an alias node can change when updating the camera firmware.</dd></dl>
<p>The following simple code snippet demonstrates how to turn the migration mode on, and to set the exposure time node to the value 100 using two names mapped to the same node. See also the tables above. </p><div class="fragment"><div class="line">GENAPIC_RESULT              res;</div><div class="line"><a class="code" href="group__pylon.html#gae9c73a5792f379665b1304f1998ab0b5">PYLON_DEVICE_HANDLE</a>         hDev;</div><div class="line"><a class="code" href="group__genapi.html#ga9a893906c491cef62e73124d1ddae198">NODE_HANDLE</a>                 hNode;</div><div class="line"><a class="code" href="group__genapi.html#ga3db34c6a854e89e2551d4c1e8a8afe56">NODEMAP_HANDLE</a>              hTlNodemap;</div><div class="line">_Bool                       isWritable;</div><div class="line"></div><div class="line"><span class="comment">// Create the first camera device found.</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaa635d34dd80fbd30a1d495d90e3e152b">PylonCreateDeviceByIndex</a>( 0, &amp;hDev );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">// Open the camera</span></div><div class="line">res = <a class="code" href="group__pylon.html#gaa90f00f56a23d31abe6634ff33fb981d">PylonDeviceOpen</a>( hDev, PYLONC_ACCESS_MODE_CONTROL );</div><div class="line">CHECK( res );</div><div class="line"></div><div class="line"><span class="comment">// Retrieve the transport layer node map.</span></div><div class="line">res = <a class="code" href="group__pylon.html#gad12c9521b848016cb6cc5b48453701c2">PylonDeviceGetTLNodeMap</a>( hDev, &amp;hTlNodemap );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line"><span class="comment">// Find the migration mode enable node.</span></div><div class="line">res = <a class="code" href="group__genapi.html#ga903a4b86f5c57f37d06f710a1b54e4ec">GenApiNodeMapGetNode</a>( hTlNodemap, <span class="stringliteral">&quot;MigrationModeEnable&quot;</span>, &amp;hNode );</div><div class="line">CHECK(res);</div><div class="line"></div><div class="line">res = <a class="code" href="group__genapi.html#gacfed6478a76075e94c259e45a3516367">GenApiNodeIsWritable</a>( hNode, &amp;isWritable );</div><div class="line">CHECK(res);</div><div class="line"><span class="keywordflow">if</span> (isWritable)</div><div class="line">{   <span class="comment">// Enable the migration mode if available and writable.</span></div><div class="line">    res = <a class="code" href="group__genapi.html#ga209215d9a0073b004da8c07992f2d6e2">GenApiBooleanSetValue</a>( hNode, 1 );</div><div class="line">    CHECK( res );</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// For demonstration purpose only, access the ExposureTimeAbs alias ExposureTime.</span></div><div class="line">    res = <a class="code" href="group__pylon.html#ga000efa39f55f2c51eef7d29fef7e6420">PylonDeviceSetFloatFeature</a>( hDev, <span class="stringliteral">&quot;ExposureTimeAbs&quot;</span>, 100.0 );</div><div class="line">    CHECK( res );</div><div class="line"></div><div class="line">    <span class="comment">// ExposureTime can still be accessed. The same node is used.</span></div><div class="line">    res = <a class="code" href="group__pylon.html#ga000efa39f55f2c51eef7d29fef7e6420">PylonDeviceSetFloatFeature</a>( hDev, <span class="stringliteral">&quot;ExposureTime&quot;</span>, 100.0 );</div><div class="line">    CHECK( res );</div><div class="line">}</div></div><!-- fragment --><p>The migration mode is implemented using proxy objects. If the migration mode is enabled, the proxy calls the alias node. If the migration mode is not enabled or not available for a node, the call is forwarded to the original node. This mapping also applies to calls of <a class="el" href="group__genapi.html#gaf7e4e2969c8cad63148ce027dbe0d594" title="Get an entry from an enumeration by name. ">GenApiEnumerationGetEntryByName()</a>, <a class="el" href="group__genapi.html#ga922c66737a0d35afb75babd096349df0" title="Return a textual representation of a node&#39;s value. ">GenApiNodeToString()</a>, <a class="el" href="group__genapi.html#ga0b30683b8a7b72c37114dcab656c8ada" title="Return a textual representation of a node&#39;s value with optional validation. ">GenApiNodeToStringEx()</a>, and <a class="el" href="group__genapi.html#gad50eb7731bee223c02379838af5f6370" title="Return the symbolic name of an enumeration entry node. ">GenApiEnumerationEntryGetSymbolic()</a>.</p>
<h2><a class="anchor" id="migration_to_usb"></a>
Migrating to Using USB Camera Devices</h2>
<h3><a class="anchor" id="usb_changes_transport"></a>
Differences in Image Transport</h3>
<p>The image transport on USB camera devices differs from the image transport on GigE camera devices. GigE camera devices automatically send image data to the PC when available. If the PC is not ready to receive the image data because no grab buffer is available, the image data sent by the camera device is dropped. For USB camera devices the PC has to actively request the image data. Grabbed images are stored in the frame buffer of the USB camera device until the PC requests the image data. If the frame buffer of the USB camera device is full, newly acquired frames will be dropped. Old images in the frame buffer of the USB camera device will be grabbed first the next time the PC requests image data. After that, newly acquired images are grabbed.</p>
<h3><a class="anchor" id="usb_and_counters"></a>
USB Camera Devices and Block ID</h3>
<p>Image data is transferred between a PC and a USB camera device using a certain sequence of data packets. In the rare case of an error during the image transport, the image data stream between PC and USB camera device is reset automatically, e.g. if the image packet sequence is out of sync. The image data stream reset causes the Block ID delivered by the USB camera device to start again at zero. Pylon indicates this error condition by setting the <a class="el" href="struct_pylon_grab_result__t.html#a78a42cc71382f7a58e15cf33040a0566">Block ID </a> of the grab result to its highest possible value (UINT64_MAX) for all subsequent grab results. A Block ID of UINT64_MAX is invalid and cannot be used in any further operations. The image data and other grab result data are not affected by the Block ID being invalid. The grabbing needs to be stopped and restarted to recover from this error condition if the application uses the Block ID. The Block ID starts at zero if the grabbing is restarted.</p>
<p>Calling the <a class="el" href="group__pylon.html#gaa571171cb0805c4d0490caa1413553ae" title="Cancels grabbing the current buffer and flushes all buffers to the output queue. ">PylonStreamGrabberFlushBuffersToOutput()</a> function resets the image stream between PC and USB camera device, too. Therefore, the value of the Block ID is set to UINT64_MAX for all subsequent grab results after calling PylonStreamGrabberFlushBuffersToOutput.</p>
<h2><a class="anchor" id="camemu_tl"></a>
Camera Emulator</h2>
<p>pylon offers a camera emulation transport layer, which is similar to other transport layers. The camera emulator transport layer can create simple camera emulator devices that allow you to develop applications without having a physical camera device attached to your computer. The emulator's functionality is limited, but it is able to create test images for different bit depths.</p>
<p>The number of available emulator devices can be controlled by setting the &lt;PYLON_CAMEMU&gt; environment variable.</p>
<p>Example: </p><div class="fragment"><div class="line">PYLON_CAMEMU=2</div></div><!-- fragment --><p>This will provide two emulator devices. These devices can be accessed using the pylon API and the pylon Viewer program.</p>
<p>When &lt;PYLON_CAMEMU&gt; is not set, no emulator devices are provided.</p>
<dl class="section note"><dt>Note</dt><dd>A maximum of 256 emulator devices are supported. </dd></dl>
</div></div><!-- contents -->
<hr>
<div id="projectname">pylon C <span id="projectnumber">6.1.0</span></div>
<address><small>Copyright (c) 2006-2020 <a href="http://www.baslerweb.com/">Basler AG</a>   (Mon Mar 16 2020 10:56:45)</small></address>
</body>
</html>
