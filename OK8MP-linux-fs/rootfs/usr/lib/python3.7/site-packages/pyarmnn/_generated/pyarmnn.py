# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pyarmnn
else:
    import _pyarmnn

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyarmnn.delete_SwigPyIterator

    def value(self):
        return _pyarmnn.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _pyarmnn.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _pyarmnn.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _pyarmnn.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _pyarmnn.SwigPyIterator_equal(self, x)

    def copy(self):
        return _pyarmnn.SwigPyIterator_copy(self)

    def next(self):
        return _pyarmnn.SwigPyIterator_next(self)

    def __next__(self):
        return _pyarmnn.SwigPyIterator___next__(self)

    def previous(self):
        return _pyarmnn.SwigPyIterator_previous(self)

    def advance(self, n):
        return _pyarmnn.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _pyarmnn.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _pyarmnn.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _pyarmnn.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _pyarmnn.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _pyarmnn.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _pyarmnn.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pyarmnn:
_pyarmnn.SwigPyIterator_swigregister(SwigPyIterator)

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _pyarmnn.ios_base_erase_event
    imbue_event = _pyarmnn.ios_base_imbue_event
    copyfmt_event = _pyarmnn.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _pyarmnn.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _pyarmnn.ios_base_flags(self, *args)

    def setf(self, *args):
        return _pyarmnn.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _pyarmnn.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _pyarmnn.ios_base_precision(self, *args)

    def width(self, *args):
        return _pyarmnn.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync=True):
        return _pyarmnn.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc):
        return _pyarmnn.ios_base_imbue(self, __loc)

    def getloc(self):
        return _pyarmnn.ios_base_getloc(self)

    @staticmethod
    def xalloc():
        return _pyarmnn.ios_base_xalloc()

    def iword(self, __ix):
        return _pyarmnn.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _pyarmnn.ios_base_pword(self, __ix)
    __swig_destroy__ = _pyarmnn.delete_ios_base

# Register ios_base in _pyarmnn:
_pyarmnn.ios_base_swigregister(ios_base)
cvar = _pyarmnn.cvar
ios_base.boolalpha = _pyarmnn.cvar.ios_base_boolalpha
ios_base.dec = _pyarmnn.cvar.ios_base_dec
ios_base.fixed = _pyarmnn.cvar.ios_base_fixed
ios_base.hex = _pyarmnn.cvar.ios_base_hex
ios_base.internal = _pyarmnn.cvar.ios_base_internal
ios_base.left = _pyarmnn.cvar.ios_base_left
ios_base.oct = _pyarmnn.cvar.ios_base_oct
ios_base.right = _pyarmnn.cvar.ios_base_right
ios_base.scientific = _pyarmnn.cvar.ios_base_scientific
ios_base.showbase = _pyarmnn.cvar.ios_base_showbase
ios_base.showpoint = _pyarmnn.cvar.ios_base_showpoint
ios_base.showpos = _pyarmnn.cvar.ios_base_showpos
ios_base.skipws = _pyarmnn.cvar.ios_base_skipws
ios_base.unitbuf = _pyarmnn.cvar.ios_base_unitbuf
ios_base.uppercase = _pyarmnn.cvar.ios_base_uppercase
ios_base.adjustfield = _pyarmnn.cvar.ios_base_adjustfield
ios_base.basefield = _pyarmnn.cvar.ios_base_basefield
ios_base.floatfield = _pyarmnn.cvar.ios_base_floatfield
ios_base.badbit = _pyarmnn.cvar.ios_base_badbit
ios_base.eofbit = _pyarmnn.cvar.ios_base_eofbit
ios_base.failbit = _pyarmnn.cvar.ios_base_failbit
ios_base.goodbit = _pyarmnn.cvar.ios_base_goodbit
ios_base.app = _pyarmnn.cvar.ios_base_app
ios_base.ate = _pyarmnn.cvar.ios_base_ate
ios_base.binary = _pyarmnn.cvar.ios_base_binary
ios_base.ios_base_in = _pyarmnn.cvar.ios_base_ios_base_in
ios_base.out = _pyarmnn.cvar.ios_base_out
ios_base.trunc = _pyarmnn.cvar.ios_base_trunc
ios_base.beg = _pyarmnn.cvar.ios_base_beg
ios_base.cur = _pyarmnn.cvar.ios_base_cur
ios_base.end = _pyarmnn.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync=True):
    return _pyarmnn.ios_base_sync_with_stdio(__sync)

def ios_base_xalloc():
    return _pyarmnn.ios_base_xalloc()

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self):
        return _pyarmnn.ios_rdstate(self)

    def clear(self, *args):
        return _pyarmnn.ios_clear(self, *args)

    def setstate(self, __state):
        return _pyarmnn.ios_setstate(self, __state)

    def good(self):
        return _pyarmnn.ios_good(self)

    def eof(self):
        return _pyarmnn.ios_eof(self)

    def fail(self):
        return _pyarmnn.ios_fail(self)

    def bad(self):
        return _pyarmnn.ios_bad(self)

    def exceptions(self, *args):
        return _pyarmnn.ios_exceptions(self, *args)

    def __init__(self, __sb):
        _pyarmnn.ios_swiginit(self, _pyarmnn.new_ios(__sb))
    __swig_destroy__ = _pyarmnn.delete_ios

    def tie(self, *args):
        return _pyarmnn.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _pyarmnn.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _pyarmnn.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _pyarmnn.ios_fill(self, *args)

    def imbue(self, __loc):
        return _pyarmnn.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _pyarmnn.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _pyarmnn.ios_widen(self, __c)

# Register ios in _pyarmnn:
_pyarmnn.ios_swigregister(ios)

class ostream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _pyarmnn.ostream_swiginit(self, _pyarmnn.new_ostream(__sb))
    __swig_destroy__ = _pyarmnn.delete_ostream

    def __lshift__(self, *args):
        return _pyarmnn.ostream___lshift__(self, *args)

    def put(self, __c):
        return _pyarmnn.ostream_put(self, __c)

    def write(self, __s, __n):
        return _pyarmnn.ostream_write(self, __s, __n)

    def flush(self):
        return _pyarmnn.ostream_flush(self)

    def tellp(self):
        return _pyarmnn.ostream_tellp(self)

    def seekp(self, *args):
        return _pyarmnn.ostream_seekp(self, *args)

# Register ostream in _pyarmnn:
_pyarmnn.ostream_swigregister(ostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

class istream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _pyarmnn.istream_swiginit(self, _pyarmnn.new_istream(__sb))
    __swig_destroy__ = _pyarmnn.delete_istream

    def __rshift__(self, *args):
        return _pyarmnn.istream___rshift__(self, *args)

    def gcount(self):
        return _pyarmnn.istream_gcount(self)

    def get(self, *args):
        return _pyarmnn.istream_get(self, *args)

    def getline(self, *args):
        return _pyarmnn.istream_getline(self, *args)

    def ignore(self, *args):
        return _pyarmnn.istream_ignore(self, *args)

    def peek(self):
        return _pyarmnn.istream_peek(self)

    def read(self, __s, __n):
        return _pyarmnn.istream_read(self, __s, __n)

    def readsome(self, __s, __n):
        return _pyarmnn.istream_readsome(self, __s, __n)

    def putback(self, __c):
        return _pyarmnn.istream_putback(self, __c)

    def unget(self):
        return _pyarmnn.istream_unget(self)

    def sync(self):
        return _pyarmnn.istream_sync(self)

    def tellg(self):
        return _pyarmnn.istream_tellg(self)

    def seekg(self, *args):
        return _pyarmnn.istream_seekg(self, *args)

# Register istream in _pyarmnn:
_pyarmnn.istream_swigregister(istream)

class iostream(istream, ostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _pyarmnn.iostream_swiginit(self, _pyarmnn.new_iostream(__sb))
    __swig_destroy__ = _pyarmnn.delete_iostream

# Register iostream in _pyarmnn:
_pyarmnn.iostream_swigregister(iostream)

endl_cb_ptr = _pyarmnn.endl_cb_ptr
endl = _pyarmnn.endl
ends_cb_ptr = _pyarmnn.ends_cb_ptr
ends = _pyarmnn.ends
flush_cb_ptr = _pyarmnn.flush_cb_ptr
flush = _pyarmnn.flush
class BackendIdVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyarmnn.BackendIdVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyarmnn.BackendIdVector___nonzero__(self)

    def __bool__(self):
        return _pyarmnn.BackendIdVector___bool__(self)

    def __len__(self):
        return _pyarmnn.BackendIdVector___len__(self)

    def __getslice__(self, i, j):
        return _pyarmnn.BackendIdVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyarmnn.BackendIdVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyarmnn.BackendIdVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyarmnn.BackendIdVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyarmnn.BackendIdVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyarmnn.BackendIdVector___setitem__(self, *args)

    def pop(self):
        return _pyarmnn.BackendIdVector_pop(self)

    def append(self, x):
        return _pyarmnn.BackendIdVector_append(self, x)

    def empty(self):
        return _pyarmnn.BackendIdVector_empty(self)

    def size(self):
        return _pyarmnn.BackendIdVector_size(self)

    def swap(self, v):
        return _pyarmnn.BackendIdVector_swap(self, v)

    def begin(self):
        return _pyarmnn.BackendIdVector_begin(self)

    def end(self):
        return _pyarmnn.BackendIdVector_end(self)

    def rbegin(self):
        return _pyarmnn.BackendIdVector_rbegin(self)

    def rend(self):
        return _pyarmnn.BackendIdVector_rend(self)

    def clear(self):
        return _pyarmnn.BackendIdVector_clear(self)

    def get_allocator(self):
        return _pyarmnn.BackendIdVector_get_allocator(self)

    def pop_back(self):
        return _pyarmnn.BackendIdVector_pop_back(self)

    def erase(self, *args):
        return _pyarmnn.BackendIdVector_erase(self, *args)

    def __init__(self, *args):
        _pyarmnn.BackendIdVector_swiginit(self, _pyarmnn.new_BackendIdVector(*args))

    def push_back(self, x):
        return _pyarmnn.BackendIdVector_push_back(self, x)

    def front(self):
        return _pyarmnn.BackendIdVector_front(self)

    def back(self):
        return _pyarmnn.BackendIdVector_back(self)

    def assign(self, n, x):
        return _pyarmnn.BackendIdVector_assign(self, n, x)

    def resize(self, *args):
        return _pyarmnn.BackendIdVector_resize(self, *args)

    def insert(self, *args):
        return _pyarmnn.BackendIdVector_insert(self, *args)

    def reserve(self, n):
        return _pyarmnn.BackendIdVector_reserve(self, n)

    def capacity(self):
        return _pyarmnn.BackendIdVector_capacity(self)
    __swig_destroy__ = _pyarmnn.delete_BackendIdVector

# Register BackendIdVector in _pyarmnn:
_pyarmnn.BackendIdVector_swigregister(BackendIdVector)

class BackendIdSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyarmnn.BackendIdSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyarmnn.BackendIdSet___nonzero__(self)

    def __bool__(self):
        return _pyarmnn.BackendIdSet___bool__(self)

    def __len__(self):
        return _pyarmnn.BackendIdSet___len__(self)

    def append(self, x):
        return _pyarmnn.BackendIdSet_append(self, x)

    def __contains__(self, x):
        return _pyarmnn.BackendIdSet___contains__(self, x)

    def __getitem__(self, i):
        return _pyarmnn.BackendIdSet___getitem__(self, i)

    def __init__(self, *args):
        _pyarmnn.BackendIdSet_swiginit(self, _pyarmnn.new_BackendIdSet(*args))

    def empty(self):
        return _pyarmnn.BackendIdSet_empty(self)

    def size(self):
        return _pyarmnn.BackendIdSet_size(self)

    def clear(self):
        return _pyarmnn.BackendIdSet_clear(self)

    def swap(self, v):
        return _pyarmnn.BackendIdSet_swap(self, v)

    def count(self, x):
        return _pyarmnn.BackendIdSet_count(self, x)

    def begin(self):
        return _pyarmnn.BackendIdSet_begin(self)

    def end(self):
        return _pyarmnn.BackendIdSet_end(self)

    def erase(self, *args):
        return _pyarmnn.BackendIdSet_erase(self, *args)

    def find(self, x):
        return _pyarmnn.BackendIdSet_find(self, x)

    def equal_range(self, x):
        return _pyarmnn.BackendIdSet_equal_range(self, x)

    def insert(self, __x):
        return _pyarmnn.BackendIdSet_insert(self, __x)
    __swig_destroy__ = _pyarmnn.delete_BackendIdSet

# Register BackendIdSet in _pyarmnn:
_pyarmnn.BackendIdSet_swigregister(BackendIdSet)

class BackendId(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, id):
        r"""

        Creates backend id instance.
        Supported backend ids: 'CpuRef', 'CpuAcc', 'GpuAcc', 'EthosNAcc'.

        Args:
            id (str): Computation backend identification.

        """
        _pyarmnn.BackendId_swiginit(self, _pyarmnn.new_BackendId(id))

    def IsCpuRef(self):
        r"""

        Checks if backend is cpu reference implementation.
        Returns:
            bool: True if backend supports cpu reference implementation, False otherwise.


        """
        return _pyarmnn.BackendId_IsCpuRef(self)

    def Get(self):
        r"""

        Returns backend identification.

        >>> backendId = BackendId('CpuRef')
        >>> assert 'CpuRef' == str(backendId)
        >>> assert 'CpuRef' == backendId.Get()

        Returns:
            str: Backend identification.


        """
        return _pyarmnn.BackendId_Get(self)

    def __str__(self):
        return _pyarmnn.BackendId___str__(self)
    __swig_destroy__ = _pyarmnn.delete_BackendId

# Register BackendId in _pyarmnn:
_pyarmnn.BackendId_swigregister(BackendId)

class PermutationVector(object):
    r"""

    Vector used to permute a tensor.

    For a 4-d tensor laid out in a memory with the format (Batch Element, Height, Width, Channels),
    which is to be passed as an input to Arm NN, each source dimension is mapped to the corresponding
    Arm NN dimension. The Batch dimension remains the same (0 -> 0). The source Height dimension is mapped
    to the location of the Arm NN Height dimension (1 -> 2). Similar arguments are made for the Width and
    Channels (2 -> 3 and 3 -> 1). This will lead to m_DimMappings pointing to the following array:
    [ 0, 2, 3, 1 ].

    Note that the mapping should be reversed if considering the case of Arm NN 4-d outputs (Batch Element,
    Channels, Height, Width) being written to a destination with the format mentioned above. We now have
    0 -> 0, 2 -> 1, 3 -> 2, 1 -> 3, which, when reordered, lead to the following m_DimMappings contents:
    [ 0, 3, 1, 2 ].

    Args:
        dimMappings (list): Indicates how to translate tensor elements from a given source into the target destination,
                            when source and target potentially have different memory layouts.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dimMappings):
        _pyarmnn.PermutationVector_swiginit(self, _pyarmnn.new_PermutationVector(dimMappings))

    def GetSize(self):
        r"""

        Get the PermutationVector size.

        Return:
            SizeType: Current size of the PermutationVector.


        """
        return _pyarmnn.PermutationVector_GetSize(self)

    def IsInverse(self, other):
        r"""

        Checks if a specified permutation vector is its inverse

        Return:
            bool: returns true if the specified Permutation vector is its inverse.


        """
        return _pyarmnn.PermutationVector_IsInverse(self, other)

    def __getitem__(self, i):
        return _pyarmnn.PermutationVector___getitem__(self, i)

    def __eq__(self, other):
        return _pyarmnn.PermutationVector___eq__(self, other)
    __swig_destroy__ = _pyarmnn.delete_PermutationVector

# Register PermutationVector in _pyarmnn:
_pyarmnn.PermutationVector_swigregister(PermutationVector)

Status_Success = _pyarmnn.Status_Success
Status_Failure = _pyarmnn.Status_Failure
DataType_Float16 = _pyarmnn.DataType_Float16
DataType_Float32 = _pyarmnn.DataType_Float32
DataType_QAsymmU8 = _pyarmnn.DataType_QAsymmU8
DataType_Signed32 = _pyarmnn.DataType_Signed32
DataType_Boolean = _pyarmnn.DataType_Boolean
DataType_QSymmS16 = _pyarmnn.DataType_QSymmS16
DataType_QuantizedSymm8PerAxis = _pyarmnn.DataType_QuantizedSymm8PerAxis
DataType_QSymmS8 = _pyarmnn.DataType_QSymmS8
DataType_QAsymmS8 = _pyarmnn.DataType_QAsymmS8
DataType_QuantisedAsymm8 = _pyarmnn.DataType_QuantisedAsymm8
DataType_QuantisedSymm16 = _pyarmnn.DataType_QuantisedSymm16
DataLayout_NCHW = _pyarmnn.DataLayout_NCHW
DataLayout_NHWC = _pyarmnn.DataLayout_NHWC
ActivationFunction_Sigmoid = _pyarmnn.ActivationFunction_Sigmoid
ActivationFunction_TanH = _pyarmnn.ActivationFunction_TanH
ActivationFunction_Linear = _pyarmnn.ActivationFunction_Linear
ActivationFunction_ReLu = _pyarmnn.ActivationFunction_ReLu
ActivationFunction_BoundedReLu = _pyarmnn.ActivationFunction_BoundedReLu
ActivationFunction_SoftReLu = _pyarmnn.ActivationFunction_SoftReLu
ActivationFunction_LeakyReLu = _pyarmnn.ActivationFunction_LeakyReLu
ActivationFunction_Abs = _pyarmnn.ActivationFunction_Abs
ActivationFunction_Sqrt = _pyarmnn.ActivationFunction_Sqrt
ActivationFunction_Square = _pyarmnn.ActivationFunction_Square
ArgMinMaxFunction_Min = _pyarmnn.ArgMinMaxFunction_Min
ArgMinMaxFunction_Max = _pyarmnn.ArgMinMaxFunction_Max
ComparisonOperation_Equal = _pyarmnn.ComparisonOperation_Equal
ComparisonOperation_Greater = _pyarmnn.ComparisonOperation_Greater
ComparisonOperation_GreaterOrEqual = _pyarmnn.ComparisonOperation_GreaterOrEqual
ComparisonOperation_Less = _pyarmnn.ComparisonOperation_Less
ComparisonOperation_LessOrEqual = _pyarmnn.ComparisonOperation_LessOrEqual
ComparisonOperation_NotEqual = _pyarmnn.ComparisonOperation_NotEqual
UnaryOperation_Abs = _pyarmnn.UnaryOperation_Abs
UnaryOperation_Exp = _pyarmnn.UnaryOperation_Exp
UnaryOperation_Sqrt = _pyarmnn.UnaryOperation_Sqrt
UnaryOperation_Rsqrt = _pyarmnn.UnaryOperation_Rsqrt
UnaryOperation_Neg = _pyarmnn.UnaryOperation_Neg
PoolingAlgorithm_Max = _pyarmnn.PoolingAlgorithm_Max
PoolingAlgorithm_Average = _pyarmnn.PoolingAlgorithm_Average
PoolingAlgorithm_L2 = _pyarmnn.PoolingAlgorithm_L2
ResizeMethod_Bilinear = _pyarmnn.ResizeMethod_Bilinear
ResizeMethod_NearestNeighbor = _pyarmnn.ResizeMethod_NearestNeighbor
PaddingMethod_IgnoreValue = _pyarmnn.PaddingMethod_IgnoreValue
PaddingMethod_Exclude = _pyarmnn.PaddingMethod_Exclude
NormalizationAlgorithmChannel_Across = _pyarmnn.NormalizationAlgorithmChannel_Across
NormalizationAlgorithmChannel_Within = _pyarmnn.NormalizationAlgorithmChannel_Within
NormalizationAlgorithmMethod_LocalBrightness = _pyarmnn.NormalizationAlgorithmMethod_LocalBrightness
NormalizationAlgorithmMethod_LocalContrast = _pyarmnn.NormalizationAlgorithmMethod_LocalContrast
OutputShapeRounding_Floor = _pyarmnn.OutputShapeRounding_Floor
OutputShapeRounding_Ceiling = _pyarmnn.OutputShapeRounding_Ceiling
class IBackend(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetId(self):
        return _pyarmnn.IBackend_GetId(self)

# Register IBackend in _pyarmnn:
_pyarmnn.IBackend_swigregister(IBackend)
MaxNumOfTensorDimensions = cvar.MaxNumOfTensorDimensions
LOWEST_CAPTURE_PERIOD = cvar.LOWEST_CAPTURE_PERIOD

class IDeviceSpec(object):
    r"""

    Interface for device specifications. Main use is to get information relating to what compute capability the device being used has.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetSupportedBackends(self):
        r"""

        Returns the backends supported by this compute device.

        Returns:
            set: This devices supported backends.


        """
        return _pyarmnn.IDeviceSpec_GetSupportedBackends(self)

    def __str__(self):
        return _pyarmnn.IDeviceSpec___str__(self)

# Register IDeviceSpec in _pyarmnn:
_pyarmnn.IDeviceSpec_swigregister(IDeviceSpec)

class ProfilingDynamicGuid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyarmnn.delete_ProfilingDynamicGuid

# Register ProfilingDynamicGuid in _pyarmnn:
_pyarmnn.ProfilingDynamicGuid_swigregister(ProfilingDynamicGuid)
MIN_STATIC_GUID = cvar.MIN_STATIC_GUID

class ProfilingStaticGuid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyarmnn.delete_ProfilingStaticGuid

# Register ProfilingStaticGuid in _pyarmnn:
_pyarmnn.ProfilingStaticGuid_swigregister(ProfilingStaticGuid)

class TensorShapeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyarmnn.TensorShapeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyarmnn.TensorShapeVector___nonzero__(self)

    def __bool__(self):
        return _pyarmnn.TensorShapeVector___bool__(self)

    def __len__(self):
        return _pyarmnn.TensorShapeVector___len__(self)

    def __getslice__(self, i, j):
        return _pyarmnn.TensorShapeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyarmnn.TensorShapeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyarmnn.TensorShapeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyarmnn.TensorShapeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyarmnn.TensorShapeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyarmnn.TensorShapeVector___setitem__(self, *args)

    def pop(self):
        return _pyarmnn.TensorShapeVector_pop(self)

    def append(self, x):
        return _pyarmnn.TensorShapeVector_append(self, x)

    def empty(self):
        return _pyarmnn.TensorShapeVector_empty(self)

    def size(self):
        return _pyarmnn.TensorShapeVector_size(self)

    def swap(self, v):
        return _pyarmnn.TensorShapeVector_swap(self, v)

    def begin(self):
        return _pyarmnn.TensorShapeVector_begin(self)

    def end(self):
        return _pyarmnn.TensorShapeVector_end(self)

    def rbegin(self):
        return _pyarmnn.TensorShapeVector_rbegin(self)

    def rend(self):
        return _pyarmnn.TensorShapeVector_rend(self)

    def clear(self):
        return _pyarmnn.TensorShapeVector_clear(self)

    def get_allocator(self):
        return _pyarmnn.TensorShapeVector_get_allocator(self)

    def pop_back(self):
        return _pyarmnn.TensorShapeVector_pop_back(self)

    def erase(self, *args):
        return _pyarmnn.TensorShapeVector_erase(self, *args)

    def __init__(self, *args):
        _pyarmnn.TensorShapeVector_swiginit(self, _pyarmnn.new_TensorShapeVector(*args))

    def push_back(self, x):
        return _pyarmnn.TensorShapeVector_push_back(self, x)

    def front(self):
        return _pyarmnn.TensorShapeVector_front(self)

    def back(self):
        return _pyarmnn.TensorShapeVector_back(self)

    def assign(self, n, x):
        return _pyarmnn.TensorShapeVector_assign(self, n, x)

    def resize(self, *args):
        return _pyarmnn.TensorShapeVector_resize(self, *args)

    def insert(self, *args):
        return _pyarmnn.TensorShapeVector_insert(self, *args)

    def reserve(self, n):
        return _pyarmnn.TensorShapeVector_reserve(self, n)

    def capacity(self):
        return _pyarmnn.TensorShapeVector_capacity(self)
    __swig_destroy__ = _pyarmnn.delete_TensorShapeVector

# Register TensorShapeVector in _pyarmnn:
_pyarmnn.TensorShapeVector_swigregister(TensorShapeVector)


def from_python_to_cpp(*args):
    return _pyarmnn.from_python_to_cpp(*args)

def from_cpp_to_python(*args):
    return _pyarmnn.from_cpp_to_python(*args)
class ActivationDescriptor(object):
    r"""

    A configuration for the Activation layer. See `INetwork.AddActivationLayer()`.

    Contains:
        m_Function (int): Specifies the activation function to use.
                          (`ActivationFunction_Sigmoid`, `ActivationFunction_TanH`, `ActivationFunction_Linear`,
                          `ActivationFunction_ReLu`, `ActivationFunction_BoundedReLu`, `ActivationFunction_SoftReLu`,
                          `ActivationFunction_LeakyReLu`, `ActivationFunction_Abs`, `ActivationFunction_Sqrt`,
                          `ActivationFunction_Square`).
                          Default: `ActivationFunction_Sigmoid`.
        m_A (float): Alpha upper bound value used by the activation functions. (`ActivationFunction_BoundedReLu`,
                      `ActivationFunction_Linear`, `ActivationFunction_TanH`). Default: 0.
        m_B (float): Beta lower bound value used by the activation functions. (`ActivationFunction_BoundedReLu`,
                      `ActivationFunction_Linear`, `ActivationFunction_TanH`). Default: 0.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.ActivationDescriptor_swiginit(self, _pyarmnn.new_ActivationDescriptor())
    m_Function = property(_pyarmnn.ActivationDescriptor_m_Function_get, _pyarmnn.ActivationDescriptor_m_Function_set)
    m_A = property(_pyarmnn.ActivationDescriptor_m_A_get, _pyarmnn.ActivationDescriptor_m_A_set)
    m_B = property(_pyarmnn.ActivationDescriptor_m_B_get, _pyarmnn.ActivationDescriptor_m_B_set)

    def __eq__(self, rhs):
        return _pyarmnn.ActivationDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_ActivationDescriptor

# Register ActivationDescriptor in _pyarmnn:
_pyarmnn.ActivationDescriptor_swigregister(ActivationDescriptor)

class ArgMinMaxDescriptor(object):
    r"""

    A descriptor for the ArgMinMax layer. See `INetwork.AddArgMinMaxLayer()`.

    Contains:
        m_Function (int): Specify if the function is to find Min or Max with `ArgMinMaxFunction_Min` or `ArgMinMaxFunction_Max`.
                          Default: `ArgMinMaxFunction_Min`.
        m_Axis (int): Axis to reduce across the input tensor. Default: -1.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.ArgMinMaxDescriptor_swiginit(self, _pyarmnn.new_ArgMinMaxDescriptor())
    m_Function = property(_pyarmnn.ArgMinMaxDescriptor_m_Function_get, _pyarmnn.ArgMinMaxDescriptor_m_Function_set)
    m_Axis = property(_pyarmnn.ArgMinMaxDescriptor_m_Axis_get, _pyarmnn.ArgMinMaxDescriptor_m_Axis_set)

    def __eq__(self, rhs):
        return _pyarmnn.ArgMinMaxDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_ArgMinMaxDescriptor

# Register ArgMinMaxDescriptor in _pyarmnn:
_pyarmnn.ArgMinMaxDescriptor_swigregister(ArgMinMaxDescriptor)

class BatchNormalizationDescriptor(object):
    r"""

    A descriptor for the BatchNormalization layer.  See `INetwork.AddBatchNormalizationLayer()`.

    Contains:
        m_Eps (float): Value to add to the variance. Used to avoid dividing by zero. Default: 0.0001.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.BatchNormalizationDescriptor_swiginit(self, _pyarmnn.new_BatchNormalizationDescriptor())
    m_Eps = property(_pyarmnn.BatchNormalizationDescriptor_m_Eps_get, _pyarmnn.BatchNormalizationDescriptor_m_Eps_set)
    m_DataLayout = property(_pyarmnn.BatchNormalizationDescriptor_m_DataLayout_get, _pyarmnn.BatchNormalizationDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.BatchNormalizationDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_BatchNormalizationDescriptor

# Register BatchNormalizationDescriptor in _pyarmnn:
_pyarmnn.BatchNormalizationDescriptor_swigregister(BatchNormalizationDescriptor)

class BatchToSpaceNdDescriptor(object):
    r"""

    A descriptor for the BatchToSpaceNd layer.  See `INetwork.AddBatchToSpaceNdLayer()`.

    Contains:
        m_BlockShape (list of int): Block shape values. Default: (1, 1). Underlying C++ type is unsigned int.
        m_Crops (list of tuple): The values to crop from the input dimension. Default: [(0, 0), (0, 0)].
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.BatchToSpaceNdDescriptor_swiginit(self, _pyarmnn.new_BatchToSpaceNdDescriptor(*args))
    m_BlockShape = property(_pyarmnn.BatchToSpaceNdDescriptor_m_BlockShape_get, _pyarmnn.BatchToSpaceNdDescriptor_m_BlockShape_set)
    m_Crops = property(_pyarmnn.BatchToSpaceNdDescriptor_m_Crops_get, _pyarmnn.BatchToSpaceNdDescriptor_m_Crops_set)
    m_DataLayout = property(_pyarmnn.BatchToSpaceNdDescriptor_m_DataLayout_get, _pyarmnn.BatchToSpaceNdDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.BatchToSpaceNdDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_BatchToSpaceNdDescriptor

# Register BatchToSpaceNdDescriptor in _pyarmnn:
_pyarmnn.BatchToSpaceNdDescriptor_swigregister(BatchToSpaceNdDescriptor)

class ComparisonDescriptor(object):
    r"""

    A descriptor for the Comparison layer.  See `INetwork.AddComparisonLayer()`.

    Contains:
        m_Operation (int): Specifies the comparison operation to execute.
                                           (`ComparisonOperation_Equal`, `ComparisonOperation_Greater`, `ComparisonOperation_GreaterOrEqual`,
                                           `ComparisonOperation_Less`, `ComparisonOperation_LessOrEqual`, `ComparisonOperation_NotEqual`)
                                           Default: `ComparisonOperation_Equal`.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.ComparisonDescriptor_swiginit(self, _pyarmnn.new_ComparisonDescriptor(*args))

    def __eq__(self, rhs):
        return _pyarmnn.ComparisonDescriptor___eq__(self, rhs)
    m_Operation = property(_pyarmnn.ComparisonDescriptor_m_Operation_get, _pyarmnn.ComparisonDescriptor_m_Operation_set)
    __swig_destroy__ = _pyarmnn.delete_ComparisonDescriptor

# Register ComparisonDescriptor in _pyarmnn:
_pyarmnn.ComparisonDescriptor_swigregister(ComparisonDescriptor)

class ConcatDescriptor(object):
    r"""

    Creates a configuration/descriptor for a Concatenation layer. See `INetwork.AddConcatLayer()`.
    Number of Views must be equal to the number of inputs, and their order must match e.g. first view corresponds to the first input, second view to the second input, etc.

    Contains:
        numViews (int): Number of views, the value  must be equal to the number of outputs of a layer.
        numDimensions (int): Number of dimensions. Default value is 4.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.ConcatDescriptor_swiginit(self, _pyarmnn.new_ConcatDescriptor(*args))

    def GetNumViews(self):
        r"""

        Get the number of views.
        Returns:
            int: Number of views.

        """
        return _pyarmnn.ConcatDescriptor_GetNumViews(self)

    def GetNumDimensions(self):
        r"""

        Get the number of dimensions.
        Returns:
            int: Number of dimensions.

        """
        return _pyarmnn.ConcatDescriptor_GetNumDimensions(self)

    def GetViewOrigin(self, idx):
        r"""

        Get the view origin input by index.

        Each view match the inputs order, e.g. first view corresponds to the first input, second view to the second input, etc.

        Args:
            idx (int): Index to get view from.

        Returns:
            list: View origin (shape) specified by the int value `idx` as a list of ints.

        """
        return _pyarmnn.ConcatDescriptor_GetViewOrigin(self, idx)

    def SetConcatAxis(self, concatAxis):
        r"""

        Set the concatenation dimension.
        Args:
            concatAxis (int): Concatenation axis index.

        """
        return _pyarmnn.ConcatDescriptor_SetConcatAxis(self, concatAxis)

    def GetConcatAxis(self):
        r"""

        Get the concatenation dimension.
        Returns:
            int: Concatenation axis index.

        """
        return _pyarmnn.ConcatDescriptor_GetConcatAxis(self)

    def __eq__(self, rhs):
        return _pyarmnn.ConcatDescriptor___eq__(self, rhs)

    def SetViewOriginCoord(self, view, coord, value):
        r"""

        Set the coordinates of a specific origin view input.

        Args:
            view (int): Origin view index.
            coord (int): Coordinate of the origin view to set.
            value (int): Value to set.
        Raises:
            RuntimeError: If the `view` is greater than or equal to GetNumViews().
            RuntimeError: If the `coord` is greater than or equal to GetNumDimensions().

        """
        return _pyarmnn.ConcatDescriptor_SetViewOriginCoord(self, view, coord, value)
    __swig_destroy__ = _pyarmnn.delete_ConcatDescriptor

# Register ConcatDescriptor in _pyarmnn:
_pyarmnn.ConcatDescriptor_swigregister(ConcatDescriptor)

class Convolution2dDescriptor(object):
    r"""

    A descriptor for the Convolution2d layer.  See `INetwork.AddConvolution2dLayer()`.

    Contains:
        m_PadLeft (int): Underlying C++ data type is uint32_t. Padding left value in the width dimension. Default: 0.
        m_PadRight (int): Underlying C++ data type is uint32_t. Padding right value in the width dimension. Default: 0.
        m_PadTop (int): Underlying C++ data type is uint32_t. Padding top value in the height dimension. Default: 0.
        m_PadBottom (int): Underlying C++ data type is uint32_t. Padding bottom value in the height dimension. Default: 0.
        m_StrideX (int): Underlying C++ data type is uint32_t. Stride value when proceeding through input for the width dimension. Default: 0.
        m_StrideY (int): Underlying C++ data type is uint32_t. Stride value when proceeding through input for the height dimension. Default: 0.
        m_DilationX (int): Underlying C++ data type is uint32_t. Dilation along x axis. Default: 1.
        m_DilationY (int): Underlying C++ data type is uint32_t. Dilation along y axis. Default: 1.
        m_BiasEnabled (bool): Enable/disable bias. Default: false.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.Convolution2dDescriptor_swiginit(self, _pyarmnn.new_Convolution2dDescriptor())
    m_PadLeft = property(_pyarmnn.Convolution2dDescriptor_m_PadLeft_get, _pyarmnn.Convolution2dDescriptor_m_PadLeft_set)
    m_PadRight = property(_pyarmnn.Convolution2dDescriptor_m_PadRight_get, _pyarmnn.Convolution2dDescriptor_m_PadRight_set)
    m_PadTop = property(_pyarmnn.Convolution2dDescriptor_m_PadTop_get, _pyarmnn.Convolution2dDescriptor_m_PadTop_set)
    m_PadBottom = property(_pyarmnn.Convolution2dDescriptor_m_PadBottom_get, _pyarmnn.Convolution2dDescriptor_m_PadBottom_set)
    m_StrideX = property(_pyarmnn.Convolution2dDescriptor_m_StrideX_get, _pyarmnn.Convolution2dDescriptor_m_StrideX_set)
    m_StrideY = property(_pyarmnn.Convolution2dDescriptor_m_StrideY_get, _pyarmnn.Convolution2dDescriptor_m_StrideY_set)
    m_DilationX = property(_pyarmnn.Convolution2dDescriptor_m_DilationX_get, _pyarmnn.Convolution2dDescriptor_m_DilationX_set)
    m_DilationY = property(_pyarmnn.Convolution2dDescriptor_m_DilationY_get, _pyarmnn.Convolution2dDescriptor_m_DilationY_set)
    m_BiasEnabled = property(_pyarmnn.Convolution2dDescriptor_m_BiasEnabled_get, _pyarmnn.Convolution2dDescriptor_m_BiasEnabled_set)
    m_DataLayout = property(_pyarmnn.Convolution2dDescriptor_m_DataLayout_get, _pyarmnn.Convolution2dDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.Convolution2dDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_Convolution2dDescriptor

# Register Convolution2dDescriptor in _pyarmnn:
_pyarmnn.Convolution2dDescriptor_swigregister(Convolution2dDescriptor)

class DepthToSpaceDescriptor(object):
    r"""

    A descriptor for the DepthToSpace layer.  See `INetwork.AddDepthToSpaceLayer()`.

    Contains:
        m_BlockSize (int): Underlying C++ type is `unsigned int`.  Scalar specifying the input block size. It must be >= 1. Default: 1.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NHWC`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.DepthToSpaceDescriptor_swiginit(self, _pyarmnn.new_DepthToSpaceDescriptor(*args))
    m_BlockSize = property(_pyarmnn.DepthToSpaceDescriptor_m_BlockSize_get, _pyarmnn.DepthToSpaceDescriptor_m_BlockSize_set)
    m_DataLayout = property(_pyarmnn.DepthToSpaceDescriptor_m_DataLayout_get, _pyarmnn.DepthToSpaceDescriptor_m_DataLayout_set)
    __swig_destroy__ = _pyarmnn.delete_DepthToSpaceDescriptor

# Register DepthToSpaceDescriptor in _pyarmnn:
_pyarmnn.DepthToSpaceDescriptor_swigregister(DepthToSpaceDescriptor)

class DepthwiseConvolution2dDescriptor(object):
    r"""

    A descriptor for the DepthwiseConvolution2d layer. See `INetwork.AddDepthwiseConvolution2dLayer()`.

    Contains:
        m_PadLeft (int): Underlying C++ data type is uint32_t. Padding left value in the width dimension. Default: 0.
        m_PadRight (int): Underlying C++ data type is uint32_t. Padding right value in the width dimension. Default: 0.
        m_PadTop (int): Underlying C++ data type is uint32_t. Padding top value in the height dimension. Default: 0.
        m_PadBottom (int): Underlying C++ data type is uint32_t. Padding bottom value in the height dimension. Default: 0.
        m_StrideX (int): Underlying C++ data type is uint32_t. Stride value when proceeding through input for the width dimension. Default: 0.
        m_StrideY (int): Underlying C++ data type is uint32_t. Stride value when proceeding through input for the height dimension. Default: 0.
        m_DilationX (int): Underlying C++ data type is uint32_t. Dilation along x axis. Default: 1.
        m_DilationY (int): Underlying C++ data type is uint32_t. Dilation along y axis. Default: 1.
        m_BiasEnabled (bool): Enable/disable bias. Default: false.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.DepthwiseConvolution2dDescriptor_swiginit(self, _pyarmnn.new_DepthwiseConvolution2dDescriptor())
    m_PadLeft = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_PadLeft_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_PadLeft_set)
    m_PadRight = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_PadRight_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_PadRight_set)
    m_PadTop = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_PadTop_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_PadTop_set)
    m_PadBottom = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_PadBottom_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_PadBottom_set)
    m_StrideX = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_StrideX_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_StrideX_set)
    m_StrideY = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_StrideY_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_StrideY_set)
    m_DilationX = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_DilationX_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_DilationX_set)
    m_DilationY = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_DilationY_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_DilationY_set)
    m_BiasEnabled = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_BiasEnabled_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_BiasEnabled_set)
    m_DataLayout = property(_pyarmnn.DepthwiseConvolution2dDescriptor_m_DataLayout_get, _pyarmnn.DepthwiseConvolution2dDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.DepthwiseConvolution2dDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_DepthwiseConvolution2dDescriptor

# Register DepthwiseConvolution2dDescriptor in _pyarmnn:
_pyarmnn.DepthwiseConvolution2dDescriptor_swigregister(DepthwiseConvolution2dDescriptor)

class DetectionPostProcessDescriptor(object):
    r"""

    A descriptor for the DetectionPostProcess layer. See `INetwork.AddDetectionPostProcessLayer()`.

    This layer is a custom layer used to process the output from SSD MobilenetV1.

    Contains:
        m_MaxDetections (int): Underlying C++ data type is uint32_t. Maximum numbers of detections. Default: 0.
        m_MaxClassesPerDetection (int): Underlying C++ data type is uint32_t. Maximum numbers of classes per detection, used in Fast NMS. Default: 1.
        m_DetectionsPerClass (int): Underlying C++ data type is uint32_t. Detections per classes, used in Regular NMS. Default: 1.
        m_NmsScoreThreshold (float): Non maximum suppression score threshold. Default: 0.
        m_NmsIouThreshold (float): Intersection over union threshold. Default: 0.
        m_NumClasses (int): Underlying C++ data type is uint32_t. Number of classes. Default: 0.
        m_UseRegularNms (bool): Use Regular Non maximum suppression. Default: false.
        m_ScaleX (float): Center size encoding scale x. Default: 0.
        m_ScaleY (float): Center size encoding scale y. Default: 0.
        m_ScaleW (float): Center size encoding scale weight. Default: 0.
        m_ScaleH (float): Center size encoding scale height. Default: 0.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.DetectionPostProcessDescriptor_swiginit(self, _pyarmnn.new_DetectionPostProcessDescriptor())
    m_MaxDetections = property(_pyarmnn.DetectionPostProcessDescriptor_m_MaxDetections_get, _pyarmnn.DetectionPostProcessDescriptor_m_MaxDetections_set)
    m_MaxClassesPerDetection = property(_pyarmnn.DetectionPostProcessDescriptor_m_MaxClassesPerDetection_get, _pyarmnn.DetectionPostProcessDescriptor_m_MaxClassesPerDetection_set)
    m_DetectionsPerClass = property(_pyarmnn.DetectionPostProcessDescriptor_m_DetectionsPerClass_get, _pyarmnn.DetectionPostProcessDescriptor_m_DetectionsPerClass_set)
    m_NmsScoreThreshold = property(_pyarmnn.DetectionPostProcessDescriptor_m_NmsScoreThreshold_get, _pyarmnn.DetectionPostProcessDescriptor_m_NmsScoreThreshold_set)
    m_NmsIouThreshold = property(_pyarmnn.DetectionPostProcessDescriptor_m_NmsIouThreshold_get, _pyarmnn.DetectionPostProcessDescriptor_m_NmsIouThreshold_set)
    m_NumClasses = property(_pyarmnn.DetectionPostProcessDescriptor_m_NumClasses_get, _pyarmnn.DetectionPostProcessDescriptor_m_NumClasses_set)
    m_UseRegularNms = property(_pyarmnn.DetectionPostProcessDescriptor_m_UseRegularNms_get, _pyarmnn.DetectionPostProcessDescriptor_m_UseRegularNms_set)
    m_ScaleX = property(_pyarmnn.DetectionPostProcessDescriptor_m_ScaleX_get, _pyarmnn.DetectionPostProcessDescriptor_m_ScaleX_set)
    m_ScaleY = property(_pyarmnn.DetectionPostProcessDescriptor_m_ScaleY_get, _pyarmnn.DetectionPostProcessDescriptor_m_ScaleY_set)
    m_ScaleW = property(_pyarmnn.DetectionPostProcessDescriptor_m_ScaleW_get, _pyarmnn.DetectionPostProcessDescriptor_m_ScaleW_set)
    m_ScaleH = property(_pyarmnn.DetectionPostProcessDescriptor_m_ScaleH_get, _pyarmnn.DetectionPostProcessDescriptor_m_ScaleH_set)

    def __eq__(self, rhs):
        return _pyarmnn.DetectionPostProcessDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_DetectionPostProcessDescriptor

# Register DetectionPostProcessDescriptor in _pyarmnn:
_pyarmnn.DetectionPostProcessDescriptor_swigregister(DetectionPostProcessDescriptor)

class FakeQuantizationDescriptor(object):
    r"""

    A descriptor for the FakeQuantization layer.

    Contains:
        m_Min (float): Minimum value for quantization range. Default: -6.0.
        m_Max (float): Maximum value for quantization range. Default: 6.0.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.FakeQuantizationDescriptor_swiginit(self, _pyarmnn.new_FakeQuantizationDescriptor())
    m_Min = property(_pyarmnn.FakeQuantizationDescriptor_m_Min_get, _pyarmnn.FakeQuantizationDescriptor_m_Min_set)
    m_Max = property(_pyarmnn.FakeQuantizationDescriptor_m_Max_get, _pyarmnn.FakeQuantizationDescriptor_m_Max_set)

    def __eq__(self, rhs):
        return _pyarmnn.FakeQuantizationDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_FakeQuantizationDescriptor

# Register FakeQuantizationDescriptor in _pyarmnn:
_pyarmnn.FakeQuantizationDescriptor_swigregister(FakeQuantizationDescriptor)

class FullyConnectedDescriptor(object):
    r"""

    A descriptor for the FullyConnected layer. See `INetwork.AddFullyConnectedLayer()`.

    Contains:
        m_BiasEnabled (bool): Enable/disable bias. Default: false.
        m_TransposeWeightMatrix (bool): Enable/disable transpose weight matrix. Default: false.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.FullyConnectedDescriptor_swiginit(self, _pyarmnn.new_FullyConnectedDescriptor())
    m_BiasEnabled = property(_pyarmnn.FullyConnectedDescriptor_m_BiasEnabled_get, _pyarmnn.FullyConnectedDescriptor_m_BiasEnabled_set)
    m_TransposeWeightMatrix = property(_pyarmnn.FullyConnectedDescriptor_m_TransposeWeightMatrix_get, _pyarmnn.FullyConnectedDescriptor_m_TransposeWeightMatrix_set)

    def __eq__(self, rhs):
        return _pyarmnn.FullyConnectedDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_FullyConnectedDescriptor

# Register FullyConnectedDescriptor in _pyarmnn:
_pyarmnn.FullyConnectedDescriptor_swigregister(FullyConnectedDescriptor)

class InstanceNormalizationDescriptor(object):
    r"""

    A descriptor for InstanceNormalization layer. See `INetwork.AddInstanceNormalizationLayer()`.

    Contains:
        m_Gamma (float): Gamma, the scale scalar value applied for the normalized tensor. Default: 1.0.
        m_Gamma (float): Beta, the offset scalar value applied for the normalized tensor. Default: 0.0.
        m_Gamma (float): Epsilon, small scalar value added to variance to avoid dividing by zero. Default: 1e-12.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.InstanceNormalizationDescriptor_swiginit(self, _pyarmnn.new_InstanceNormalizationDescriptor())
    m_Gamma = property(_pyarmnn.InstanceNormalizationDescriptor_m_Gamma_get, _pyarmnn.InstanceNormalizationDescriptor_m_Gamma_set)
    m_Beta = property(_pyarmnn.InstanceNormalizationDescriptor_m_Beta_get, _pyarmnn.InstanceNormalizationDescriptor_m_Beta_set)
    m_Eps = property(_pyarmnn.InstanceNormalizationDescriptor_m_Eps_get, _pyarmnn.InstanceNormalizationDescriptor_m_Eps_set)
    m_DataLayout = property(_pyarmnn.InstanceNormalizationDescriptor_m_DataLayout_get, _pyarmnn.InstanceNormalizationDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.InstanceNormalizationDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_InstanceNormalizationDescriptor

# Register InstanceNormalizationDescriptor in _pyarmnn:
_pyarmnn.InstanceNormalizationDescriptor_swigregister(InstanceNormalizationDescriptor)

class LstmDescriptor(object):
    r"""

    A descriptor for the LSTM layer. See `INetwork.AddLstmLayer()`.

    Contains:
        m_ActivationFunc (int): Underlying C++ data type is uint32_t. The activation function to use. 0: None, 1: Relu, 3: Relu6, 4: Tanh, 6: Sigmoid.
                                     Default: 1.
        m_ClippingThresCell (float): Clipping threshold value for the cell state. Default: 0.0.
        m_ClippingThresProj (float): Clipping threshold value for the projection. Default: 0.0.
        m_CifgEnabled (bool): Enable/disable cifg (coupled input & forget gate). Default: true.
        m_PeepholeEnabled (bool): Enable/disable peephole. Default: false.
        m_ProjectionEnabled (bool): Enable/disable the projection layer. Default: false.
        m_LayerNormEnabled (bool): Enable/disable layer normalization. Default: false.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.LstmDescriptor_swiginit(self, _pyarmnn.new_LstmDescriptor())
    m_ActivationFunc = property(_pyarmnn.LstmDescriptor_m_ActivationFunc_get, _pyarmnn.LstmDescriptor_m_ActivationFunc_set)
    m_ClippingThresCell = property(_pyarmnn.LstmDescriptor_m_ClippingThresCell_get, _pyarmnn.LstmDescriptor_m_ClippingThresCell_set)
    m_ClippingThresProj = property(_pyarmnn.LstmDescriptor_m_ClippingThresProj_get, _pyarmnn.LstmDescriptor_m_ClippingThresProj_set)
    m_CifgEnabled = property(_pyarmnn.LstmDescriptor_m_CifgEnabled_get, _pyarmnn.LstmDescriptor_m_CifgEnabled_set)
    m_PeepholeEnabled = property(_pyarmnn.LstmDescriptor_m_PeepholeEnabled_get, _pyarmnn.LstmDescriptor_m_PeepholeEnabled_set)
    m_ProjectionEnabled = property(_pyarmnn.LstmDescriptor_m_ProjectionEnabled_get, _pyarmnn.LstmDescriptor_m_ProjectionEnabled_set)
    m_LayerNormEnabled = property(_pyarmnn.LstmDescriptor_m_LayerNormEnabled_get, _pyarmnn.LstmDescriptor_m_LayerNormEnabled_set)

    def __eq__(self, rhs):
        return _pyarmnn.LstmDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_LstmDescriptor

# Register LstmDescriptor in _pyarmnn:
_pyarmnn.LstmDescriptor_swigregister(LstmDescriptor)

class L2NormalizationDescriptor(object):
    r"""

    A Descriptor for the L2Normalization layer. See `INetwork.AddL2NormalizationLayer()`.

    Contains:
        m_Eps (float): Used to avoid dividing by zero. Default: 1e-12.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.L2NormalizationDescriptor_swiginit(self, _pyarmnn.new_L2NormalizationDescriptor())
    m_Eps = property(_pyarmnn.L2NormalizationDescriptor_m_Eps_get, _pyarmnn.L2NormalizationDescriptor_m_Eps_set)
    m_DataLayout = property(_pyarmnn.L2NormalizationDescriptor_m_DataLayout_get, _pyarmnn.L2NormalizationDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.L2NormalizationDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_L2NormalizationDescriptor

# Register L2NormalizationDescriptor in _pyarmnn:
_pyarmnn.L2NormalizationDescriptor_swigregister(L2NormalizationDescriptor)

class MeanDescriptor(object):
    r"""

    A descriptor for the Mean layer. See `INetwork.AddMeanLayer()`.

    Contains:
        m_Axis (list of int): Underlying C++ data type is std::vector<unsigned int>. Used to avoid dividing by zero. Values for the dimensions to reduce.
        m_KeepDims (bool): Enable/disable keep dimensions. If true, then the reduced dimensions that are of length 1 are kept. Default: False.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.MeanDescriptor_swiginit(self, _pyarmnn.new_MeanDescriptor(*args))
    m_Axis = property(_pyarmnn.MeanDescriptor_m_Axis_get, _pyarmnn.MeanDescriptor_m_Axis_set)
    m_KeepDims = property(_pyarmnn.MeanDescriptor_m_KeepDims_get, _pyarmnn.MeanDescriptor_m_KeepDims_set)

    def __eq__(self, rhs):
        return _pyarmnn.MeanDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_MeanDescriptor

# Register MeanDescriptor in _pyarmnn:
_pyarmnn.MeanDescriptor_swigregister(MeanDescriptor)

class NormalizationDescriptor(object):
    r"""

    A descriptor for the Normalization layer. See `INetwork.AddNormalizationLayer()`.

    Contains:
        m_NormChannelType (int): Normalization channel algorithm to use (`NormalizationAlgorithmMethod_Across`, `NormalizationAlgorithmMethod_Within`).
                                                           Default: `NormalizationAlgorithmChannel_Across`.
        m_NormMethodType (int): Normalization method algorithm to use (`NormalizationAlgorithmMethod_LocalBrightness`, `NormalizationAlgorithmMethod_LocalContrast`).
                                                         Default: `NormalizationAlgorithmMethod_LocalBrightness`.
        m_NormSize (int): Underlying C++ data type is uint32_t. Depth radius value. Default: 0.
        m_Alpha (float): Alpha value for the normalization equation. Default: 0.0.
        m_Beta (float): Beta value for the normalization equation. Default: 0.0.
        m_K (float): Kappa value used for the across channel normalization equation. Default: 0.0.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.NormalizationDescriptor_swiginit(self, _pyarmnn.new_NormalizationDescriptor())
    m_NormChannelType = property(_pyarmnn.NormalizationDescriptor_m_NormChannelType_get, _pyarmnn.NormalizationDescriptor_m_NormChannelType_set)
    m_NormMethodType = property(_pyarmnn.NormalizationDescriptor_m_NormMethodType_get, _pyarmnn.NormalizationDescriptor_m_NormMethodType_set)
    m_NormSize = property(_pyarmnn.NormalizationDescriptor_m_NormSize_get, _pyarmnn.NormalizationDescriptor_m_NormSize_set)
    m_Alpha = property(_pyarmnn.NormalizationDescriptor_m_Alpha_get, _pyarmnn.NormalizationDescriptor_m_Alpha_set)
    m_Beta = property(_pyarmnn.NormalizationDescriptor_m_Beta_get, _pyarmnn.NormalizationDescriptor_m_Beta_set)
    m_K = property(_pyarmnn.NormalizationDescriptor_m_K_get, _pyarmnn.NormalizationDescriptor_m_K_set)
    m_DataLayout = property(_pyarmnn.NormalizationDescriptor_m_DataLayout_get, _pyarmnn.NormalizationDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.NormalizationDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_NormalizationDescriptor

# Register NormalizationDescriptor in _pyarmnn:
_pyarmnn.NormalizationDescriptor_swigregister(NormalizationDescriptor)

class PadDescriptor(object):
    r"""

    A descriptor for the Pad layer. See `INetwork.AddPadLayer()`.

    Contains:
        m_PadList (list of tuple): specifies the padding for input dimension.
                                   The first tuple value is the number of values to add before the tensor in the dimension.
                                   The second tuple value is the number of values to add after the tensor in the dimension.
                                   The number of pairs should match the number of dimensions in the input tensor.
        m_PadValue (bool): Optional value to use for padding. Default: 0.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.PadDescriptor_swiginit(self, _pyarmnn.new_PadDescriptor(*args))
    m_PadList = property(_pyarmnn.PadDescriptor_m_PadList_get, _pyarmnn.PadDescriptor_m_PadList_set)
    m_PadValue = property(_pyarmnn.PadDescriptor_m_PadValue_get, _pyarmnn.PadDescriptor_m_PadValue_set)

    def __eq__(self, rhs):
        return _pyarmnn.PadDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_PadDescriptor

# Register PadDescriptor in _pyarmnn:
_pyarmnn.PadDescriptor_swigregister(PadDescriptor)

class ElementwiseUnaryDescriptor(object):
    r"""

    A descriptor for the ElementwiseUnary layer. See `INetwork.AddElementwiseUnaryLayer()`.

    Contains:
        m_Operation (int): Indicates which Unary operation to use. (`UnaryOperation_Abs`, `UnaryOperation_Exp`,
                           `UnaryOperation_Neg`, `UnaryOperation_Rsqrt`, `UnaryOperation_Sqrt`)
                           Default: `UnaryOperation_Abs`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.ElementwiseUnaryDescriptor_swiginit(self, _pyarmnn.new_ElementwiseUnaryDescriptor(*args))
    m_Operation = property(_pyarmnn.ElementwiseUnaryDescriptor_m_Operation_get, _pyarmnn.ElementwiseUnaryDescriptor_m_Operation_set)

    def __eq__(self, rhs):
        return _pyarmnn.ElementwiseUnaryDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_ElementwiseUnaryDescriptor

# Register ElementwiseUnaryDescriptor in _pyarmnn:
_pyarmnn.ElementwiseUnaryDescriptor_swigregister(ElementwiseUnaryDescriptor)

class PermuteDescriptor(object):
    r"""

    A descriptor for the Permute layer. See `INetwork.AddPermuteLayer()`.

    Contains:
        m_DimMappings (PermutationVector): Indicates how to translate tensor elements from a given source into the target destination,
                                           when source and target potentially have different memory layouts e.g. {0U, 3U, 1U, 2U}.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.PermuteDescriptor_swiginit(self, _pyarmnn.new_PermuteDescriptor(*args))
    m_DimMappings = property(_pyarmnn.PermuteDescriptor_m_DimMappings_get, _pyarmnn.PermuteDescriptor_m_DimMappings_set)

    def __eq__(self, rhs):
        return _pyarmnn.PermuteDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_PermuteDescriptor

# Register PermuteDescriptor in _pyarmnn:
_pyarmnn.PermuteDescriptor_swigregister(PermuteDescriptor)

class Pooling2dDescriptor(object):
    r"""

    A descriptor for the Pooling2d layer. See `INetwork.AddPooling2dLayer()`.

    Contains:
        m_PoolType (int): The pooling algorithm to use (`PoolingAlgorithm_Max`, `PoolingAlgorithm_Average`, `PoolingAlgorithm_L2`). Default: `PoolingAlgorithm_Max`.
        m_PadLeft (int): Underlying C++ data type is uint32_t. Padding left value in the width dimension. Default: 0.
        m_PadRight (int): Underlying C++ data type is uint32_t. Padding right value in the width dimension. Default: 0.
        m_PadTop (int): Underlying C++ data type is uint32_t. Padding top value in the height dimension. Default: 0.
        m_PadBottom (int): Underlying C++ data type is uint32_t. Padding bottom value in the height dimension. Default: 0.
        m_PoolWidth (int): Underlying C++ data type is uint32_t. Pooling width value. Default: 0.
        m_PoolHeight (int): Underlying C++ data type is uint32_t. Pooling height value. Default: 0.
        m_StrideX (int): Underlying C++ data type is uint32_t. Stride value when proceeding through input for the width dimension. Default: 0.
        m_StrideY (int): Underlying C++ data type is uint32_t. Stride value when proceeding through input for the height dimension. Default: 0.
        m_OutputShapeRounding (int):  The rounding method for the output shape. (`OutputShapeRounding_Floor`, `OutputShapeRounding_Ceiling`).
                                                      Default: `OutputShapeRounding_Floor`.
        m_PaddingMethod (int): The padding method to be used. (`PaddingMethod_Exclude`, `PaddingMethod_IgnoreValue`).
                                         Default: `PaddingMethod_Exclude`.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.Pooling2dDescriptor_swiginit(self, _pyarmnn.new_Pooling2dDescriptor())
    m_PoolType = property(_pyarmnn.Pooling2dDescriptor_m_PoolType_get, _pyarmnn.Pooling2dDescriptor_m_PoolType_set)
    m_PadLeft = property(_pyarmnn.Pooling2dDescriptor_m_PadLeft_get, _pyarmnn.Pooling2dDescriptor_m_PadLeft_set)
    m_PadRight = property(_pyarmnn.Pooling2dDescriptor_m_PadRight_get, _pyarmnn.Pooling2dDescriptor_m_PadRight_set)
    m_PadTop = property(_pyarmnn.Pooling2dDescriptor_m_PadTop_get, _pyarmnn.Pooling2dDescriptor_m_PadTop_set)
    m_PadBottom = property(_pyarmnn.Pooling2dDescriptor_m_PadBottom_get, _pyarmnn.Pooling2dDescriptor_m_PadBottom_set)
    m_PoolWidth = property(_pyarmnn.Pooling2dDescriptor_m_PoolWidth_get, _pyarmnn.Pooling2dDescriptor_m_PoolWidth_set)
    m_PoolHeight = property(_pyarmnn.Pooling2dDescriptor_m_PoolHeight_get, _pyarmnn.Pooling2dDescriptor_m_PoolHeight_set)
    m_StrideX = property(_pyarmnn.Pooling2dDescriptor_m_StrideX_get, _pyarmnn.Pooling2dDescriptor_m_StrideX_set)
    m_StrideY = property(_pyarmnn.Pooling2dDescriptor_m_StrideY_get, _pyarmnn.Pooling2dDescriptor_m_StrideY_set)
    m_OutputShapeRounding = property(_pyarmnn.Pooling2dDescriptor_m_OutputShapeRounding_get, _pyarmnn.Pooling2dDescriptor_m_OutputShapeRounding_set)
    m_PaddingMethod = property(_pyarmnn.Pooling2dDescriptor_m_PaddingMethod_get, _pyarmnn.Pooling2dDescriptor_m_PaddingMethod_set)
    m_DataLayout = property(_pyarmnn.Pooling2dDescriptor_m_DataLayout_get, _pyarmnn.Pooling2dDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.Pooling2dDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_Pooling2dDescriptor

# Register Pooling2dDescriptor in _pyarmnn:
_pyarmnn.Pooling2dDescriptor_swigregister(Pooling2dDescriptor)

class ReshapeDescriptor(object):
    r"""

    A descriptor for the Reshape layer. See `INetwork.AddReshapeLayer()`.

    Contains:
        m_TargetShape (TensorShape): Target shape value.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.ReshapeDescriptor_swiginit(self, _pyarmnn.new_ReshapeDescriptor(*args))
    m_TargetShape = property(_pyarmnn.ReshapeDescriptor_m_TargetShape_get, _pyarmnn.ReshapeDescriptor_m_TargetShape_set)

    def __eq__(self, rhs):
        return _pyarmnn.ReshapeDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_ReshapeDescriptor

# Register ReshapeDescriptor in _pyarmnn:
_pyarmnn.ReshapeDescriptor_swigregister(ReshapeDescriptor)

class ResizeDescriptor(object):
    r"""

    A descriptor for the Resize layer. See `INetwork.AddResizeLayer()`.

    Contains:
        m_TargetWidth (int): Underlying C++ data type is uint32_t. Target width value. Default: 0.
        m_TargetHeight (int): Underlying C++ data type is uint32_t. Target height value. Default: 0.
        m_Method (int): The Interpolation method to use (`ResizeMethod_Bilinear`, `ResizeMethod_NearestNeighbor`).
                        Default: `ResizeMethod_NearestNeighbor`.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.
        m_BilinearAlignCorners (bool):  Align corners or not when resizing bilinearly. If True, corner pixel values are preserved after resizing.
                                        Default: False


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.ResizeDescriptor_swiginit(self, _pyarmnn.new_ResizeDescriptor())
    m_TargetWidth = property(_pyarmnn.ResizeDescriptor_m_TargetWidth_get, _pyarmnn.ResizeDescriptor_m_TargetWidth_set)
    m_TargetHeight = property(_pyarmnn.ResizeDescriptor_m_TargetHeight_get, _pyarmnn.ResizeDescriptor_m_TargetHeight_set)
    m_Method = property(_pyarmnn.ResizeDescriptor_m_Method_get, _pyarmnn.ResizeDescriptor_m_Method_set)
    m_DataLayout = property(_pyarmnn.ResizeDescriptor_m_DataLayout_get, _pyarmnn.ResizeDescriptor_m_DataLayout_set)
    m_BilinearAlignCorners = property(_pyarmnn.ResizeDescriptor_m_BilinearAlignCorners_get, _pyarmnn.ResizeDescriptor_m_BilinearAlignCorners_set)

    def __eq__(self, rhs):
        return _pyarmnn.ResizeDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_ResizeDescriptor

# Register ResizeDescriptor in _pyarmnn:
_pyarmnn.ResizeDescriptor_swigregister(ResizeDescriptor)

class SliceDescriptor(object):
    r"""

    A descriptor for the Slice layer. See `INetwork.AddSliceLayer()`.

    Contains:
        m_Begin (list of int): Underlying C++ data type is std::vector<unsigned int>. Beginning indices of the slice in each dimension.
        m_Size (list of int): Underlying C++ data type is std::vector<unsigned int>. Size of the slice in each dimension.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.SliceDescriptor_swiginit(self, _pyarmnn.new_SliceDescriptor(*args))
    m_Begin = property(_pyarmnn.SliceDescriptor_m_Begin_get, _pyarmnn.SliceDescriptor_m_Begin_set)
    m_Size = property(_pyarmnn.SliceDescriptor_m_Size_get, _pyarmnn.SliceDescriptor_m_Size_set)

    def __eq__(self, rhs):
        return _pyarmnn.SliceDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_SliceDescriptor

# Register SliceDescriptor in _pyarmnn:
_pyarmnn.SliceDescriptor_swigregister(SliceDescriptor)

class SpaceToBatchNdDescriptor(object):
    r"""

    A descriptor for the Space To Batch N-dimensions layer. See `INetwork.AddSpaceToBatchNdLayer()`.

    Contains:
        m_BlockShape (list of int): Underlying C++ data type is std::vector<unsigned int>. Block shape values. Default: [1, 1].
        m_Crops (list of tuple): Specifies the padding values for the input dimension:
                                 [heightPad - (top, bottom) widthPad - (left, right)].
                                 Default: [(0, 0), (0, 0)].
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.SpaceToBatchNdDescriptor_swiginit(self, _pyarmnn.new_SpaceToBatchNdDescriptor(*args))
    m_BlockShape = property(_pyarmnn.SpaceToBatchNdDescriptor_m_BlockShape_get, _pyarmnn.SpaceToBatchNdDescriptor_m_BlockShape_set)
    m_PadList = property(_pyarmnn.SpaceToBatchNdDescriptor_m_PadList_get, _pyarmnn.SpaceToBatchNdDescriptor_m_PadList_set)
    m_DataLayout = property(_pyarmnn.SpaceToBatchNdDescriptor_m_DataLayout_get, _pyarmnn.SpaceToBatchNdDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.SpaceToBatchNdDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_SpaceToBatchNdDescriptor

# Register SpaceToBatchNdDescriptor in _pyarmnn:
_pyarmnn.SpaceToBatchNdDescriptor_swigregister(SpaceToBatchNdDescriptor)

class SpaceToDepthDescriptor(object):
    r"""

    A descriptor for the SpaceToDepth layer. See `INetwork.AddSpaceToDepthLayer()`.

    Contains:
        m_BlockSize (int): Underlying C++ type is unsigned int.  Scalar specifying the input block size. It must be >= 1. Default: 1.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NHWC`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.SpaceToDepthDescriptor_swiginit(self, _pyarmnn.new_SpaceToDepthDescriptor(*args))
    m_BlockSize = property(_pyarmnn.SpaceToDepthDescriptor_m_BlockSize_get, _pyarmnn.SpaceToDepthDescriptor_m_BlockSize_set)
    m_DataLayout = property(_pyarmnn.SpaceToDepthDescriptor_m_DataLayout_get, _pyarmnn.SpaceToDepthDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.SpaceToDepthDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_SpaceToDepthDescriptor

# Register SpaceToDepthDescriptor in _pyarmnn:
_pyarmnn.SpaceToDepthDescriptor_swigregister(SpaceToDepthDescriptor)

class SplitterDescriptor(object):
    r"""

    A descriptor for a Splitter layer. See `INetwork.AddSplitterLayer()`.

    Args:
        numViews (int): Number of views, the value  must be equal to the number of outputs of a layer.
        numDimensions (int): Number of dimensions. Default value is 4.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.SplitterDescriptor_swiginit(self, _pyarmnn.new_SplitterDescriptor(*args))

    def GetNumViews(self):
        r"""

        Get the number of views.
        Returns:
            int: number of views.

        """
        return _pyarmnn.SplitterDescriptor_GetNumViews(self)

    def GetNumDimensions(self):
        r"""

        Get the number of dimensions.

        Returns:
            int: Number of dimensions.


        """
        return _pyarmnn.SplitterDescriptor_GetNumDimensions(self)

    def GetViewOrigin(self, idx):
        r"""

        Get the output view origin (shape) by index, the order matches the outputs.

        e.g. first view corresponds to the first output, second view to the second output, etc.
        Args:
            idx (int): Index.
        Returns:
            list: View origin (shape) as a list of ints.

        """
        return _pyarmnn.SplitterDescriptor_GetViewOrigin(self, idx)

    def GetViewSizes(self, idx):
        r"""

        Get the view sizes by index.
        Args:
            idx (int): Index.
        Returns:
            list: Sizes for the specified index as a list of ints.

        """
        return _pyarmnn.SplitterDescriptor_GetViewSizes(self, idx)

    def GetOrigins(self):
        r"""

        Get the view origins that describe how the splitting process is configured.

        The number of views is the number of outputs, and their order match.
        Returns:
            OriginsDescriptor: A descriptor for the origins view.

        """
        return _pyarmnn.SplitterDescriptor_GetOrigins(self)

    def __eq__(self, rhs):
        return _pyarmnn.SplitterDescriptor___eq__(self, rhs)

    def SetViewOriginCoord(self, view, coord, value):
        r"""

        Set the value of a specific origin view input coordinate.

        Contains:
            view (int): Origin view index.
            coord (int): Coordinate of the origin view to set.
            value (int): Value to set.
        Raises:
            RuntimeError: If the `view` is greater than or equal to GetNumViews().
                          If the `coord` is greater than or equal to GetNumDimensions().

        """
        return _pyarmnn.SplitterDescriptor_SetViewOriginCoord(self, view, coord, value)

    def SetViewSize(self, view, coord, value):
        r"""

        Set the size of the views.

        Args:
            view (int): View index.
            coord (int): Coordinate of the origin view to set.
            value (int): Value to set.
        Raises:
            RuntimeError: If the `view` is greater than or equal to GetNumViews().
                          If the `coord` is greater than or equal to GetNumDimensions().

        """
        return _pyarmnn.SplitterDescriptor_SetViewSize(self, view, coord, value)
    __swig_destroy__ = _pyarmnn.delete_SplitterDescriptor

# Register SplitterDescriptor in _pyarmnn:
_pyarmnn.SplitterDescriptor_swigregister(SplitterDescriptor)

class StackDescriptor(object):
    r"""

    A descriptor for the Stack layer. See `INetwork.AddStackLayer()`.

    Contains:
        m_Axis (int): Underlying C++ type is unsigned int. 0-based axis along which to stack the input tensors. Default: 0.
        m_NumInputs (int): Required shape of all input tensors. Default: 0.
        m_InputShape (TensorShape): Required shape of all input tensors.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.StackDescriptor_swiginit(self, _pyarmnn.new_StackDescriptor(*args))
    m_Axis = property(_pyarmnn.StackDescriptor_m_Axis_get, _pyarmnn.StackDescriptor_m_Axis_set)
    m_NumInputs = property(_pyarmnn.StackDescriptor_m_NumInputs_get, _pyarmnn.StackDescriptor_m_NumInputs_set)
    m_InputShape = property(_pyarmnn.StackDescriptor_m_InputShape_get, _pyarmnn.StackDescriptor_m_InputShape_set)

    def __eq__(self, rhs):
        return _pyarmnn.StackDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_StackDescriptor

# Register StackDescriptor in _pyarmnn:
_pyarmnn.StackDescriptor_swigregister(StackDescriptor)

class StandInDescriptor(object):
    r"""

    A descriptor for the StandIn layer. See `INetwork.AddStandInLayer()`.

    Contains:
        m_NumInputs (int): Underlying C++ type is unsigned int. Number of input tensors. Default: 0.
        m_NumOutputs (int): Underlying C++ type is unsigned int. Number of output tensors. Default: 0.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.StandInDescriptor_swiginit(self, _pyarmnn.new_StandInDescriptor(*args))
    m_NumInputs = property(_pyarmnn.StandInDescriptor_m_NumInputs_get, _pyarmnn.StandInDescriptor_m_NumInputs_set)
    m_NumOutputs = property(_pyarmnn.StandInDescriptor_m_NumOutputs_get, _pyarmnn.StandInDescriptor_m_NumOutputs_set)
    __swig_destroy__ = _pyarmnn.delete_StandInDescriptor

# Register StandInDescriptor in _pyarmnn:
_pyarmnn.StandInDescriptor_swigregister(StandInDescriptor)

class StridedSliceDescriptor(object):
    r"""

    A descriptor for the StridedSlice layer. See `INetwork.AddStridedSliceLayer()`.

    Contains:
        m_Begin (list of int): Underlying C++ data type is std::vector<int>. Begin values for the input that will be sliced.
        m_End (list of int): Underlying C++ data type is std::vector<int>. End values for the input that will be sliced.
        m_Stride (list of int): Underlying C++ data type is std::vector<int>. Stride values for the input that will be sliced.
        m_BeginMask (int): Underlying C++ data type is int32_t. Begin mask value. If set, then the begin is disregarded and
                               the fullest range is used for the dimension. Default: 0.
        m_EndMask (int): Underlying C++ data type is int32_t. End mask value. If set, then the end is disregarded and
                             the fullest range is used for the dimension.Default: 0.
        m_ShrinkAxisMask (int): Underlying C++ data type is int32_t. Shrink axis mask value. If set, the nth specification shrinks the dimensionality by 1. Default: 0.
        m_EllipsisMask (int): Underlying C++ data type is int32_t. Ellipsis mask value. Default: 0.
        m_NewAxisMask (int): Underlying C++ data type is int32_t. New axis mask value. If set, the begin, end and stride is disregarded and
                                  a new 1 dimension is inserted to this location of the output tensor. Default: 0.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.StridedSliceDescriptor_swiginit(self, _pyarmnn.new_StridedSliceDescriptor(*args))

    def GetStartForAxis(self, inputShape, axis):
        return _pyarmnn.StridedSliceDescriptor_GetStartForAxis(self, inputShape, axis)

    def GetStopForAxis(self, inputShape, axis, startForAxis):
        return _pyarmnn.StridedSliceDescriptor_GetStopForAxis(self, inputShape, axis, startForAxis)
    m_Begin = property(_pyarmnn.StridedSliceDescriptor_m_Begin_get, _pyarmnn.StridedSliceDescriptor_m_Begin_set)
    m_End = property(_pyarmnn.StridedSliceDescriptor_m_End_get, _pyarmnn.StridedSliceDescriptor_m_End_set)
    m_Stride = property(_pyarmnn.StridedSliceDescriptor_m_Stride_get, _pyarmnn.StridedSliceDescriptor_m_Stride_set)
    m_BeginMask = property(_pyarmnn.StridedSliceDescriptor_m_BeginMask_get, _pyarmnn.StridedSliceDescriptor_m_BeginMask_set)
    m_EndMask = property(_pyarmnn.StridedSliceDescriptor_m_EndMask_get, _pyarmnn.StridedSliceDescriptor_m_EndMask_set)
    m_ShrinkAxisMask = property(_pyarmnn.StridedSliceDescriptor_m_ShrinkAxisMask_get, _pyarmnn.StridedSliceDescriptor_m_ShrinkAxisMask_set)
    m_EllipsisMask = property(_pyarmnn.StridedSliceDescriptor_m_EllipsisMask_get, _pyarmnn.StridedSliceDescriptor_m_EllipsisMask_set)
    m_NewAxisMask = property(_pyarmnn.StridedSliceDescriptor_m_NewAxisMask_get, _pyarmnn.StridedSliceDescriptor_m_NewAxisMask_set)
    m_DataLayout = property(_pyarmnn.StridedSliceDescriptor_m_DataLayout_get, _pyarmnn.StridedSliceDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.StridedSliceDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_StridedSliceDescriptor

# Register StridedSliceDescriptor in _pyarmnn:
_pyarmnn.StridedSliceDescriptor_swigregister(StridedSliceDescriptor)

class SoftmaxDescriptor(object):
    r"""

    A descriptor for the Softmax layer. See `INetwork.AddSoftmaxLayer()`.

    Contains:
        m_Beta (float): Exponentiation value.
        m_Axis (int): Scalar, defaulted to the last index (-1), specifying the dimension the activation will be performed on.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.SoftmaxDescriptor_swiginit(self, _pyarmnn.new_SoftmaxDescriptor())
    m_Beta = property(_pyarmnn.SoftmaxDescriptor_m_Beta_get, _pyarmnn.SoftmaxDescriptor_m_Beta_set)
    m_Axis = property(_pyarmnn.SoftmaxDescriptor_m_Axis_get, _pyarmnn.SoftmaxDescriptor_m_Axis_set)

    def __eq__(self, rhs):
        return _pyarmnn.SoftmaxDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_SoftmaxDescriptor

# Register SoftmaxDescriptor in _pyarmnn:
_pyarmnn.SoftmaxDescriptor_swigregister(SoftmaxDescriptor)

class TransposeConvolution2dDescriptor(object):
    r"""

    A descriptor for the TransposeConvolution2d layer. See `INetwork.AddTransposeConvolution2dLayer()`.

    Contains:
        m_PadLeft (int): Underlying C++ data type is uint32_t. Padding left value in the width dimension. Default: 0.
        m_PadRight (int): Underlying C++ data type is uint32_t. Padding right value in the width dimension. Default: 0.
        m_PadTop (int): Underlying C++ data type is uint32_t. Padding top value in the height dimension. Default: 0.
        m_PadBottom (int): Underlying C++ data type is uint32_t. Padding bottom value in the height dimension. Default: 0.
        m_StrideX (int): Underlying C++ data type is uint32_t. Stride value when proceeding through input for the width dimension. Default: 0.
        m_StrideY (int): Underlying C++ data type is uint32_t. Stride value when proceeding through input for the height dimension. Default: 0.
        m_BiasEnabled (bool): Enable/disable bias. Default: false.
        m_DataLayout (int): The data layout to be used (`DataLayout_NCHW`, `DataLayout_NHWC`). Default: `DataLayout_NCHW`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.TransposeConvolution2dDescriptor_swiginit(self, _pyarmnn.new_TransposeConvolution2dDescriptor())
    m_PadLeft = property(_pyarmnn.TransposeConvolution2dDescriptor_m_PadLeft_get, _pyarmnn.TransposeConvolution2dDescriptor_m_PadLeft_set)
    m_PadRight = property(_pyarmnn.TransposeConvolution2dDescriptor_m_PadRight_get, _pyarmnn.TransposeConvolution2dDescriptor_m_PadRight_set)
    m_PadTop = property(_pyarmnn.TransposeConvolution2dDescriptor_m_PadTop_get, _pyarmnn.TransposeConvolution2dDescriptor_m_PadTop_set)
    m_PadBottom = property(_pyarmnn.TransposeConvolution2dDescriptor_m_PadBottom_get, _pyarmnn.TransposeConvolution2dDescriptor_m_PadBottom_set)
    m_StrideX = property(_pyarmnn.TransposeConvolution2dDescriptor_m_StrideX_get, _pyarmnn.TransposeConvolution2dDescriptor_m_StrideX_set)
    m_StrideY = property(_pyarmnn.TransposeConvolution2dDescriptor_m_StrideY_get, _pyarmnn.TransposeConvolution2dDescriptor_m_StrideY_set)
    m_BiasEnabled = property(_pyarmnn.TransposeConvolution2dDescriptor_m_BiasEnabled_get, _pyarmnn.TransposeConvolution2dDescriptor_m_BiasEnabled_set)
    m_DataLayout = property(_pyarmnn.TransposeConvolution2dDescriptor_m_DataLayout_get, _pyarmnn.TransposeConvolution2dDescriptor_m_DataLayout_set)

    def __eq__(self, rhs):
        return _pyarmnn.TransposeConvolution2dDescriptor___eq__(self, rhs)
    __swig_destroy__ = _pyarmnn.delete_TransposeConvolution2dDescriptor

# Register TransposeConvolution2dDescriptor in _pyarmnn:
_pyarmnn.TransposeConvolution2dDescriptor_swigregister(TransposeConvolution2dDescriptor)


def CreateDescriptorForConcatenation(shapes, concatenationDimension):
    r"""

    Create a descriptor for a Concatenation layer.
    Args:
        shapes (list of TensorShape): Input shapes of tensors to concatenated.
        concatenationDimension (int): Concatenation axis, must be >=0.

    Returns:
        ConcatDescriptor: A descriptor object for a Concatenation layer.

    """
    return _pyarmnn.CreateDescriptorForConcatenation(shapes, concatenationDimension)
class LstmInputParams(object):
    r"""

    Long Short-Term Memory layer input parameters.

    See `INetwork.AddLstmLayer()`.
    Operation described by the following equations:

     \[i_t=\sigma(W_{xi}x_t+W_{hi}h_{t-1}+W_{ci}C_{t-1}+b_i) \\
        f_t=\sigma(W_{xf}x_t+W_{hf}h_{t-1}+W_{cf}C_{t-1}+b_f) \\
        C_t=clip(f_t \odot C_{t-1} + i_t \odot g(W_{xc}x_t+W_{hc}h_{t-1}+b_c),\ t_{cell}) \\
        o_t = \sigma(W_{xo}x_t+W_{ho}h_{t-1}+W_{co}C_t+b_o)  \\
        h_t = clip(W_{proj}(o_t \odot g(C_t))+b_{proj},\ t_{proj})\ if\ there\ is\ a\ projection;  \\
        h_t = o_t \odot g(C_t)\ otherwise. \]
        Where:
        \(x_t\) - input;
        \(i_t\) - input gate;
        \(f_t\) - forget gate;
        \(C_t\) - cell state;
        \(o_t\) - output;
        \(h_t\) - output state;
        \(\sigma\) - logistic sigmoid function;
        \(g\) - cell input and cell output activation function, see `LstmDescriptor.m_ActivationFunc`;
        \(t_{cell}\) - threshold for clipping the cell state, see `LstmDescriptor.m_ClippingThresCell`;
        \(t_{proj}\) - threshold for clipping the projected output, see `LstmDescriptor.m_ClippingThresProj`;

    Contains:
        m_InputToInputWeights (ConstTensor): \(W_{xi}\), input-to-input weight matrix.
        m_InputToForgetWeights (ConstTensor): \(W_{xf}\), input-to-forget weight matrix.
        m_InputToCellWeights (ConstTensor): \(W_{xc}\), input-to-cell weight matrix.
        m_InputToOutputWeights (ConstTensor): \(W_{xo}\), input-to-output weight matrix.

        m_RecurrentToInputWeights (ConstTensor): \(W_{hi}\), recurrent-to-input weight matrix.
        m_RecurrentToForgetWeights (ConstTensor): \(W_{hf}\), recurrent-to-forget weight matrix.
        m_RecurrentToCellWeights (ConstTensor): \(W_{hc}\), recurrent-to-cell weight matrix.
        m_RecurrentToOutputWeights (ConstTensor): \(W_{ho}\), recurrent-to-output weight matrix.

        m_CellToInputWeights (ConstTensor): \(W_{ci}\), cell-to-input weight matrix. Has effect if `LstmDescriptor.m_PeepholeEnabled`.
        m_CellToForgetWeights (ConstTensor): \(W_{cf}\), cell-to-forget weight matrix. Has effect if `LstmDescriptor.m_PeepholeEnabled`.
        m_CellToOutputWeights (ConstTensor): \(W_{co}\), cell-to-output weight matrix. Has effect if `LstmDescriptor.m_PeepholeEnabled`.

        m_InputGateBias (ConstTensor): \(b_i\), input gate bias.
        m_ForgetGateBias (ConstTensor): \(b_f\), forget gate bias.
        m_CellBias (ConstTensor): \(b_c\), cell bias.
        m_OutputGateBias (ConstTensor): \(b_o\),  output gate bias.

        m_ProjectionWeights (ConstTensor): \(W_{proj}\), projection weight matrix.
                                           Has effect if `LstmDescriptor.m_ProjectionEnabled` is set to True.
        m_ProjectionBias (ConstTensor): \(b_{proj}\), projection bias.
                                        Has effect if `LstmDescriptor.m_ProjectionEnabled` is set to True.
        m_InputLayerNormWeights (ConstTensor): normalisation weights for input,
                                               has effect if `LstmDescriptor.m_LayerNormEnabled` set to True.
        m_ForgetLayerNormWeights (ConstTensor): normalisation weights for forget gate,
                                                has effect if `LstmDescriptor.m_LayerNormEnabled` set to True.
        m_CellLayerNormWeights (ConstTensor): normalisation weights for current cell,
                                              has effect if `LstmDescriptor.m_LayerNormEnabled` set to True.
        m_OutputLayerNormWeights (ConstTensor): normalisation weights for output gate,
                                                has effect if `LstmDescriptor.m_LayerNormEnabled` set to True.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.LstmInputParams_swiginit(self, _pyarmnn.new_LstmInputParams())
    m_InputToInputWeights = property(_pyarmnn.LstmInputParams_m_InputToInputWeights_get, _pyarmnn.LstmInputParams_m_InputToInputWeights_set)
    m_InputToForgetWeights = property(_pyarmnn.LstmInputParams_m_InputToForgetWeights_get, _pyarmnn.LstmInputParams_m_InputToForgetWeights_set)
    m_InputToCellWeights = property(_pyarmnn.LstmInputParams_m_InputToCellWeights_get, _pyarmnn.LstmInputParams_m_InputToCellWeights_set)
    m_InputToOutputWeights = property(_pyarmnn.LstmInputParams_m_InputToOutputWeights_get, _pyarmnn.LstmInputParams_m_InputToOutputWeights_set)
    m_RecurrentToInputWeights = property(_pyarmnn.LstmInputParams_m_RecurrentToInputWeights_get, _pyarmnn.LstmInputParams_m_RecurrentToInputWeights_set)
    m_RecurrentToForgetWeights = property(_pyarmnn.LstmInputParams_m_RecurrentToForgetWeights_get, _pyarmnn.LstmInputParams_m_RecurrentToForgetWeights_set)
    m_RecurrentToCellWeights = property(_pyarmnn.LstmInputParams_m_RecurrentToCellWeights_get, _pyarmnn.LstmInputParams_m_RecurrentToCellWeights_set)
    m_RecurrentToOutputWeights = property(_pyarmnn.LstmInputParams_m_RecurrentToOutputWeights_get, _pyarmnn.LstmInputParams_m_RecurrentToOutputWeights_set)
    m_CellToInputWeights = property(_pyarmnn.LstmInputParams_m_CellToInputWeights_get, _pyarmnn.LstmInputParams_m_CellToInputWeights_set)
    m_CellToForgetWeights = property(_pyarmnn.LstmInputParams_m_CellToForgetWeights_get, _pyarmnn.LstmInputParams_m_CellToForgetWeights_set)
    m_CellToOutputWeights = property(_pyarmnn.LstmInputParams_m_CellToOutputWeights_get, _pyarmnn.LstmInputParams_m_CellToOutputWeights_set)
    m_InputGateBias = property(_pyarmnn.LstmInputParams_m_InputGateBias_get, _pyarmnn.LstmInputParams_m_InputGateBias_set)
    m_ForgetGateBias = property(_pyarmnn.LstmInputParams_m_ForgetGateBias_get, _pyarmnn.LstmInputParams_m_ForgetGateBias_set)
    m_CellBias = property(_pyarmnn.LstmInputParams_m_CellBias_get, _pyarmnn.LstmInputParams_m_CellBias_set)
    m_OutputGateBias = property(_pyarmnn.LstmInputParams_m_OutputGateBias_get, _pyarmnn.LstmInputParams_m_OutputGateBias_set)
    m_ProjectionWeights = property(_pyarmnn.LstmInputParams_m_ProjectionWeights_get, _pyarmnn.LstmInputParams_m_ProjectionWeights_set)
    m_ProjectionBias = property(_pyarmnn.LstmInputParams_m_ProjectionBias_get, _pyarmnn.LstmInputParams_m_ProjectionBias_set)
    m_InputLayerNormWeights = property(_pyarmnn.LstmInputParams_m_InputLayerNormWeights_get, _pyarmnn.LstmInputParams_m_InputLayerNormWeights_set)
    m_ForgetLayerNormWeights = property(_pyarmnn.LstmInputParams_m_ForgetLayerNormWeights_get, _pyarmnn.LstmInputParams_m_ForgetLayerNormWeights_set)
    m_CellLayerNormWeights = property(_pyarmnn.LstmInputParams_m_CellLayerNormWeights_get, _pyarmnn.LstmInputParams_m_CellLayerNormWeights_set)
    m_OutputLayerNormWeights = property(_pyarmnn.LstmInputParams_m_OutputLayerNormWeights_get, _pyarmnn.LstmInputParams_m_OutputLayerNormWeights_set)
    __swig_destroy__ = _pyarmnn.delete_LstmInputParams

# Register LstmInputParams in _pyarmnn:
_pyarmnn.LstmInputParams_swigregister(LstmInputParams)

class QuantizedLstmInputParams(object):
    r"""

    Quantized Long Short-Term Memory layer input parameters.

    See `INetwork.AddQuantizedLstmLayer()`.
    Operation described by the following equations:

     \[i_t=\sigma(W_{xi}x_t+W_{hi}h_{t-1}+W_{ci}C_{t-1}+b_i) \\
        f_t=\sigma(W_{xf}x_t+W_{hf}h_{t-1}+W_{cf}C_{t-1}+b_f) \\
        C_t=clip(f_t \odot C_{t-1} + i_t \odot g(W_{xc}x_t+W_{hc}h_{t-1}+b_c),\ t_{cell}) \\
        o_t = \sigma(W_{xo}x_t+W_{ho}h_{t-1}+W_{co}C_t+b_o)  \\
        h_t = clip(W_{proj}(o_t \odot g(C_t))+b_{proj},\ t_{proj})\ if\ there\ is\ a\ projection;  \\
        h_t = o_t \odot g(C_t)\ otherwise. \]
        Where:
        \(x_t\) - input;
        \(i_t\) - input gate;
        \(f_t\) - forget gate;
        \(C_t\) - cell state;
        \(o_t\) - output;
        \(h_t\) - output state;
        \(\sigma\) - logistic sigmoid function;
        \(g\) - cell input and cell output activation function, see `LstmDescriptor.m_ActivationFunc`;
        \(t_{cell}\) - threshold for clipping the cell state, see `LstmDescriptor.m_ClippingThresCell`;
        \(t_{proj}\) - threshold for clipping the projected output, see `LstmDescriptor.m_ClippingThresProj`;

    Contains:
        m_InputToInputWeights (ConstTensor): \(W_{xi}\), input-to-input weight matrix.
        m_InputToForgetWeights (ConstTensor): \(W_{xf}\), input-to-forget weight matrix.
        m_InputToCellWeights (ConstTensor): \(W_{xc}\), input-to-cell weight matrix.
        m_InputToOutputWeights (ConstTensor): \(W_{xo}\), input-to-output weight matrix.

        m_RecurrentToInputWeights (ConstTensor): \(W_{hi}\), recurrent-to-input weight matrix.
        m_RecurrentToForgetWeights (ConstTensor): \(W_{hf}\), recurrent-to-forget weight matrix.
        m_RecurrentToCellWeights (ConstTensor): \(W_{hc}\), recurrent-to-cell weight matrix.
        m_RecurrentToOutputWeights (ConstTensor): \(W_{ho}\), recurrent-to-output weight matrix.

        m_InputGateBias (ConstTensor): \(b_i\), input gate bias.
        m_ForgetGateBias (ConstTensor): \(b_f\), forget gate bias.
        m_CellBias (ConstTensor): \(b_c\), cell bias.
        m_OutputGateBias (ConstTensor): \(b_o\),  output gate bias.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyarmnn.QuantizedLstmInputParams_swiginit(self, _pyarmnn.new_QuantizedLstmInputParams())
    m_InputToInputWeights = property(_pyarmnn.QuantizedLstmInputParams_m_InputToInputWeights_get, _pyarmnn.QuantizedLstmInputParams_m_InputToInputWeights_set)
    m_InputToForgetWeights = property(_pyarmnn.QuantizedLstmInputParams_m_InputToForgetWeights_get, _pyarmnn.QuantizedLstmInputParams_m_InputToForgetWeights_set)
    m_InputToCellWeights = property(_pyarmnn.QuantizedLstmInputParams_m_InputToCellWeights_get, _pyarmnn.QuantizedLstmInputParams_m_InputToCellWeights_set)
    m_InputToOutputWeights = property(_pyarmnn.QuantizedLstmInputParams_m_InputToOutputWeights_get, _pyarmnn.QuantizedLstmInputParams_m_InputToOutputWeights_set)
    m_RecurrentToInputWeights = property(_pyarmnn.QuantizedLstmInputParams_m_RecurrentToInputWeights_get, _pyarmnn.QuantizedLstmInputParams_m_RecurrentToInputWeights_set)
    m_RecurrentToForgetWeights = property(_pyarmnn.QuantizedLstmInputParams_m_RecurrentToForgetWeights_get, _pyarmnn.QuantizedLstmInputParams_m_RecurrentToForgetWeights_set)
    m_RecurrentToCellWeights = property(_pyarmnn.QuantizedLstmInputParams_m_RecurrentToCellWeights_get, _pyarmnn.QuantizedLstmInputParams_m_RecurrentToCellWeights_set)
    m_RecurrentToOutputWeights = property(_pyarmnn.QuantizedLstmInputParams_m_RecurrentToOutputWeights_get, _pyarmnn.QuantizedLstmInputParams_m_RecurrentToOutputWeights_set)
    m_InputGateBias = property(_pyarmnn.QuantizedLstmInputParams_m_InputGateBias_get, _pyarmnn.QuantizedLstmInputParams_m_InputGateBias_set)
    m_ForgetGateBias = property(_pyarmnn.QuantizedLstmInputParams_m_ForgetGateBias_get, _pyarmnn.QuantizedLstmInputParams_m_ForgetGateBias_set)
    m_CellBias = property(_pyarmnn.QuantizedLstmInputParams_m_CellBias_get, _pyarmnn.QuantizedLstmInputParams_m_CellBias_set)
    m_OutputGateBias = property(_pyarmnn.QuantizedLstmInputParams_m_OutputGateBias_get, _pyarmnn.QuantizedLstmInputParams_m_OutputGateBias_set)
    __swig_destroy__ = _pyarmnn.delete_QuantizedLstmInputParams

# Register QuantizedLstmInputParams in _pyarmnn:
_pyarmnn.QuantizedLstmInputParams_swigregister(QuantizedLstmInputParams)

class OptimizerOptions(object):
    r"""

    Struct for holding options relating to the Arm NN optimizer. See `Optimize`.

    Contains:
        m_debug (bool): Add debug data for easier troubleshooting.
        m_ReduceFp32ToFp16 (bool): Reduce Fp32 data to Fp16 for faster processing.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.OptimizerOptions_swiginit(self, _pyarmnn.new_OptimizerOptions(*args))
    m_ReduceFp32ToFp16 = property(_pyarmnn.OptimizerOptions_m_ReduceFp32ToFp16_get, _pyarmnn.OptimizerOptions_m_ReduceFp32ToFp16_set)
    m_Debug = property(_pyarmnn.OptimizerOptions_m_Debug_get, _pyarmnn.OptimizerOptions_m_Debug_set)
    __swig_destroy__ = _pyarmnn.delete_OptimizerOptions

# Register OptimizerOptions in _pyarmnn:
_pyarmnn.OptimizerOptions_swigregister(OptimizerOptions)

class IInputSlot(object):
    r"""

    An input connection slot for a layer. Slot lifecycle is managed by the layer.

    The input slot can be connected to an output slot of the preceding layer in the graph.
    Only one connection to the input slot is allowed.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetConnection(self):
        r"""

        Returns output slot of a preceding layer that is connected to the given input slot.

        Returns:
            IOutputSlot: Borrowed reference to an output connection slot for a preceding layer.


        """
        return _pyarmnn.IInputSlot_GetConnection(self)

# Register IInputSlot in _pyarmnn:
_pyarmnn.IInputSlot_swigregister(IInputSlot)

class IOutputSlot(object):
    r"""

    An output connection slot for a layer. Slot lifecycle is managed by the layer.

    The output slot may be connected to 1 or more input slots of subsequent layers in the graph.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetNumConnections(self):
        r"""

        Returns the total number of connected input slots.

        The same result could be obtained by calling `len()`:

        >>> output_slot = ...
        >>> size = len(output_slot)
        >>> assert size == output_slot.GetNumConnections()

        Returns:
            int: Number of connected input slots.

        """
        return _pyarmnn.IOutputSlot_GetNumConnections(self)

    def GetConnection(self, index):
        r"""

        Retrieves connected input slot by index.

        The same result could be obtained by using square brackets:

        >>> output_slot = ...
        >>> connected_input_slot = output_slot[0]

        Args:
           index (int): Slot index.

        Returns:
            IInputSlot: Borrowed reference to connected input slot with given index.

        Raises:
            RuntimeError: If index out of bounds.

        """
        return _pyarmnn.IOutputSlot_GetConnection(self, index)

    def SetTensorInfo(self, tensorInfo):
        r"""

        Sets tensor info for output slot.
        Operation does not change TensorInfo ownership.
        Args:
            tensorInfo (TensorInfo): Output tensor info.


        """
        return _pyarmnn.IOutputSlot_SetTensorInfo(self, tensorInfo)

    def GetTensorInfo(self):
        r"""

        Gets tensor info for output slot.

        Args:
            tensorInfo (TensorInfo): Output tensor info.


        """
        return _pyarmnn.IOutputSlot_GetTensorInfo(self)

    def IsTensorInfoSet(self):
        r"""

        Checks if tensor info was set previously.

        Returns:
            bool: True if output tensor info was set, False - otherwise.


        """
        return _pyarmnn.IOutputSlot_IsTensorInfoSet(self)

    def Connect(self, destination):
        r"""

        Connects this output slot with given input slot.
        Input slot is updated with this output connection.

        Args:
            destination (IInputSlot): Output tensor info.

        Returns:
            int: Total number of connections.

        Raises:
            RuntimeError: If input slot was already connected.


        """
        return _pyarmnn.IOutputSlot_Connect(self, destination)

    def Disconnect(self, slot):
        r"""

        Disconnects this output slot from given input slot.

        Args:
            slot (IInputSlot): Input slot to disconnect from.


        """
        return _pyarmnn.IOutputSlot_Disconnect(self, slot)

    def CalculateIndexOnOwner(self):
        r"""

        Calculates the index of this slot for the layer.

        Returns:
            int: Slot index.


        """
        return _pyarmnn.IOutputSlot_CalculateIndexOnOwner(self)

    def GetOwningLayerGuid(self):
        r"""

        Returns the index of the layer. Same value as `IConnectableLayer.GetGuid`.

        Returns:
            int: Layer id.


        """
        return _pyarmnn.IOutputSlot_GetOwningLayerGuid(self)

    def __getitem__(self, index):
        return _pyarmnn.IOutputSlot___getitem__(self, index)

    def __len__(self):
        return _pyarmnn.IOutputSlot___len__(self)

# Register IOutputSlot in _pyarmnn:
_pyarmnn.IOutputSlot_swigregister(IOutputSlot)

class IConnectableLayer(object):
    r"""

    Interface for a layer that is connectable to other layers via `IInputSlot` and `IOutputSlot`.
    The object implementing this interface is returned by `INetwork` when calling `add*Layer` methods.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetName(self):
        r"""

        Returns the name of the layer. Name attribute is optional for a layer, thus
        `None` value could be returned.

        Returns:
            str: Layer name or `None`.


        """
        return _pyarmnn.IConnectableLayer_GetName(self)

    def GetNumInputSlots(self):
        r"""

        Gets the number of input slots for the layer.

        Returns:
            int: Number of input slots.


        """
        return _pyarmnn.IConnectableLayer_GetNumInputSlots(self)

    def GetNumOutputSlots(self):
        r"""

        Gets the number of output slots for the layer.

        Returns:
            int: Number of output slots.


        """
        return _pyarmnn.IConnectableLayer_GetNumOutputSlots(self)

    def GetInputSlot(self, index):
        r"""

        Gets the input slot by index.

        Args:
            index (int): Slot index.

        Returns:
            IInputSlot: Borrowed reference to input slot.


        """
        return _pyarmnn.IConnectableLayer_GetInputSlot(self, index)

    def GetOutputSlot(self, index):
        r"""

        Gets the output slot by index.

        Args:
            index (int): Slot index.

        Returns:
            IOutputSlot: Borrowed reference to output slot.


        """
        return _pyarmnn.IConnectableLayer_GetOutputSlot(self, index)

    def GetGuid(self):
        r"""

        Gets the unique layer id (within one process).
        Guid is generated and assigned automatically when the layer is created.

        Returns:
            int: The unique layer id.


        """
        return _pyarmnn.IConnectableLayer_GetGuid(self)

# Register IConnectableLayer in _pyarmnn:
_pyarmnn.IConnectableLayer_swigregister(IConnectableLayer)

class INetwork(object):
    r"""

    Interface for a network object. Network objects contain the whole computation graph, made up of different layers connected together.

    INetwork objects can be constructed manually or obtained by using parsers. INetwork objects are used to create optimized networks, see `Optimize`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def AddInputLayer(self, id, name=None):
        r"""

        Adds an input layer to the network. Input layers are placed at the start of a network and used for feeding input data during inference.

        Args:
            id (int): User generated id to uniquely identify a particular input. The same id needs to be specified
                      when passing the inputs to the IRuntime::EnqueueWorkload() function.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddInputLayer(self, id, name)

    def AddAdditionLayer(self, name=None):
        r"""

        Adds an addition layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddAdditionLayer(self, name)

    def AddOutputLayer(self, id, name=None):
        r"""

            Adds an output layer to the network. Output layer is the final layer in your network.

        Args:
            id (int): User generated id to uniquely identify a particular input. The same id needs to be specified
                      when passing the inputs to `IRuntime.EnqueueWorkload()`.
            name (str): Optional name for the layer.

            Returns:
                IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddOutputLayer(self, id, name)

    def AddActivationLayer(self, activationDescriptor, name=None):
        r"""

        Adds an Activation layer to the network. Type of activation is decided by activationDescriptor.

        Args:
            activationDescriptor (ActivationDescriptor): ActivationDescriptor to configure the activation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddActivationLayer(self, activationDescriptor, name)

    def AddArgMinMaxLayer(self, desc, name=None):
        r"""

        Adds an ArgMinMax layer to the network.

        Args:
            desc (ArgMinMaxDescriptor): Parameters for the ArgMinMax layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddArgMinMaxLayer(self, desc, name)

    def AddBatchNormalizationLayer(self, desc, mean, variance, beta, gamma, name=None):
        r"""

        Adds a Batch Normalization layer to the network.

        Args:
            mean (ConstTensor): Pre-calculated mean for each channel.
            variance (ConstTensor): Pre-calculated variance for each channel.
            beta (ConstTensor): Per-channel additive factor.
            gamma (ConstTensor): Per-channel multiplicative factor.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddBatchNormalizationLayer(self, desc, mean, variance, beta, gamma, name)

    def AddBatchToSpaceNdLayer(self, batchToSpaceNdDescriptor, name=None):
        r"""

        Adds a Batch To Space ND layer to the network.

        Args:
            batchToSpaceNdDescriptor (BatchToSpaceNdDescriptor): Configuration parameters for the layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddBatchToSpaceNdLayer(self, batchToSpaceNdDescriptor, name)

    def AddComparisonLayer(self, comparisonDescriptor, name=None):
        r"""

        Adds a Comparison layer to the network.

        Args:
            comparisonDescriptor (ComparisonDescriptor): Configuration parameters for the layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddComparisonLayer(self, comparisonDescriptor, name)

    def AddConcatLayer(self, concatDescriptor, name=None):
        r"""

        Adds a Concatenation layer to the network.

        Args:
            concatDescriptor (ConcatDescriptor): Parameters to configure the Concatenation layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddConcatLayer(self, concatDescriptor, name)

    def AddConstantLayer(self, input, name=None):
        r"""

        Adds a layer with no inputs and a single output, which always corresponds to the passed in constant tensor.

        Args:
            input (ConstTensor): Tensor to be provided as the only output of the layer. The layer will maintain
                    its own copy of the tensor data, meaning the memory referenced by input can
                    be freed or reused after this function is called.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddConstantLayer(self, input, name)

    def AddDepthToSpaceLayer(self, depthToSpaceDescriptor, name=None):
        r"""

        Adds a Depth To Space layer to the network.

        Args:
            depthToSpaceDescriptor (DepthToSpaceDescriptor): Parameters for the depth to space operation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddDepthToSpaceLayer(self, depthToSpaceDescriptor, name)

    def AddDequantizeLayer(self, name=None):
        r"""

        Adds a Dequantize layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddDequantizeLayer(self, name)

    def AddDetectionPostProcessLayer(self, descriptor, anchors, name=None):
        r"""

        Adds a Detection PostProcess layer to the network. Detection PostProcess is a custom layer for SSD MobilenetV1.

        Args:
            descriptor (DetectionPostProcessDescriptor): Description of the Detection PostProcess layer.
            anchors (ConstTensor): Tensor for anchors.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddDetectionPostProcessLayer(self, descriptor, anchors, name)

    def AddDivisionLayer(self, name=None):
        r"""

        Adds a Division layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddDivisionLayer(self, name)

    def AddElementwiseUnaryLayer(self, elementwiseUnaryDescriptor, name=None):
        r"""

        Adds an Elementwise Unary layer to the network. Type of unary operation to use is decided by elementwiseUnaryDescriptor. Unary operations supported are (Abs, Exp, Neg, Rsqrt, Sqrt)

        Args:
            elementwiseUnaryDescriptor (ElementwiseUnaryDescriptor): ElementwiseUnaryDescriptor to configure the choice of unary operation added to the network.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddElementwiseUnaryLayer(self, elementwiseUnaryDescriptor, name)

    def AddFloorLayer(self, name=None):
        r"""

        Adds a Floor layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddFloorLayer(self, name)

    def AddGatherLayer(self, name=None):
        r"""

        Add Gather layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddGatherLayer(self, name)

    def AddInstanceNormalizationLayer(self, desc, name=None):
        r"""

        Adds an Instance Normalization layer to the network.

        Args:
            desc (InstanceNormalizationDescriptor): Parameters for the instance normalization operation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddInstanceNormalizationLayer(self, desc, name)

    def AddLogSoftmaxLayer(self, logSoftmaxDescriptor, name=None):
        r"""

        Adds a Log Softmax layer to the network.

        Args:
            desc (SoftmaxDescriptor): parameters to configure the log softmax.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddLogSoftmaxLayer(self, logSoftmaxDescriptor, name)

    def AddL2NormalizationLayer(self, desc, name=None):
        r"""

        Adds an L2 Normalization layer to the network.
        Normalization is performed along dimension 1, but requires a 4d input.

        Args:
            desc (L2NormalizationDescriptor): Parameters for the L2 normalization operation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddL2NormalizationLayer(self, desc, name)

    def AddLstmLayer(self, descriptor, params, name=None):
        r"""

        Add a Long Short-Term Memory layer to the network.

        Args:
            descriptor (LstmDescriptor): Parameters for the Lstm operation.
            params (LstmInputParams): Weights and biases for the LSTM cell.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddLstmLayer(self, descriptor, params, name)

    def AddMaximumLayer(self, name=None):
        r"""

        Add a Maximum layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddMaximumLayer(self, name)

    def AddMeanLayer(self, meanDescriptor, name=None):
        r"""

        Adds a Mean layer to the network.

        Args:
            meanDescriptor (meanDescriptor): Parameters for the mean operation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddMeanLayer(self, meanDescriptor, name)

    def AddMergeLayer(self, name=None):
        r"""

        Adds a Merge layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddMergeLayer(self, name)

    def AddMinimumLayer(self, name=None):
        r"""

        Adds a Minimum layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddMinimumLayer(self, name)

    def AddMultiplicationLayer(self, name=None):
        r"""

        Adds a Multiplication layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddMultiplicationLayer(self, name)

    def AddNormalizationLayer(self, normalizationDescriptor, name=None):
        r"""

        Adds a Normalization layer to the network.

        Args:
            normalizationDescriptor (NormalizationDescriptor): Parameters to configure the normalization.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddNormalizationLayer(self, normalizationDescriptor, name)

    def AddPadLayer(self, padDescriptor, name=None):
        r"""

        Adds a Pad layer to the network.

        Args:
            padDescriptor (PadDescriptor): Padding configuration for the layer. See `PadDescriptor` for more details.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddPadLayer(self, padDescriptor, name)

    def AddPermuteLayer(self, permuteDescriptor, name=None):
        r"""

        Adds a Permute layer to the network.

        Args:
            permuteDescriptor (PermuteDescriptor): Configuration of the permutation layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddPermuteLayer(self, permuteDescriptor, name)

    def AddPooling2dLayer(self, pooling2dDescriptor, name=None):
        r"""

        Adds a Pooling layer to the network. Type of pooling is decided by the configuration.

        Args:
            pooling2dDescriptor (Pooling2dDescriptor): Configuration for the pooling layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddPooling2dLayer(self, pooling2dDescriptor, name)

    def AddPreluLayer(self, name=None):
        r"""

        Adds a PReLU layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddPreluLayer(self, name)

    def AddQuantizeLayer(self, name=None):
        r"""

        Adds a Quantize layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddQuantizeLayer(self, name)

    def AddQuantizedLstmLayer(self, params, name=None):
        r"""

        Adds a Quantized Long Short-Term Memory layer to the network.

        Args:
            params (`QuantizedLstmInputParams`): The weights and biases for the Quantized LSTM cell.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddQuantizedLstmLayer(self, params, name)

    def AddReshapeLayer(self, reshapeDescriptor, name=None):
        r"""

        Adds a Reshape layer to the network.

        Args:
            reshapeDescriptor (ReshapeDescriptor): Parameters for the reshape operation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddReshapeLayer(self, reshapeDescriptor, name)

    def AddResizeLayer(self, resizeDescriptor, name=None):
        r"""

        Adds a Resize layer to the network.

        Args:
            resizeDescriptor (ResizeDescriptor): Configuration for the resize layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddResizeLayer(self, resizeDescriptor, name)

    def AddSliceLayer(self, sliceDescriptor, name=None):
        r"""

        Adds a Slice layer to the network.

        Args:
            sliceDescriptor (SliceDescriptor): Descriptor to configure the slice operation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddSliceLayer(self, sliceDescriptor, name)

    def AddSoftmaxLayer(self, softmaxDescriptor, name=None):
        r"""

        Adds a Softmax layer to the network.

        If the data type is `DataType_QuantisedAsymm8`, then the output quantization parameters
        must have a scale of 1/256 and an offset of 0.

        Args:
            softmaxDescriptor (SoftmaxDescriptor): Configuration for the softmax layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddSoftmaxLayer(self, softmaxDescriptor, name)

    def AddSpaceToBatchNdLayer(self, spaceToBatchNdDescriptor, name=None):
        r"""

        Adds a Space To Batch layer to the network.

        Args:
            spaceToBatchNdDescriptor (SpaceToBatchNdDescriptor): Configuration for the space to batch layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddSpaceToBatchNdLayer(self, spaceToBatchNdDescriptor, name)

    def AddSpaceToDepthLayer(self, spaceToDepthDescriptor, name=None):
        r"""

        Adds a space to depth layer to the network.

        Args:
            spaceToDepthDescriptor (SpaceToDepthDescriptor): Parameters for the space to depth operation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddSpaceToDepthLayer(self, spaceToDepthDescriptor, name)

    def AddSplitterLayer(self, splitterDescriptor, name=None):
        r"""

        Adds a Splitter layer to the network.

        Args:
            splitterDescriptor (SplitterDescriptor): Parameters to configure the splitter layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddSplitterLayer(self, splitterDescriptor, name)

    def AddStackLayer(self, descriptor, name=None):
        r"""

        Adds a Stack layer to the network.

        Args:
            descriptor (StackDescriptor):  Descriptor to configure the stack layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddStackLayer(self, descriptor, name)

    def AddStandInLayer(self, descriptor, name=None):
        r"""

        Adds a StandIn layer to the network.

        Args:
            descriptor (StandInDescriptor): Parameters to configure the standIn layer.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddStandInLayer(self, descriptor, name)

    def AddStridedSliceLayer(self, stridedSliceDescriptor, name=None):
        r"""

        Adds a Strided Slice layer to the network.

        Args:
            stridedSliceDescriptor (StridedSliceDescriptor): Parameters for the strided slice operation.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddStridedSliceLayer(self, stridedSliceDescriptor, name)

    def AddSubtractionLayer(self, name=None):
        r"""

        Adds a Subtraction layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddSubtractionLayer(self, name)

    def AddSwitchLayer(self, name=None):
        r"""

        Adds a Switch layer to the network.

        Args:
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddSwitchLayer(self, name)

    def __init__(self):
        _pyarmnn.INetwork_swiginit(self, _pyarmnn.new_INetwork())
    __swig_destroy__ = _pyarmnn.delete_INetwork

    def AddFullyConnectedLayer(self, fullyConnectedDescriptor, weights, biases=None, name=None):
        r"""

        Adds a Fully Connected layer to the network. Also known as a Linear or Dense layer.

        Args:
            fullyConnectedDescriptor (FullyConnectedDescriptor): Description of the fully connected layer.
            weights (ConstTensor): Tensor for the weights data.
            biases (ConstTensor): Optional tensor for the bias data.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddFullyConnectedLayer(self, fullyConnectedDescriptor, weights, biases, name)

    def AddTransposeConvolution2dLayer(self, descriptor, weights, biases=None, name=None):
        r"""

        Adds a 2D Transpose Convolution layer to the network.

        Args:
            descriptor (TransposeConvolution2dDescriptor): Descriptor containing all parameters to configure this layer.
            weights (ConstTensor): Tensor for the weights data.
            biases (ConstTensor): Optional tensor for the bias data.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddTransposeConvolution2dLayer(self, descriptor, weights, biases, name)

    def AddConvolution2dLayer(self, convolution2dDescriptor, weights, biases=None, name=None):
        r"""

        Adds a 2D Convolution layer to the network.

        Args:
            convolution2dDescriptor (Convolution2dDescriptor): Description of the 2D convolution layer.
            weights (ConstTensor): Tensor for the weights data.
            biases (ConstTensor): Optional tensor for the bias data. If specified, must match the output tensor shape.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddConvolution2dLayer(self, convolution2dDescriptor, weights, biases, name)

    def AddDepthwiseConvolution2dLayer(self, convolution2dDescriptor, weights, biases=None, name=None):
        r"""

        Adds a 2D Depthwise Convolution layer to the network.

        Args:
            convolution2dDescriptor (DepthwiseConvolution2dDescriptor): Description of the 2D depthwise convolution layer.
            weights (ConstTensor): Tensor for the weights. Expected format: [channelMultiplier, inputChannels, height, width].
            biases (ConstTensor): Optional tensor for the bias data. If specified, must match the output tensor shape.
            name (str): Optional name for the layer.

        Returns:
            IConnectableLayer: Interface for configuring the layer.

        """
        return _pyarmnn.INetwork_AddDepthwiseConvolution2dLayer(self, convolution2dDescriptor, weights, biases, name)

# Register INetwork in _pyarmnn:
_pyarmnn.INetwork_swigregister(INetwork)

class IOptimizedNetwork(object):
    r"""

    Interface class for an optimzied network object. Optimized networks are obtained after running `Optimize` on
    an `INetwork` object.
    Optimized networks are passed to `EnqueueWorkload`.

    Args:
        convolution2dDescriptor (DepthwiseConvolution2dDescriptor): Description of the 2D depthwise convolution layer.
        weights (ConstTensor): Tensor for the weights. Expected format: [channelMultiplier, inputChannels, height, width].
        biases (ConstTensor): Optional tensor for the bias data. If specified, must match the output tensor shape.
        name (str): Optional name for the layer.

    Returns:
        IConnectableLayer: Interface for configuring the layer.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyarmnn.delete_IOptimizedNetwork

    def SerializeToDot(self, fileName):
        r"""

        Saves optimized network graph as dot file.

        Args:
            fileName (str): File path to save to.
        Raises:
            RuntimeError: If serialization failure.

        """
        return _pyarmnn.IOptimizedNetwork_SerializeToDot(self, fileName)

# Register IOptimizedNetwork in _pyarmnn:
_pyarmnn.IOptimizedNetwork_swigregister(IOptimizedNetwork)


def Optimize(*args):
    r"""

    Create an optimized version of the given network. Should be called before loading a network into the runtime.

    Examples:
        Optimize a loaded network ready for inference.
        >>> parser = ann.ITfLiteParser()
        >>> network = parser.CreateNetworkFromBinaryFile('./model.tflite')
        >>>
        >>> preferredBackends = [ann.BackendId('CpuAcc'), ann.BackendId('CpuRef')]
        >>> opt_network, messages = ann.Optimize(network, preferredBackends, runtime.GetDeviceSpec(), ann.OptimizerOptions())

    Args:
        network (INetwork): INetwork description of the network to be optimized.
        backendPreferences (list): The choice of the backend ordered by user preferences. See `BackendId`.
        deviceSpec (IDeviceSpec): DeviceSpec object as queried from the runtime. See `IRuntime.GetDeviceSpec`.
        options (OptimizerOptions): Object with optimizer configuration options.

    Returns:
        tuple: (`IOptimizedNetwork`, a tuple of failures or warnings).

    Raises:
        RuntimeError: If process fails.

    """
    return _pyarmnn.Optimize(*args)
class IProfiler(object):
    r"""

    Interface for profiling Arm NN. See `IRuntime.GetProfiler`.

    IProfiler object allows you to enable profiling and get various profiling results.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def EnableProfiling(self, enableProfiling):
        r"""

        Sets the profiler to start/stop profiling.

        Args:
            enableProfiling (bool): Flag to enable/disable profiling.


        """
        return _pyarmnn.IProfiler_EnableProfiling(self, enableProfiling)

    def IsProfilingEnabled(self):
        r"""

        Checks if profiling is enabled.

        Returns:
            bool: If profiling is enabled or not.


        """
        return _pyarmnn.IProfiler_IsProfilingEnabled(self)

    def event_log(self):
        r"""

        Gets the string value of the profiling events analysis log.

        Returns:
            str: The profiling events analysis log.


        """
        return _pyarmnn.IProfiler_event_log(self)

    def as_json(self):
        r"""

        Gets the profiling log as the JSON string.

        Returns:
            str: Profiling log as JSON formatted string.


        """
        return _pyarmnn.IProfiler_as_json(self)

# Register IProfiler in _pyarmnn:
_pyarmnn.IProfiler_swigregister(IProfiler)

class IntPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.IntPair_swiginit(self, _pyarmnn.new_IntPair(*args))
    first = property(_pyarmnn.IntPair_first_get, _pyarmnn.IntPair_first_set)
    second = property(_pyarmnn.IntPair_second_get, _pyarmnn.IntPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyarmnn.delete_IntPair

# Register IntPair in _pyarmnn:
_pyarmnn.IntPair_swigregister(IntPair)

class ConstTensorPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.ConstTensorPair_swiginit(self, _pyarmnn.new_ConstTensorPair(*args))
    first = property(_pyarmnn.ConstTensorPair_first_get, _pyarmnn.ConstTensorPair_first_set)
    second = property(_pyarmnn.ConstTensorPair_second_get, _pyarmnn.ConstTensorPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyarmnn.delete_ConstTensorPair

# Register ConstTensorPair in _pyarmnn:
_pyarmnn.ConstTensorPair_swigregister(ConstTensorPair)

class TensorPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.TensorPair_swiginit(self, _pyarmnn.new_TensorPair(*args))
    first = property(_pyarmnn.TensorPair_first_get, _pyarmnn.TensorPair_first_set)
    second = property(_pyarmnn.TensorPair_second_get, _pyarmnn.TensorPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyarmnn.delete_TensorPair

# Register TensorPair in _pyarmnn:
_pyarmnn.TensorPair_swigregister(TensorPair)

class InputTensorsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyarmnn.InputTensorsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyarmnn.InputTensorsVector___nonzero__(self)

    def __bool__(self):
        return _pyarmnn.InputTensorsVector___bool__(self)

    def __len__(self):
        return _pyarmnn.InputTensorsVector___len__(self)

    def __getslice__(self, i, j):
        return _pyarmnn.InputTensorsVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyarmnn.InputTensorsVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyarmnn.InputTensorsVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyarmnn.InputTensorsVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyarmnn.InputTensorsVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyarmnn.InputTensorsVector___setitem__(self, *args)

    def pop(self):
        return _pyarmnn.InputTensorsVector_pop(self)

    def append(self, x):
        return _pyarmnn.InputTensorsVector_append(self, x)

    def empty(self):
        return _pyarmnn.InputTensorsVector_empty(self)

    def size(self):
        return _pyarmnn.InputTensorsVector_size(self)

    def swap(self, v):
        return _pyarmnn.InputTensorsVector_swap(self, v)

    def begin(self):
        return _pyarmnn.InputTensorsVector_begin(self)

    def end(self):
        return _pyarmnn.InputTensorsVector_end(self)

    def rbegin(self):
        return _pyarmnn.InputTensorsVector_rbegin(self)

    def rend(self):
        return _pyarmnn.InputTensorsVector_rend(self)

    def clear(self):
        return _pyarmnn.InputTensorsVector_clear(self)

    def get_allocator(self):
        return _pyarmnn.InputTensorsVector_get_allocator(self)

    def pop_back(self):
        return _pyarmnn.InputTensorsVector_pop_back(self)

    def erase(self, *args):
        return _pyarmnn.InputTensorsVector_erase(self, *args)

    def __init__(self, *args):
        _pyarmnn.InputTensorsVector_swiginit(self, _pyarmnn.new_InputTensorsVector(*args))

    def push_back(self, x):
        return _pyarmnn.InputTensorsVector_push_back(self, x)

    def front(self):
        return _pyarmnn.InputTensorsVector_front(self)

    def back(self):
        return _pyarmnn.InputTensorsVector_back(self)

    def assign(self, n, x):
        return _pyarmnn.InputTensorsVector_assign(self, n, x)

    def resize(self, *args):
        return _pyarmnn.InputTensorsVector_resize(self, *args)

    def insert(self, *args):
        return _pyarmnn.InputTensorsVector_insert(self, *args)

    def reserve(self, n):
        return _pyarmnn.InputTensorsVector_reserve(self, n)

    def capacity(self):
        return _pyarmnn.InputTensorsVector_capacity(self)
    __swig_destroy__ = _pyarmnn.delete_InputTensorsVector

# Register InputTensorsVector in _pyarmnn:
_pyarmnn.InputTensorsVector_swigregister(InputTensorsVector)

class OutputTensorsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyarmnn.OutputTensorsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyarmnn.OutputTensorsVector___nonzero__(self)

    def __bool__(self):
        return _pyarmnn.OutputTensorsVector___bool__(self)

    def __len__(self):
        return _pyarmnn.OutputTensorsVector___len__(self)

    def __getslice__(self, i, j):
        return _pyarmnn.OutputTensorsVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyarmnn.OutputTensorsVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyarmnn.OutputTensorsVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyarmnn.OutputTensorsVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyarmnn.OutputTensorsVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyarmnn.OutputTensorsVector___setitem__(self, *args)

    def pop(self):
        return _pyarmnn.OutputTensorsVector_pop(self)

    def append(self, x):
        return _pyarmnn.OutputTensorsVector_append(self, x)

    def empty(self):
        return _pyarmnn.OutputTensorsVector_empty(self)

    def size(self):
        return _pyarmnn.OutputTensorsVector_size(self)

    def swap(self, v):
        return _pyarmnn.OutputTensorsVector_swap(self, v)

    def begin(self):
        return _pyarmnn.OutputTensorsVector_begin(self)

    def end(self):
        return _pyarmnn.OutputTensorsVector_end(self)

    def rbegin(self):
        return _pyarmnn.OutputTensorsVector_rbegin(self)

    def rend(self):
        return _pyarmnn.OutputTensorsVector_rend(self)

    def clear(self):
        return _pyarmnn.OutputTensorsVector_clear(self)

    def get_allocator(self):
        return _pyarmnn.OutputTensorsVector_get_allocator(self)

    def pop_back(self):
        return _pyarmnn.OutputTensorsVector_pop_back(self)

    def erase(self, *args):
        return _pyarmnn.OutputTensorsVector_erase(self, *args)

    def __init__(self, *args):
        _pyarmnn.OutputTensorsVector_swiginit(self, _pyarmnn.new_OutputTensorsVector(*args))

    def push_back(self, x):
        return _pyarmnn.OutputTensorsVector_push_back(self, x)

    def front(self):
        return _pyarmnn.OutputTensorsVector_front(self)

    def back(self):
        return _pyarmnn.OutputTensorsVector_back(self)

    def assign(self, n, x):
        return _pyarmnn.OutputTensorsVector_assign(self, n, x)

    def resize(self, *args):
        return _pyarmnn.OutputTensorsVector_resize(self, *args)

    def insert(self, *args):
        return _pyarmnn.OutputTensorsVector_insert(self, *args)

    def reserve(self, n):
        return _pyarmnn.OutputTensorsVector_reserve(self, n)

    def capacity(self):
        return _pyarmnn.OutputTensorsVector_capacity(self)
    __swig_destroy__ = _pyarmnn.delete_OutputTensorsVector

# Register OutputTensorsVector in _pyarmnn:
_pyarmnn.OutputTensorsVector_swigregister(OutputTensorsVector)

SHARED_PTR_DISOWN = _pyarmnn.SHARED_PTR_DISOWN
class CreationOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        Structure for holding creation options. For majority of cases it is fine to leave values at default.

        Contains:
            m_GpuAccTunedParameters (IGpuAccTunedParameters): If set, uses the GpuAcc tuned parameters from the given object
                                                              when executing GPU workloads. It will also be updated with new
                                                              tuned parameters if it is configured to do so.

            m_EnableGpuProfiling (bool): Setting this flag will allow the user to obtain GPU profiling information from
                                         the runtime.

            m_DynamicBackendsPath (string): Setting this value will override the paths set by the DYNAMIC_BACKEND_PATHS
                                            compiler directive. Only a single path is allowed for the override.


        """
        _pyarmnn.CreationOptions_swiginit(self, _pyarmnn.new_CreationOptions())
    m_GpuAccTunedParameters = property(_pyarmnn.CreationOptions_m_GpuAccTunedParameters_get, _pyarmnn.CreationOptions_m_GpuAccTunedParameters_set)
    m_EnableGpuProfiling = property(_pyarmnn.CreationOptions_m_EnableGpuProfiling_get, _pyarmnn.CreationOptions_m_EnableGpuProfiling_set)
    m_DynamicBackendsPath = property(_pyarmnn.CreationOptions_m_DynamicBackendsPath_get, _pyarmnn.CreationOptions_m_DynamicBackendsPath_set)
    __swig_destroy__ = _pyarmnn.delete_CreationOptions

# Register CreationOptions in _pyarmnn:
_pyarmnn.CreationOptions_swigregister(CreationOptions)

class INetworkProperties(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, importEnabled=False, exportEnabled=False):
        r"""

        Structure for holding network properties.

        Contains:
            m_ImportEnabled (bool): Enable import.

            m_ExportEnabled (bool): Enable export.


        """
        _pyarmnn.INetworkProperties_swiginit(self, _pyarmnn.new_INetworkProperties(importEnabled, exportEnabled))
    m_ImportEnabled = property(_pyarmnn.INetworkProperties_m_ImportEnabled_get)
    m_ExportEnabled = property(_pyarmnn.INetworkProperties_m_ExportEnabled_get)
    __swig_destroy__ = _pyarmnn.delete_INetworkProperties

# Register INetworkProperties in _pyarmnn:
_pyarmnn.INetworkProperties_swigregister(INetworkProperties)

class IRuntime(object):
    r"""

    Interface for runtime objects.

    Runtime objects are responsible for performing inference on an `IOptimizedNetwork`.

    Args:
        options (CreationOptions): CreationOptions data struct.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def GetInputTensorInfo(self, networkId, layerId):
        r"""

        Get information relating to networks input tensor.

        Args:
            networkId (int): Unique ID of the network being run.
            layerId (int): Unique ID of the input layer.

        Returns:
            TensorInfo: Information relating to the input tensor a network.

        """
        return _pyarmnn.IRuntime_GetInputTensorInfo(self, networkId, layerId)

    def GetOutputTensorInfo(self, networkId, layerId):
        r"""

        Get information relating to networks output tensor.

        Args:
            networkId (int): Unique ID of the network being run.
            layerId (int): Unique ID of the output layer.

        Returns:
            TensorInfo: Information relating to the output tensor a network.

        """
        return _pyarmnn.IRuntime_GetOutputTensorInfo(self, networkId, layerId)

    def GetDeviceSpec(self):
        r"""

        Get information relating supported compute backends on current device.

        Returns:
            IDeviceSpec: Device spec information detailing all supported backends on current platform.

        """
        return _pyarmnn.IRuntime_GetDeviceSpec(self)

    def LoadNetwork(self, network, networkProperties=None):
        r"""

        Loads a complete network into the IRuntime.
        The runtime takes ownership of the network once passed in.
        Args:
            network (IOptimizedNetwork): An optimized network to load into the IRuntime.
            networkProperties (INetworkProperties): Properties that allows the user to opt-in to import/export behavior. Default: None.
        Returns:
            tuple: (int, str) Network id and non fatal failure or warning messsages.
        Raises:
            RuntimeError: If process fails.

        """
        return _pyarmnn.IRuntime_LoadNetwork(self, network, networkProperties)

    def EnqueueWorkload(self, networkId, inputTensors, outputTensors):
        r"""

        Calling this function will perform an inference on your network.

        Args:
            networkId (int): Unique ID of the network to run.
            inputTensors (list): A list of tuples (int, `ConstTensor`), see `make_input_tensors`.
            outputTensors (list): A list of tuples (int, `Tensor`), see `make_output_tensors`.


        """
        return _pyarmnn.IRuntime_EnqueueWorkload(self, networkId, inputTensors, outputTensors)

    def UnloadNetwork(self, networkId):
        r"""

        Unload a currently loaded network from the runtime.

        Args:
            networkId (int): Unique ID of the network to unload.


        """
        return _pyarmnn.IRuntime_UnloadNetwork(self, networkId)

    def GetProfiler(self, networkId):
        r"""

        Returns the IProfiler instance registered against the working thread, and stored on the loaded network.
        Be aware that if the runtime has unloaded the network, or if the runtime is destroyed,
        that the IProfiler instance will also be destroyed, and will cause a segmentation fault.

        Args:
            networkId (int): The ID of the loaded network you want to profile.

        Returns:
            IProfiler: IProfiler instance the given loaded network has stored.

        Raises:
            RuntimeError: If no profiler is found.

        """
        return _pyarmnn.IRuntime_GetProfiler(self, networkId)
    __swig_destroy__ = _pyarmnn.delete_IRuntime

    def __init__(self, options):
        _pyarmnn.IRuntime_swiginit(self, _pyarmnn.new_IRuntime(options))

# Register IRuntime in _pyarmnn:
_pyarmnn.IRuntime_swigregister(IRuntime)

class TensorShape(object):
    r"""

    Class for holding the shape information of an Arm NN tensor.

    This class is iterable. You can iterate over it to get each value of the Tensor shape.

    Examples:
        Obtain tensor shape information as a list.
        >>> import pyarmnn as ann
        >>> import numpy as np
        >>>
        >>> tensor_info = ann.TensorInfo(ann.TensorShape((4, 2, 1, 3)), ann.DataType_Float32)
        >>> tensor = ann.ConstTensor(tensor_info, np.ones([4, 2, 1, 3], dtype=np.float32))
        >>> print(list(tensor.GetShape()))
        [4, 2, 1, 3]


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __iter__(self):
        for dim in range(self.GetNumDimensions()):
            yield self[dim]


    def __init__(self, numDimensions):
        _pyarmnn.TensorShape_swiginit(self, _pyarmnn.new_TensorShape(numDimensions))

    def GetNumDimensions(self):
        r"""

        Returns the number of dimensions in this TensorShape.

        Returns:
            int: The number of dimensions in this TensorShape.


        """
        return _pyarmnn.TensorShape_GetNumDimensions(self)

    def GetNumElements(self):
        r"""

        Returns the total number of elements for a tensor with this TensorShape.

        Returns:
            int: The total number of elements for a tensor with this TensorShape.


        """
        return _pyarmnn.TensorShape_GetNumElements(self)

    def __getitem__(self, i):
        return _pyarmnn.TensorShape___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyarmnn.TensorShape___setitem__(self, i, val)

    def __str__(self):
        return _pyarmnn.TensorShape___str__(self)
    __swig_destroy__ = _pyarmnn.delete_TensorShape

# Register TensorShape in _pyarmnn:
_pyarmnn.TensorShape_swigregister(TensorShape)

class TensorInfo(object):
    r"""

    Class for holding the tensor information of an Arm NN tensor such as quantization, datatype, shape etc.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyarmnn.TensorInfo_swiginit(self, _pyarmnn.new_TensorInfo(*args))

    def GetShape(self):
        r"""

        Get the tensor shape.

        Return:
            TensorShape: Current shape of the tensor.


        """
        return _pyarmnn.TensorInfo_GetShape(self)

    def SetShape(self, newShape):
        r"""

        Set the tensor shape. Must have the same number of elements as current tensor.

        Args:
            newShape (TensorShape): New tensor shape to reshape to.


        """
        return _pyarmnn.TensorInfo_SetShape(self, newShape)

    def GetNumDimensions(self):
        r"""

        Returns the number of dimensions in this Tensor.

        Returns:
            int: The number of dimensions in this Tensor.


        """
        return _pyarmnn.TensorInfo_GetNumDimensions(self)

    def GetNumElements(self):
        r"""

        Returns the total number of elements for this Tensor.

        Returns:
            int: The total number of elements for this Tensor.


        """
        return _pyarmnn.TensorInfo_GetNumElements(self)

    def GetDataType(self):
        r"""

        Get the tensor datatype.

        Returns:
            DataType: Current tensor DataType.


        """
        return _pyarmnn.TensorInfo_GetDataType(self)

    def SetDataType(self, type):
        r"""

        Set the tensor datatype.

        Args:
            type (DataType): DataType to set the tensor to.


        """
        return _pyarmnn.TensorInfo_SetDataType(self, type)

    def GetQuantizationScale(self):
        r"""

        Get the value of the tensors quantization scale.

        Returns:
            float: Tensor quantization scale value.


        """
        return _pyarmnn.TensorInfo_GetQuantizationScale(self)

    def GetQuantizationOffset(self):
        r"""

        Get the value of the tensors quantization offset.

        Returns:
            int: Tensor quantization offset value.


        """
        return _pyarmnn.TensorInfo_GetQuantizationOffset(self)

    def SetQuantizationScale(self, scale):
        r"""

        Set the value of the tensors quantization scale.

        Args:
            scale (float): Scale value to set.


        """
        return _pyarmnn.TensorInfo_SetQuantizationScale(self, scale)

    def SetQuantizationOffset(self, offset):
        r"""

        Set the value of the tensors quantization offset.

        Args:
            offset (int): Offset value to set.


        """
        return _pyarmnn.TensorInfo_SetQuantizationOffset(self, offset)

    def IsQuantized(self):
        r"""

        Returns true if the tensor is a quantized data type.

        Returns:
            bool: True if the tensor is a quantized data type.


        """
        return _pyarmnn.TensorInfo_IsQuantized(self)

    def IsTypeSpaceMatch(self, other):
        r"""

        Check that the types are the same and, if quantize, that the quantization parameters are the same.

        Returns:
            bool: True if matched, else False.


        """
        return _pyarmnn.TensorInfo_IsTypeSpaceMatch(self, other)

    def GetNumBytes(self):
        r"""

        Get the number of bytes needed for this tensor.

        Returns:
            int: Number of bytes consumed by this tensor.


        """
        return _pyarmnn.TensorInfo_GetNumBytes(self)

    def __str__(self):
        return _pyarmnn.TensorInfo___str__(self)
    __swig_destroy__ = _pyarmnn.delete_TensorInfo

# Register TensorInfo in _pyarmnn:
_pyarmnn.TensorInfo_swigregister(TensorInfo)

class Tensor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyarmnn.delete_Tensor

    def __init__(self, *args):
        _pyarmnn.Tensor_swiginit(self, _pyarmnn.new_Tensor(*args))

    def GetInfo(self):
        return _pyarmnn.Tensor_GetInfo(self)

    def GetShape(self):
        return _pyarmnn.Tensor_GetShape(self)

    def GetDataType(self):
        return _pyarmnn.Tensor_GetDataType(self)

    def GetNumDimensions(self):
        return _pyarmnn.Tensor_GetNumDimensions(self)

    def GetNumBytes(self):
        return _pyarmnn.Tensor_GetNumBytes(self)

    def GetNumElements(self):
        return _pyarmnn.Tensor_GetNumElements(self)

    def __str__(self):
        return _pyarmnn.Tensor___str__(self)

# Register Tensor in _pyarmnn:
_pyarmnn.Tensor_swigregister(Tensor)

class ConstTensor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyarmnn.delete_ConstTensor

    def __init__(self, *args):
        _pyarmnn.ConstTensor_swiginit(self, _pyarmnn.new_ConstTensor(*args))

    def GetInfo(self):
        return _pyarmnn.ConstTensor_GetInfo(self)

    def GetShape(self):
        return _pyarmnn.ConstTensor_GetShape(self)

    def GetDataType(self):
        return _pyarmnn.ConstTensor_GetDataType(self)

    def GetNumDimensions(self):
        return _pyarmnn.ConstTensor_GetNumDimensions(self)

    def GetNumBytes(self):
        return _pyarmnn.ConstTensor_GetNumBytes(self)

    def GetNumElements(self):
        return _pyarmnn.ConstTensor_GetNumElements(self)

    def __str__(self):
        return _pyarmnn.ConstTensor___str__(self)

# Register ConstTensor in _pyarmnn:
_pyarmnn.ConstTensor_swigregister(ConstTensor)


def GetDataTypeSize(dataType):
    return _pyarmnn.GetDataTypeSize(dataType)

def GetDataTypeName(dataType):
    return _pyarmnn.GetDataTypeName(dataType)

def Quantize_uint8_t(value, scale, offset):
    return _pyarmnn.Quantize_uint8_t(value, scale, offset)

def Quantize_int8_t(value, scale, offset):
    return _pyarmnn.Quantize_int8_t(value, scale, offset)

def Quantize_int16_t(value, scale, offset):
    return _pyarmnn.Quantize_int16_t(value, scale, offset)

def Quantize_int32_t(value, scale, offset):
    return _pyarmnn.Quantize_int32_t(value, scale, offset)

def Dequantize_uint8_t(value, scale, offset):
    return _pyarmnn.Dequantize_uint8_t(value, scale, offset)

def Dequantize_int8_t(value, scale, offset):
    return _pyarmnn.Dequantize_int8_t(value, scale, offset)

def Dequantize_int16_t(value, scale, offset):
    return _pyarmnn.Dequantize_int16_t(value, scale, offset)

def Dequantize_int32_t(value, scale, offset):
    return _pyarmnn.Dequantize_int32_t(value, scale, offset)


