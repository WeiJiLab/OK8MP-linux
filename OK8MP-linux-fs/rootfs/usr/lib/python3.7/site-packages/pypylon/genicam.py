# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""

Copyright (C) 2017-2018 Basler AG
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.
    3. Neither the name of the copyright holder nor the names of its contributors
       may be used to endorse or promote products derived from this software
       without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_genicam')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_genicam')
    _genicam = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_genicam', [dirname(__file__)])
        except ImportError:
            import _genicam
            return _genicam
        try:
            _mod = imp.load_module('_genicam', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _genicam = swig_import_helper()
    del swig_import_helper
else:
    import _genicam
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genicam.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _genicam.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _genicam.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _genicam.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _genicam.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _genicam.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _genicam.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _genicam.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _genicam.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _genicam.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _genicam.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _genicam.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _genicam.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class ios_base(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _genicam.ios_base_erase_event
    imbue_event = _genicam.ios_base_imbue_event
    copyfmt_event = _genicam.ios_base_copyfmt_event

    def register_callback(self, __fn: 'std::ios_base::event_callback', __index: 'int') -> "void":
        return _genicam.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args) -> "std::ios_base::fmtflags":
        return _genicam.ios_base_flags(self, *args)

    def setf(self, *args) -> "std::ios_base::fmtflags":
        return _genicam.ios_base_setf(self, *args)

    def unsetf(self, __mask: 'std::ios_base::fmtflags') -> "void":
        return _genicam.ios_base_unsetf(self, __mask)

    def precision(self, *args) -> "std::streamsize":
        return _genicam.ios_base_precision(self, *args)

    def width(self, *args) -> "std::streamsize":
        return _genicam.ios_base_width(self, *args)
    sync_with_stdio = staticmethod(_genicam.ios_base_sync_with_stdio)

    def imbue(self, __loc: 'std::locale const &') -> "std::locale":
        return _genicam.ios_base_imbue(self, __loc)

    def getloc(self) -> "std::locale":
        return _genicam.ios_base_getloc(self)
    xalloc = staticmethod(_genicam.ios_base_xalloc)

    def iword(self, __ix: 'int') -> "long &":
        return _genicam.ios_base_iword(self, __ix)

    def pword(self, __ix: 'int') -> "void *&":
        return _genicam.ios_base_pword(self, __ix)
    __swig_destroy__ = _genicam.delete_ios_base
    __del__ = lambda self: None
ios_base_swigregister = _genicam.ios_base_swigregister
ios_base_swigregister(ios_base)
cvar = _genicam.cvar
ios_base.boolalpha = _genicam.cvar.ios_base_boolalpha
ios_base.dec = _genicam.cvar.ios_base_dec
ios_base.fixed = _genicam.cvar.ios_base_fixed
ios_base.hex = _genicam.cvar.ios_base_hex
ios_base.internal = _genicam.cvar.ios_base_internal
ios_base.left = _genicam.cvar.ios_base_left
ios_base.oct = _genicam.cvar.ios_base_oct
ios_base.right = _genicam.cvar.ios_base_right
ios_base.scientific = _genicam.cvar.ios_base_scientific
ios_base.showbase = _genicam.cvar.ios_base_showbase
ios_base.showpoint = _genicam.cvar.ios_base_showpoint
ios_base.showpos = _genicam.cvar.ios_base_showpos
ios_base.skipws = _genicam.cvar.ios_base_skipws
ios_base.unitbuf = _genicam.cvar.ios_base_unitbuf
ios_base.uppercase = _genicam.cvar.ios_base_uppercase
ios_base.adjustfield = _genicam.cvar.ios_base_adjustfield
ios_base.basefield = _genicam.cvar.ios_base_basefield
ios_base.floatfield = _genicam.cvar.ios_base_floatfield
ios_base.badbit = _genicam.cvar.ios_base_badbit
ios_base.eofbit = _genicam.cvar.ios_base_eofbit
ios_base.failbit = _genicam.cvar.ios_base_failbit
ios_base.goodbit = _genicam.cvar.ios_base_goodbit
ios_base.app = _genicam.cvar.ios_base_app
ios_base.ate = _genicam.cvar.ios_base_ate
ios_base.binary = _genicam.cvar.ios_base_binary
ios_base.ios_base_in = _genicam.cvar.ios_base_ios_base_in
ios_base.out = _genicam.cvar.ios_base_out
ios_base.trunc = _genicam.cvar.ios_base_trunc
ios_base.beg = _genicam.cvar.ios_base_beg
ios_base.cur = _genicam.cvar.ios_base_cur
ios_base.end = _genicam.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync: 'bool'=True) -> "bool":
    return _genicam.ios_base_sync_with_stdio(__sync)
ios_base_sync_with_stdio = _genicam.ios_base_sync_with_stdio

def ios_base_xalloc() -> "int":
    return _genicam.ios_base_xalloc()
ios_base_xalloc = _genicam.ios_base_xalloc

class ios(ios_base):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def rdstate(self) -> "std::ios_base::iostate":
        return _genicam.ios_rdstate(self)

    def clear(self, *args) -> "void":
        return _genicam.ios_clear(self, *args)

    def setstate(self, __state: 'std::ios_base::iostate') -> "void":
        return _genicam.ios_setstate(self, __state)

    def good(self) -> "bool":
        return _genicam.ios_good(self)

    def eof(self) -> "bool":
        return _genicam.ios_eof(self)

    def fail(self) -> "bool":
        return _genicam.ios_fail(self)

    def bad(self) -> "bool":
        return _genicam.ios_bad(self)

    def exceptions(self, *args) -> "void":
        return _genicam.ios_exceptions(self, *args)

    def __init__(self, __sb: 'std::basic_streambuf< char,std::char_traits< char > > *'):
        this = _genicam.new_ios(__sb)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ios
    __del__ = lambda self: None

    def tie(self, *args) -> "std::basic_ostream< char,std::char_traits< char > > *":
        return _genicam.ios_tie(self, *args)

    def rdbuf(self, *args) -> "std::basic_streambuf< char,std::char_traits< char > > *":
        return _genicam.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs: 'ios') -> "std::basic_ios< char > &":
        return _genicam.ios_copyfmt(self, __rhs)

    def fill(self, *args) -> "std::basic_ios< char >::char_type":
        return _genicam.ios_fill(self, *args)

    def imbue(self, __loc: 'std::locale const &') -> "std::locale":
        return _genicam.ios_imbue(self, __loc)

    def narrow(self, __c: 'std::basic_ios< char >::char_type', __dfault: 'char') -> "char":
        return _genicam.ios_narrow(self, __c, __dfault)

    def widen(self, __c: 'char') -> "std::basic_ios< char >::char_type":
        return _genicam.ios_widen(self, __c)
ios_swigregister = _genicam.ios_swigregister
ios_swigregister(ios)


GenericException = _genicam.GenericException


BadAllocException = _genicam.BadAllocException


InvalidArgumentException = _genicam.InvalidArgumentException


OutOfRangeException = _genicam.OutOfRangeException


PropertyException = _genicam.PropertyException


RuntimeException = _genicam.RuntimeException


LogicalErrorException = _genicam.LogicalErrorException


AccessException = _genicam.AccessException


TimeoutException = _genicam.TimeoutException


DynamicCastException = _genicam.DynamicCastException


def TranslateGenicamException(_gcex_e: 'GenericException const *') -> "GenericException const *":
    return _genicam.TranslateGenicamException(_gcex_e)
TranslateGenicamException = _genicam.TranslateGenicamException
Signed = _genicam.Signed
Unsigned = _genicam.Unsigned
_UndefinedSign = _genicam._UndefinedSign
NI = _genicam.NI
NA = _genicam.NA
WO = _genicam.WO
RO = _genicam.RO
RW = _genicam.RW
_UndefinedAccesMode = _genicam._UndefinedAccesMode
_CycleDetectAccesMode = _genicam._CycleDetectAccesMode
Beginner = _genicam.Beginner
Expert = _genicam.Expert
Guru = _genicam.Guru
Invisible = _genicam.Invisible
_UndefinedVisibility = _genicam._UndefinedVisibility
NoCache = _genicam.NoCache
WriteThrough = _genicam.WriteThrough
WriteAround = _genicam.WriteAround
_UndefinedCachingMode = _genicam._UndefinedCachingMode
Linear = _genicam.Linear
Logarithmic = _genicam.Logarithmic
Boolean = _genicam.Boolean
PureNumber = _genicam.PureNumber
HexNumber = _genicam.HexNumber
IPV4Address = _genicam.IPV4Address
MACAddress = _genicam.MACAddress
_UndefinedRepresentation = _genicam._UndefinedRepresentation
BigEndian = _genicam.BigEndian
LittleEndian = _genicam.LittleEndian
_UndefinedEndian = _genicam._UndefinedEndian
Custom = _genicam.Custom
Standard = _genicam.Standard
_UndefinedNameSpace = _genicam._UndefinedNameSpace
_None = _genicam._None
GEV = _genicam.GEV
IIDC = _genicam.IIDC
CL = _genicam.CL
USB = _genicam.USB
_UndefinedStandardNameSpace = _genicam._UndefinedStandardNameSpace
Yes = _genicam.Yes
No = _genicam.No
_UndefinedYesNo = _genicam._UndefinedYesNo
Increasing = _genicam.Increasing
Decreasing = _genicam.Decreasing
Varying = _genicam.Varying
Automatic = _genicam.Automatic
_UndefinedESlope = _genicam._UndefinedESlope
xvLoad = _genicam.xvLoad
xvCycles = _genicam.xvCycles
xvSFNC = _genicam.xvSFNC
xvDefault = _genicam.xvDefault
xvAll = _genicam.xvAll
_UndefinedEXMLValidation = _genicam._UndefinedEXMLValidation
fnAutomatic = _genicam.fnAutomatic
fnFixed = _genicam.fnFixed
fnScientific = _genicam.fnScientific
_UndefinedEDisplayNotation = _genicam._UndefinedEDisplayNotation
intfIValue = _genicam.intfIValue
intfIBase = _genicam.intfIBase
intfIInteger = _genicam.intfIInteger
intfIBoolean = _genicam.intfIBoolean
intfICommand = _genicam.intfICommand
intfIFloat = _genicam.intfIFloat
intfIString = _genicam.intfIString
intfIRegister = _genicam.intfIRegister
intfICategory = _genicam.intfICategory
intfIEnumeration = _genicam.intfIEnumeration
intfIEnumEntry = _genicam.intfIEnumEntry
intfIPort = _genicam.intfIPort
ctParentNodes = _genicam.ctParentNodes
ctReadingChildren = _genicam.ctReadingChildren
ctWritingChildren = _genicam.ctWritingChildren
ctInvalidatingChildren = _genicam.ctInvalidatingChildren
ctDependingNodes = _genicam.ctDependingNodes
ctTerminalNodes = _genicam.ctTerminalNodes
ctValueChangingChildren = _genicam.ctValueChangingChildren
noIncrement = _genicam.noIncrement
fixedIncrement = _genicam.fixedIncrement
listIncrement = _genicam.listIncrement
idFrom = _genicam.idFrom
idTo = _genicam.idTo
idNone = _genicam.idNone
class ESignClass(object):
    """


    ESignClass holds conversion methods for the sign enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ESign *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.ESignClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.ESignClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_ESignClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ESignClass
    __del__ = lambda self: None
ESignClass_swigregister = _genicam.ESignClass_swigregister
ESignClass_swigregister(ESignClass)

def ESignClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ESign *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.ESignClass_FromString(ValueStr, pValue)

def ESignClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.ESignClass_ToString(*args)

class EEndianessClass(object):
    """


    EEndianessClass holds conversion methods for the endianess enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EEndianess *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.EEndianessClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.EEndianessClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_EEndianessClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EEndianessClass
    __del__ = lambda self: None
EEndianessClass_swigregister = _genicam.EEndianessClass_swigregister
EEndianessClass_swigregister(EEndianessClass)

def EEndianessClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EEndianess *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.EEndianessClass_FromString(ValueStr, pValue)

def EEndianessClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.EEndianessClass_ToString(*args)

class ERepresentationClass(object):
    """


    ERepresentationClass holds conversion methods for the representation
    enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ERepresentation *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.ERepresentationClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.ERepresentationClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_ERepresentationClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ERepresentationClass
    __del__ = lambda self: None
ERepresentationClass_swigregister = _genicam.ERepresentationClass_swigregister
ERepresentationClass_swigregister(ERepresentationClass)

def ERepresentationClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ERepresentation *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.ERepresentationClass_FromString(ValueStr, pValue)

def ERepresentationClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.ERepresentationClass_ToString(*args)

class EVisibilityClass(object):
    """


    EVisibilityClass holds conversion methods for the visibility enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EVisibility *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.EVisibilityClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.EVisibilityClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_EVisibilityClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EVisibilityClass
    __del__ = lambda self: None
EVisibilityClass_swigregister = _genicam.EVisibilityClass_swigregister
EVisibilityClass_swigregister(EVisibilityClass)

def EVisibilityClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EVisibility *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.EVisibilityClass_FromString(ValueStr, pValue)

def EVisibilityClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.EVisibilityClass_ToString(*args)

class EAccessModeClass(object):
    """


    EAccessModeClass holds conversion methods for the access mode enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EAccessMode *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.EAccessModeClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.EAccessModeClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_EAccessModeClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EAccessModeClass
    __del__ = lambda self: None
EAccessModeClass_swigregister = _genicam.EAccessModeClass_swigregister
EAccessModeClass_swigregister(EAccessModeClass)

def EAccessModeClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EAccessMode *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.EAccessModeClass_FromString(ValueStr, pValue)

def EAccessModeClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.EAccessModeClass_ToString(*args)

class ECachingModeClass(object):
    """


    ECachingModeClass holds conversion methods for the caching mode enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ECachingMode *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.ECachingModeClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.ECachingModeClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_ECachingModeClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ECachingModeClass
    __del__ = lambda self: None
ECachingModeClass_swigregister = _genicam.ECachingModeClass_swigregister
ECachingModeClass_swigregister(ECachingModeClass)

def ECachingModeClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ECachingMode *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.ECachingModeClass_FromString(ValueStr, pValue)

def ECachingModeClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.ECachingModeClass_ToString(*args)

class ENameSpaceClass(object):
    """


    Holds conversion methods for the namespace enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ENameSpace *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.ENameSpaceClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.ENameSpaceClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_ENameSpaceClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ENameSpaceClass
    __del__ = lambda self: None
ENameSpaceClass_swigregister = _genicam.ENameSpaceClass_swigregister
ENameSpaceClass_swigregister(ENameSpaceClass)

def ENameSpaceClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ENameSpace *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.ENameSpaceClass_FromString(ValueStr, pValue)

def ENameSpaceClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.ENameSpaceClass_ToString(*args)

class EYesNoClass(object):
    """


    Holds conversion methods for the standard namespace enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EYesNo *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.EYesNoClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.EYesNoClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_EYesNoClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EYesNoClass
    __del__ = lambda self: None
EYesNoClass_swigregister = _genicam.EYesNoClass_swigregister
EYesNoClass_swigregister(EYesNoClass)

def EYesNoClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EYesNo *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.EYesNoClass_FromString(ValueStr, pValue)

def EYesNoClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.EYesNoClass_ToString(*args)

class EStandardNameSpaceClass(object):
    """


    Holds conversion methods for the standard namespace enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EStandardNameSpace *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.EStandardNameSpaceClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.EStandardNameSpaceClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_EStandardNameSpaceClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EStandardNameSpaceClass
    __del__ = lambda self: None
EStandardNameSpaceClass_swigregister = _genicam.EStandardNameSpaceClass_swigregister
EStandardNameSpaceClass_swigregister(EStandardNameSpaceClass)

def EStandardNameSpaceClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EStandardNameSpace *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.EStandardNameSpaceClass_FromString(ValueStr, pValue)

def EStandardNameSpaceClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.EStandardNameSpaceClass_ToString(*args)

class ESlopeClass(object):
    """


    Holds conversion methods for the converter formulas.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ESlope *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.ESlopeClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.ESlopeClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_ESlopeClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ESlopeClass
    __del__ = lambda self: None
ESlopeClass_swigregister = _genicam.ESlopeClass_swigregister
ESlopeClass_swigregister(ESlopeClass)

def ESlopeClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::ESlope *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.ESlopeClass_FromString(ValueStr, pValue)

def ESlopeClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.ESlopeClass_ToString(*args)

class EDisplayNotationClass(object):
    """


    Holds conversion methods for the notation type of floats.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EDisplayNotation *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.EDisplayNotationClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.EDisplayNotationClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_EDisplayNotationClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EDisplayNotationClass
    __del__ = lambda self: None
EDisplayNotationClass_swigregister = _genicam.EDisplayNotationClass_swigregister
EDisplayNotationClass_swigregister(EDisplayNotationClass)

def EDisplayNotationClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EDisplayNotation *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.EDisplayNotationClass_FromString(ValueStr, pValue)

def EDisplayNotationClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.EDisplayNotationClass_ToString(*args)

class EInputDirectionClass(object):
    """


    Holds conversion methods for the notation type of floats.  

    C++ includes: EnumClasses.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EInputDirection *') -> "GENICAM_NAMESPACE::gcstring const &":
        """


        Converts a string to enum value.  

        """
        return _genicam.EInputDirectionClass_FromString(ValueStr, pValue)

    FromString = staticmethod(FromString)

    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        """


        Converts a string to an int32_t property.  

        """
        return _genicam.EInputDirectionClass_ToString(*args)

    ToString = staticmethod(ToString)

    def __init__(self):
        this = _genicam.new_EInputDirectionClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EInputDirectionClass
    __del__ = lambda self: None
EInputDirectionClass_swigregister = _genicam.EInputDirectionClass_swigregister
EInputDirectionClass_swigregister(EInputDirectionClass)

def EInputDirectionClass_FromString(ValueStr: 'GENICAM_NAMESPACE::gcstring const &', pValue: 'GENAPI_NAMESPACE::EInputDirection *') -> "GENICAM_NAMESPACE::gcstring const &":
    """


    Converts a string to enum value.  

    """
    return _genicam.EInputDirectionClass_FromString(ValueStr, pValue)

def EInputDirectionClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    """


    Converts a string to an int32_t property.  

    """
    return _genicam.EInputDirectionClass_ToString(*args)

class Version(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Major = _swig_property(_genicam.Version_Major_get, _genicam.Version_Major_set)
    Minor = _swig_property(_genicam.Version_Minor_get, _genicam.Version_Minor_set)
    SubMinor = _swig_property(_genicam.Version_SubMinor_get, _genicam.Version_SubMinor_set)

    def __init__(self):
        this = _genicam.new_Version()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_Version
    __del__ = lambda self: None
Version_swigregister = _genicam.Version_swigregister
Version_swigregister(Version)

class IBase(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetAccessMode(self) -> "GENAPI_NAMESPACE::EAccessMode":
        return _genicam.IBase_GetAccessMode(self)
IBase_swigregister = _genicam.IBase_swigregister
IBase_swigregister(IBase)

class INode(IBase):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetName(self, FullQualified: 'bool'=False) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetName(self, FullQualified)
    Name = property(GetName) 

    def GetNameSpace(self) -> "GENAPI_NAMESPACE::ENameSpace":
        return _genicam.INode_GetNameSpace(self)
    NameSpace = property(GetNameSpace) 

    def GetVisibility(self) -> "GENAPI_NAMESPACE::EVisibility":
        return _genicam.INode_GetVisibility(self)
    Visibility = property(GetVisibility) 

    def InvalidateNode(self) -> "void":
        return _genicam.INode_InvalidateNode(self)

    def IsCachable(self) -> "bool":
        return _genicam.INode_IsCachable(self)

    def IsAccessModeCacheable(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.INode_IsAccessModeCacheable(self)

    def GetCachingMode(self) -> "GENAPI_NAMESPACE::ECachingMode":
        return _genicam.INode_GetCachingMode(self)
    CachingMode = property(GetCachingMode) 

    def GetPollingTime(self) -> "int64_t":
        return _genicam.INode_GetPollingTime(self)
    PollingTime = property(GetPollingTime) 

    def GetToolTip(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetToolTip(self)
    ToolTip = property(GetToolTip) 

    def GetDescription(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetDescription(self)
    Description = property(GetDescription) 

    def GetDisplayName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetDisplayName(self)
    DisplayName = property(GetDisplayName) 

    def GetDeviceName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetDeviceName(self)
    DeviceName = property(GetDeviceName) 

    def GetChildren(self, *args) -> "void":
        return _genicam.INode_GetChildren(self, *args)
    Children = property(GetChildren) 

    def GetParents(self) -> "void":
        return _genicam.INode_GetParents(self)
    Parents = property(GetParents) 

    def RegisterCallback(self, INPUT: 'CNodeCallback *') -> "GENAPI_NAMESPACE::CallbackHandleType":
        return _genicam.INode_RegisterCallback(self, INPUT)

    def DeregisterCallback(self, hCallback: 'GENAPI_NAMESPACE::CallbackHandleType') -> "bool":
        return _genicam.INode_DeregisterCallback(self, hCallback)

    def GetNodeMap(self) -> "GENAPI_NAMESPACE::INodeMap *":
        return _genicam.INode_GetNodeMap(self)
    NodeMap = property(GetNodeMap) 

    def GetEventID(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetEventID(self)
    EventID = property(GetEventID) 

    def IsStreamable(self) -> "bool":
        return _genicam.INode_IsStreamable(self)

    def GetPropertyNames(self) -> "void":
        return _genicam.INode_GetPropertyNames(self)
    PropertyNames = property(GetPropertyNames) 

    def GetProperty(self, PropertyName: 'GENICAM_NAMESPACE::gcstring const &') -> "void":
        return _genicam.INode_GetProperty(self, PropertyName)

    def ImposeAccessMode(self, ImposedAccessMode: 'GENAPI_NAMESPACE::EAccessMode') -> "void":
        return _genicam.INode_ImposeAccessMode(self, ImposedAccessMode)

    def ImposeVisibility(self, ImposedVisibility: 'GENAPI_NAMESPACE::EVisibility') -> "void":
        return _genicam.INode_ImposeVisibility(self, ImposedVisibility)

    def GetAlias(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.INode_GetAlias(self)
    Alias = property(GetAlias) 

    def GetCastAlias(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.INode_GetCastAlias(self)
    CastAlias = property(GetCastAlias) 

    def GetDocuURL(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetDocuURL(self)
    DocuURL = property(GetDocuURL) 

    def IsDeprecated(self) -> "bool":
        return _genicam.INode_IsDeprecated(self)

    def GetPrincipalInterfaceType(self) -> "GENAPI_NAMESPACE::EInterfaceType":
        return _genicam.INode_GetPrincipalInterfaceType(self)
    PrincipalInterfaceType = property(GetPrincipalInterfaceType) 

    def IsFeature(self) -> "bool":
        return _genicam.INode_IsFeature(self)

    def IsSelector(self) -> "bool":
        return _genicam.INode_IsSelector(self)

    def GetSelectedFeatures(self) -> "void":
        return _genicam.INode_GetSelectedFeatures(self)

    def GetSelectingFeatures(self) -> "void":
        return _genicam.INode_GetSelectingFeatures(self)
INode_swigregister = _genicam.INode_swigregister
INode_swigregister(INode)


def IsReadable(*args) -> "bool":
    """


    Checks if a node is readable.  

    """
    return _genicam.IsReadable(*args)

def IsWritable(*args) -> "bool":
    """


    Checks if a node is Writable.  

    """
    return _genicam.IsWritable(*args)

def IsImplemented(*args) -> "bool":
    """


    Checks if a node is Implemented.  

    """
    return _genicam.IsImplemented(*args)

def IsAvailable(*args) -> "bool":
    """


    Checks if a node is Available.  

    """
    return _genicam.IsAvailable(*args)

def Combine(Peter: 'GENAPI_NAMESPACE::EAccessMode', Paul: 'GENAPI_NAMESPACE::EAccessMode') -> "GENAPI_NAMESPACE::EAccessMode":
    """


    Computes which CachingMode results from a combination.  

    """
    return _genicam.Combine(Peter, Paul)

def IsVisible(Visibility: 'GENAPI_NAMESPACE::EVisibility', MaxVisiblity: 'GENAPI_NAMESPACE::EVisibility') -> "bool":
    """


    Tests Visibility.  

    CAVE : this relys on the EVisibility enum's coding  

    """
    return _genicam.IsVisible(Visibility, MaxVisiblity)

def CombineVisibility(Peter: 'GENAPI_NAMESPACE::EVisibility', Paul: 'GENAPI_NAMESPACE::EVisibility') -> "GENAPI_NAMESPACE::EVisibility":
    """


    Computes which CachingMode results from a combination.  

    """
    return _genicam.CombineVisibility(Peter, Paul)

def IsCacheable(CachingMode: 'GENAPI_NAMESPACE::ECachingMode') -> "bool":
    """


    Tests Cacheability.  

    """
    return _genicam.IsCacheable(CachingMode)

def CombineCachingMode(Peter: 'GENAPI_NAMESPACE::ECachingMode', Paul: 'GENAPI_NAMESPACE::ECachingMode') -> "GENAPI_NAMESPACE::ECachingMode":
    """


    Computes which CachingMode results from a combination.  

    """
    return _genicam.CombineCachingMode(Peter, Paul)
class INodeMap(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetNodes(self) -> "void":
        return _genicam.INodeMap_GetNodes(self)

    def GetNode(self, Name: 'GENICAM_NAMESPACE::gcstring const &') -> "GENAPI_NAMESPACE::INode *":
        return _genicam.INodeMap_GetNode(self, Name)

    def InvalidateNodes(self) -> "void":
        return _genicam.INodeMap_InvalidateNodes(self)

    def Connect(self, *args) -> "bool":
        return _genicam.INodeMap_Connect(self, *args)

    def GetDeviceName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INodeMap_GetDeviceName(self)

    def Poll(self, ElapsedTime: 'int64_t') -> "void":
        return _genicam.INodeMap_Poll(self, ElapsedTime)

    def GetLock(self) -> "CLock &":
        return _genicam.INodeMap_GetLock(self)

    def GetNumNodes(self) -> "uint64_t":
        return _genicam.INodeMap_GetNumNodes(self)

    def ParseSwissKnifes(self, pErrorList: 'GENICAM_NAMESPACE::gcstring_vector *'=None) -> "bool":
        return _genicam.INodeMap_ParseSwissKnifes(self, pErrorList)
    DeviceName = property(GetDeviceName) 

    def GetDeviceInfo(self) -> "GENAPI_NAMESPACE::IDeviceInfo *":
        return _genicam.INodeMap_GetDeviceInfo(self)
    DeviceInfo = property(GetDeviceInfo) 

    def __getattr__(self, attribute):
        if attribute in self.__dict__ or attribute in ( "thisown","this") or attribute.startswith("__"):
            return object.__getattr__(self, attribute)
        else:
            return self.GetNode(attribute)

    def __setattr__(self, attribute, val):
        if attribute in self.__dict__ or attribute in ( "thisown","this") or attribute.startswith("__"):
            object.__setattr__(self, attribute, val)
        else:
            self.GetNode(attribute).SetValue(val)

    def __dir__(self):
        l = dir(type(self))
        l.extend(self.__dict__.keys())
        nodes = []
        try:
            nodes = self.GetNodeMap().GetNodes()
            features = filter(lambda n: n.GetNode().IsFeature(), nodes)
            l.extend(x.GetNode().GetName() for x in features)
        except:
            pass
        try:
            chunks = filter(lambda n: "ChunkData" in (f.Name for f in n.GetParents()), nodes)
            l.extend(x.GetNode().GetName() for x in chunks)
        except:
            pass
        return sorted(set(l))

INodeMap_swigregister = _genicam.INodeMap_swigregister
INodeMap_swigregister(INodeMap)

cbPostInsideLock = _genicam.cbPostInsideLock
cbPostOutsideLock = _genicam.cbPostOutsideLock
class PyNodeCallback(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pNode: 'INode', PyFunc: 'PyObject *', CallbackType: 'GENAPI_NAMESPACE::ECallbackType'):
        this = _genicam.new_PyNodeCallback(pNode, PyFunc, CallbackType)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_PyNodeCallback
    __del__ = lambda self: None

    def GetNode(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.PyNodeCallback_GetNode(self)
PyNodeCallback_swigregister = _genicam.PyNodeCallback_swigregister
PyNodeCallback_swigregister(PyNodeCallback)


def Register(node, callback_fun, callback_type=cbPostInsideLock):
    assert callback_type in ( cbPostOutsideLock, cbPostInsideLock)
    cb = PyNodeCallback(node, callback_fun, callback_type)
    cb.thisown = 0
    return node.RegisterCallback(cb)



def Deregister(pCallbackInfo: 'GENAPI_NAMESPACE::CallbackHandleType') -> "void":
    """


    Unregistering callback by handle.  

    """
    return _genicam.Deregister(pCallbackInfo)
class IValue(IBase):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetNode(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.IValue_GetNode(self)

    def ToString(self, Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IValue_ToString(self, Verify, IgnoreCache)

    def FromString(self, ValueStr: 'GENICAM_NAMESPACE::gcstring const &', Verify: 'bool'=True) -> "void":
        return _genicam.IValue_FromString(self, ValueStr, Verify)

    def IsValueCacheValid(self) -> "bool":
        return _genicam.IValue_IsValueCacheValid(self)
    Node = property(GetNode) 
IValue_swigregister = _genicam.IValue_swigregister
IValue_swigregister(IValue)

class node_vector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _genicam.node_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _genicam.node_vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _genicam.node_vector___bool__(self)

    def __len__(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::size_type":
        return _genicam.node_vector___len__(self)

    def __getslice__(self, i: 'std::vector< GENAPI_NAMESPACE::INode * >::difference_type', j: 'std::vector< GENAPI_NAMESPACE::INode * >::difference_type') -> "std::vector< GENAPI_NAMESPACE::INode *,std::allocator< GENAPI_NAMESPACE::INode * > > *":
        return _genicam.node_vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _genicam.node_vector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< GENAPI_NAMESPACE::INode * >::difference_type', j: 'std::vector< GENAPI_NAMESPACE::INode * >::difference_type') -> "void":
        return _genicam.node_vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _genicam.node_vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< GENAPI_NAMESPACE::INode * >::value_type":
        return _genicam.node_vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _genicam.node_vector___setitem__(self, *args)

    def pop(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::value_type":
        return _genicam.node_vector_pop(self)

    def append(self, x: 'INode') -> "void":
        return _genicam.node_vector_append(self, x)

    def empty(self) -> "bool":
        return _genicam.node_vector_empty(self)

    def size(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::size_type":
        return _genicam.node_vector_size(self)

    def swap(self, v: 'node_vector') -> "void":
        return _genicam.node_vector_swap(self, v)

    def begin(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::iterator":
        return _genicam.node_vector_begin(self)

    def end(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::iterator":
        return _genicam.node_vector_end(self)

    def rbegin(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::reverse_iterator":
        return _genicam.node_vector_rbegin(self)

    def rend(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::reverse_iterator":
        return _genicam.node_vector_rend(self)

    def clear(self) -> "void":
        return _genicam.node_vector_clear(self)

    def get_allocator(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::allocator_type":
        return _genicam.node_vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _genicam.node_vector_pop_back(self)

    def erase(self, *args) -> "std::vector< GENAPI_NAMESPACE::INode * >::iterator":
        return _genicam.node_vector_erase(self, *args)

    def __init__(self, *args):
        this = _genicam.new_node_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'INode') -> "void":
        return _genicam.node_vector_push_back(self, x)

    def front(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::value_type":
        return _genicam.node_vector_front(self)

    def back(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::value_type":
        return _genicam.node_vector_back(self)

    def assign(self, n: 'std::vector< GENAPI_NAMESPACE::INode * >::size_type', x: 'INode') -> "void":
        return _genicam.node_vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _genicam.node_vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _genicam.node_vector_insert(self, *args)

    def reserve(self, n: 'std::vector< GENAPI_NAMESPACE::INode * >::size_type') -> "void":
        return _genicam.node_vector_reserve(self, n)

    def capacity(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::size_type":
        return _genicam.node_vector_capacity(self)
    __swig_destroy__ = _genicam.delete_node_vector
    __del__ = lambda self: None
node_vector_swigregister = _genicam.node_vector_swigregister
node_vector_swigregister(node_vector)

class value_vector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _genicam.value_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _genicam.value_vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _genicam.value_vector___bool__(self)

    def __len__(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::size_type":
        return _genicam.value_vector___len__(self)

    def __getslice__(self, i: 'std::vector< GENAPI_NAMESPACE::IValue * >::difference_type', j: 'std::vector< GENAPI_NAMESPACE::IValue * >::difference_type') -> "std::vector< GENAPI_NAMESPACE::IValue *,std::allocator< GENAPI_NAMESPACE::IValue * > > *":
        return _genicam.value_vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _genicam.value_vector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< GENAPI_NAMESPACE::IValue * >::difference_type', j: 'std::vector< GENAPI_NAMESPACE::IValue * >::difference_type') -> "void":
        return _genicam.value_vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _genicam.value_vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< GENAPI_NAMESPACE::IValue * >::value_type":
        return _genicam.value_vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _genicam.value_vector___setitem__(self, *args)

    def pop(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::value_type":
        return _genicam.value_vector_pop(self)

    def append(self, x: 'IValue') -> "void":
        return _genicam.value_vector_append(self, x)

    def empty(self) -> "bool":
        return _genicam.value_vector_empty(self)

    def size(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::size_type":
        return _genicam.value_vector_size(self)

    def swap(self, v: 'value_vector') -> "void":
        return _genicam.value_vector_swap(self, v)

    def begin(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::iterator":
        return _genicam.value_vector_begin(self)

    def end(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::iterator":
        return _genicam.value_vector_end(self)

    def rbegin(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::reverse_iterator":
        return _genicam.value_vector_rbegin(self)

    def rend(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::reverse_iterator":
        return _genicam.value_vector_rend(self)

    def clear(self) -> "void":
        return _genicam.value_vector_clear(self)

    def get_allocator(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::allocator_type":
        return _genicam.value_vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _genicam.value_vector_pop_back(self)

    def erase(self, *args) -> "std::vector< GENAPI_NAMESPACE::IValue * >::iterator":
        return _genicam.value_vector_erase(self, *args)

    def __init__(self, *args):
        this = _genicam.new_value_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'IValue') -> "void":
        return _genicam.value_vector_push_back(self, x)

    def front(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::value_type":
        return _genicam.value_vector_front(self)

    def back(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::value_type":
        return _genicam.value_vector_back(self)

    def assign(self, n: 'std::vector< GENAPI_NAMESPACE::IValue * >::size_type', x: 'IValue') -> "void":
        return _genicam.value_vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _genicam.value_vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _genicam.value_vector_insert(self, *args)

    def reserve(self, n: 'std::vector< GENAPI_NAMESPACE::IValue * >::size_type') -> "void":
        return _genicam.value_vector_reserve(self, n)

    def capacity(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::size_type":
        return _genicam.value_vector_capacity(self)
    __swig_destroy__ = _genicam.delete_value_vector
    __del__ = lambda self: None
value_vector_swigregister = _genicam.value_vector_swigregister
value_vector_swigregister(value_vector)

class string_vector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _genicam.string_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _genicam.string_vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _genicam.string_vector___bool__(self)

    def __len__(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::size_type":
        return _genicam.string_vector___len__(self)

    def __getslice__(self, i: 'std::vector< GENICAM_NAMESPACE::gcstring >::difference_type', j: 'std::vector< GENICAM_NAMESPACE::gcstring >::difference_type') -> "std::vector< GENICAM_NAMESPACE::gcstring,std::allocator< GENICAM_NAMESPACE::gcstring > > *":
        return _genicam.string_vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _genicam.string_vector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< GENICAM_NAMESPACE::gcstring >::difference_type', j: 'std::vector< GENICAM_NAMESPACE::gcstring >::difference_type') -> "void":
        return _genicam.string_vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _genicam.string_vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &":
        return _genicam.string_vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _genicam.string_vector___setitem__(self, *args)

    def pop(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::value_type":
        return _genicam.string_vector_pop(self)

    def append(self, x: 'std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &') -> "void":
        return _genicam.string_vector_append(self, x)

    def empty(self) -> "bool":
        return _genicam.string_vector_empty(self)

    def size(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::size_type":
        return _genicam.string_vector_size(self)

    def swap(self, v: 'string_vector') -> "void":
        return _genicam.string_vector_swap(self, v)

    def begin(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::iterator":
        return _genicam.string_vector_begin(self)

    def end(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::iterator":
        return _genicam.string_vector_end(self)

    def rbegin(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::reverse_iterator":
        return _genicam.string_vector_rbegin(self)

    def rend(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::reverse_iterator":
        return _genicam.string_vector_rend(self)

    def clear(self) -> "void":
        return _genicam.string_vector_clear(self)

    def get_allocator(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::allocator_type":
        return _genicam.string_vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _genicam.string_vector_pop_back(self)

    def erase(self, *args) -> "std::vector< GENICAM_NAMESPACE::gcstring >::iterator":
        return _genicam.string_vector_erase(self, *args)

    def __init__(self, *args):
        this = _genicam.new_string_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &') -> "void":
        return _genicam.string_vector_push_back(self, x)

    def front(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &":
        return _genicam.string_vector_front(self)

    def back(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &":
        return _genicam.string_vector_back(self)

    def assign(self, n: 'std::vector< GENICAM_NAMESPACE::gcstring >::size_type', x: 'std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &') -> "void":
        return _genicam.string_vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _genicam.string_vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _genicam.string_vector_insert(self, *args)

    def reserve(self, n: 'std::vector< GENICAM_NAMESPACE::gcstring >::size_type') -> "void":
        return _genicam.string_vector_reserve(self, n)

    def capacity(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::size_type":
        return _genicam.string_vector_capacity(self)
    __swig_destroy__ = _genicam.delete_string_vector
    __del__ = lambda self: None
string_vector_swigregister = _genicam.string_vector_swigregister
string_vector_swigregister(string_vector)

class IPort(IBase):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Read(self, Address: 'int64_t', pBuffer: 'void *') -> "void":
        return _genicam.IPort_Read(self, Address, pBuffer)

    def Write(self, Address: 'int64_t', pBuffer: 'void const *') -> "void":
        return _genicam.IPort_Write(self, Address, pBuffer)

    def GetNode(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.IPort_GetNode(self)

    def GetChunkID(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IPort_GetChunkID(self)

    def CacheChunkData(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.IPort_CacheChunkData(self)

    def GetSwapEndianess(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.IPort_GetSwapEndianess(self)
    Node = property(GetNode) 
    ChunkID = property(GetChunkID) 
IPort_swigregister = _genicam.IPort_swigregister
IPort_swigregister(IPort)

CHUNK_BASE_ADDRESS_REGISTER_LEN = _genicam.CHUNK_BASE_ADDRESS_REGISTER_LEN
CHUNK_LENGTH_REGISTER_LEN = _genicam.CHUNK_LENGTH_REGISTER_LEN
class IChunkPort(IPort):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetChunkID(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IChunkPort_GetChunkID(self)

    def CacheChunkData(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.IChunkPort_CacheChunkData(self)
IChunkPort_swigregister = _genicam.IChunkPort_swigregister
IChunkPort_swigregister(IChunkPort)

class IPortConstruct(IPort):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetSwapEndianess(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.IPortConstruct_GetSwapEndianess(self)
IPortConstruct_swigregister = _genicam.IPortConstruct_swigregister
IPortConstruct_swigregister(IPortConstruct)

class IPortWriteList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Write(self, pBuffer: 'void const *', Address: 'int64_t', Length: 'int64_t') -> "void":
        return _genicam.IPortWriteList_Write(self, pBuffer, Address, Length)

    def Replay(self, pPort: 'IPort') -> "void":
        return _genicam.IPortWriteList_Replay(self, pPort)

    def SetCookie(self, Value: 'int64_t const') -> "void":
        return _genicam.IPortWriteList_SetCookie(self, Value)

    def GetCookie(self) -> "int64_t":
        return _genicam.IPortWriteList_GetCookie(self)
IPortWriteList_swigregister = _genicam.IPortWriteList_swigregister
IPortWriteList_swigregister(IPortWriteList)

class IPortReplay(IPort):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Replay(self, pPortRecorder: 'IPortWriteList', Invalidate: 'bool'=True) -> "void":
        return _genicam.IPortReplay_Replay(self, pPortRecorder, Invalidate)
IPortReplay_swigregister = _genicam.IPortReplay_swigregister
IPortReplay_swigregister(IPortReplay)

class IPortRecorder(IPortReplay):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def StartRecording(self, pPortRecorder: 'IPortWriteList') -> "void":
        return _genicam.IPortRecorder_StartRecording(self, pPortRecorder)

    def StopRecording(self) -> "void":
        return _genicam.IPortRecorder_StopRecording(self)
IPortRecorder_swigregister = _genicam.IPortRecorder_swigregister
IPortRecorder_swigregister(IPortRecorder)

class CPortImpl(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CPortImpl:
            _self = None
        else:
            _self = self
        this = _genicam.new_CPortImpl(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_CPortImpl
    __del__ = lambda self: None

    def GetAccessMode(self) -> "GENAPI_NAMESPACE::EAccessMode":
        """


        Get the access mode of the node.  

        Driver closed => NI, Driver open => RW, analysing a struct, RO  

        """
        return _genicam.CPortImpl_GetAccessMode(self)


    def Read(self, Address: 'int64_t', pBuffer: 'void *') -> "void":
        return _genicam.CPortImpl_Read(self, Address, pBuffer)

    def Write(self, Address: 'int64_t', pBuffer: 'void const *') -> "void":
        return _genicam.CPortImpl_Write(self, Address, pBuffer)

    def InvalidateNode(self) -> "void":
        """


        """
        return _genicam.CPortImpl_InvalidateNode(self)

    def __disown__(self):
        self.this.disown()
        _genicam.disown_CPortImpl(self)
        return weakref_proxy(self)
CPortImpl_swigregister = _genicam.CPortImpl_swigregister
CPortImpl_swigregister(CPortImpl)

class IDeviceInfo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetModelName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetModelName(self)

    def GetVendorName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetVendorName(self)

    def GetToolTip(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetToolTip(self)

    def GetStandardNameSpace(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetStandardNameSpace(self)

    def GetGenApiVersion(self) -> "void":
        return _genicam.IDeviceInfo_GetGenApiVersion(self)

    def GetSchemaVersion(self) -> "void":
        return _genicam.IDeviceInfo_GetSchemaVersion(self)

    def GetDeviceVersion(self) -> "void":
        return _genicam.IDeviceInfo_GetDeviceVersion(self)

    def GetProductGuid(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetProductGuid(self)

    def GetVersionGuid(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetVersionGuid(self)
IDeviceInfo_swigregister = _genicam.IDeviceInfo_swigregister
IDeviceInfo_swigregister(IDeviceInfo)

class CNodeMapRef(object):
    """


    Smartpointer for NodeMaps with create function.  

    note: This class is a simple typedef definition. The class syntax is only used,
        because Doxygen has to generate a useful documentation.  

    C++ includes: NodeMapRef.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        Copy constructor.  

        """
        this = _genicam.new_CNodeMapRef(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_CNodeMapRef
    __del__ = lambda self: None

    def _LoadXMLFromFile(self, FileName: 'GENICAM_NAMESPACE::gcstring') -> "void":
        return _genicam.CNodeMapRef__LoadXMLFromFile(self, FileName)

    def _LoadXMLFromString(self, XMLData: 'GENICAM_NAMESPACE::gcstring const &') -> "void":
        return _genicam.CNodeMapRef__LoadXMLFromString(self, XMLData)

    def _GetDeviceName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.CNodeMapRef__GetDeviceName(self)

    def _Poll(self, ElapsedTime: 'int64_t') -> "void":
        return _genicam.CNodeMapRef__Poll(self, ElapsedTime)

    def _Destroy(self) -> "void":
        return _genicam.CNodeMapRef__Destroy(self)
    _ClearXMLCache = staticmethod(_genicam.CNodeMapRef__ClearXMLCache)

    def _GetNodes(self) -> "void":
        return _genicam.CNodeMapRef__GetNodes(self)

    def _GetNode(self, key: 'GENICAM_NAMESPACE::gcstring const &') -> "GENAPI_NAMESPACE::INode *":
        return _genicam.CNodeMapRef__GetNode(self, key)

    def GetNode(self, key: 'GENICAM_NAMESPACE::gcstring const &') -> "GENAPI_NAMESPACE::INode *":
        return _genicam.CNodeMapRef_GetNode(self, key)

    def _InvalidateNodes(self) -> "void":
        return _genicam.CNodeMapRef__InvalidateNodes(self)

    def _Connect(self, *args) -> "bool":
        return _genicam.CNodeMapRef__Connect(self, *args)
    _Ptr = _swig_property(_genicam.CNodeMapRef__Ptr_get, _genicam.CNodeMapRef__Ptr_set)

    def GetDeviceInfo(self) -> "GENAPI_NAMESPACE::IDeviceInfo *":
        return _genicam.CNodeMapRef_GetDeviceInfo(self)
    DeviceInfo = property(GetDeviceInfo) 

    def __getattr__(self, attribute):
        if attribute in self.__dict__ or attribute in ( "thisown","this") or attribute.startswith("__"):
            return object.__getattr__(self, attribute)
        else:
            return self.GetNode(attribute)

    def __setattr__(self, attribute, val):
        if attribute in self.__dict__ or attribute in ( "thisown","this") or attribute.startswith("__"):
            object.__setattr__(self, attribute, val)
        else:
            self.GetNode(attribute).SetValue(val)

    def __dir__(self):
        l = []
        l += [x for x in dir(type(self))]
        l += [x for x in self.__dict__.keys()]
        try:
            l += [x.GetNode().GetName() for x in filter(lambda n: n.GetNode().IsFeature(), self.GetNodeMap().GetNodes())]
        except:
            pass
        return sorted(set(l))

CNodeMapRef_swigregister = _genicam.CNodeMapRef_swigregister
CNodeMapRef_swigregister(CNodeMapRef)

def CNodeMapRef__ClearXMLCache() -> "bool":
    return _genicam.CNodeMapRef__ClearXMLCache()
CNodeMapRef__ClearXMLCache = _genicam.CNodeMapRef__ClearXMLCache

class IFloat(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetValue(self, Value: 'double', Verify: 'bool'=True) -> "void":
        return _genicam.IFloat_SetValue(self, Value, Verify)

    def GetValue(self, Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "double":
        return _genicam.IFloat_GetValue(self, Verify, IgnoreCache)

    def __call__(self) -> "double":
        return _genicam.IFloat___call__(self)

    def GetMin(self) -> "double":
        return _genicam.IFloat_GetMin(self)

    def GetMax(self) -> "double":
        return _genicam.IFloat_GetMax(self)

    def HasInc(self) -> "bool":
        return _genicam.IFloat_HasInc(self)

    def GetIncMode(self) -> "GENAPI_NAMESPACE::EIncMode":
        return _genicam.IFloat_GetIncMode(self)

    def GetInc(self) -> "double":
        return _genicam.IFloat_GetInc(self)

    def GetListOfValidValues(self, bounded: 'bool'=True) -> "double_autovector_t":
        return _genicam.IFloat_GetListOfValidValues(self, bounded)

    def GetRepresentation(self) -> "GENAPI_NAMESPACE::ERepresentation":
        return _genicam.IFloat_GetRepresentation(self)

    def GetUnit(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IFloat_GetUnit(self)

    def GetDisplayNotation(self) -> "GENAPI_NAMESPACE::EDisplayNotation":
        return _genicam.IFloat_GetDisplayNotation(self)

    def GetDisplayPrecision(self) -> "int64_t":
        return _genicam.IFloat_GetDisplayPrecision(self)

    def ImposeMin(self, Value: 'double') -> "void":
        return _genicam.IFloat_ImposeMin(self, Value)

    def ImposeMax(self, Value: 'double') -> "void":
        return _genicam.IFloat_ImposeMax(self, Value)

    def GetIntAlias(self) -> "GENAPI_NAMESPACE::IInteger *":
        return _genicam.IFloat_GetIntAlias(self)

    def GetEnumAlias(self) -> "GENAPI_NAMESPACE::IEnumeration *":
        return _genicam.IFloat_GetEnumAlias(self)
    Value = property(GetValue,SetValue) 
    Min = property(GetMin) 
    Max = property(GetMax) 
    IncMode = property(GetIncMode) 
    Inc = property(GetInc) 
    ListOfValidValues = property(GetListOfValidValues) 
    Representation = property(GetRepresentation) 
    Unit = property(GetUnit) 
    DisplayNotation = property(GetDisplayNotation) 
    DisplayPrecision = property(GetDisplayPrecision) 
    IntAlias = property(GetIntAlias) 
    EnumAlias = property(GetEnumAlias) 
IFloat_swigregister = _genicam.IFloat_swigregister
IFloat_swigregister(IFloat)

class IInteger(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetValue(self, Value: 'int64_t', Verify: 'bool'=True) -> "void":
        return _genicam.IInteger_SetValue(self, Value, Verify)

    def GetValue(self, Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "int64_t":
        return _genicam.IInteger_GetValue(self, Verify, IgnoreCache)

    def __call__(self) -> "int64_t":
        return _genicam.IInteger___call__(self)

    def GetMin(self) -> "int64_t":
        return _genicam.IInteger_GetMin(self)

    def GetMax(self) -> "int64_t":
        return _genicam.IInteger_GetMax(self)

    def GetIncMode(self) -> "GENAPI_NAMESPACE::EIncMode":
        return _genicam.IInteger_GetIncMode(self)

    def GetInc(self) -> "int64_t":
        return _genicam.IInteger_GetInc(self)

    def GetListOfValidValues(self, bounded: 'bool'=True) -> "int64_autovector_t":
        return _genicam.IInteger_GetListOfValidValues(self, bounded)

    def GetRepresentation(self) -> "GENAPI_NAMESPACE::ERepresentation":
        return _genicam.IInteger_GetRepresentation(self)

    def GetUnit(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IInteger_GetUnit(self)

    def ImposeMin(self, Value: 'int64_t') -> "void":
        return _genicam.IInteger_ImposeMin(self, Value)

    def ImposeMax(self, Value: 'int64_t') -> "void":
        return _genicam.IInteger_ImposeMax(self, Value)

    def GetFloatAlias(self) -> "GENAPI_NAMESPACE::IFloat *":
        return _genicam.IInteger_GetFloatAlias(self)

    def Set(self, pBuffer: 'uint8_t const *', Verify: 'bool'=True) -> "void":
        return _genicam.IInteger_Set(self, pBuffer, Verify)

    def Get(self, pBuffer: 'uint8_t *', Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "void":
        return _genicam.IInteger_Get(self, pBuffer, Verify, IgnoreCache)

    def GetLength(self) -> "int64_t":
        return _genicam.IInteger_GetLength(self)

    def GetAddress(self) -> "int64_t":
        return _genicam.IInteger_GetAddress(self)
    Value = property(GetValue,SetValue) 
    Min = property(GetMin) 
    Max = property(GetMax) 
    IncMode = property(GetIncMode) 
    Inc = property(GetInc) 
    ListOfValidValues = property(GetListOfValidValues) 
    Representation = property(GetRepresentation) 
    Unit = property(GetUnit) 
    FloatAlias = property(GetFloatAlias) 
    Address = property(GetAddress) 
    Length = property(GetLength) 
IInteger_swigregister = _genicam.IInteger_swigregister
IInteger_swigregister(IInteger)

class IRegister(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Set(self, pBuffer: 'uint8_t const *', Verify: 'bool'=True) -> "void":
        return _genicam.IRegister_Set(self, pBuffer, Verify)

    def Get(self, pBuffer: 'uint8_t *', Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "void":
        return _genicam.IRegister_Get(self, pBuffer, Verify, IgnoreCache)

    def GetLength(self) -> "int64_t":
        return _genicam.IRegister_GetLength(self)

    def GetAddress(self) -> "int64_t":
        return _genicam.IRegister_GetAddress(self)
    Length = property(GetLength) 
    Address = property(GetAddress) 
IRegister_swigregister = _genicam.IRegister_swigregister
IRegister_swigregister(IRegister)


def GetAll(self):
    return self.Get(self.GetLength())
IRegister.GetAll = GetAll

class IEnumEntry(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetValue(self) -> "int64_t":
        return _genicam.IEnumEntry_GetValue(self)

    def GetSymbolic(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IEnumEntry_GetSymbolic(self)

    def GetNumericValue(self) -> "double":
        return _genicam.IEnumEntry_GetNumericValue(self)

    def IsSelfClearing(self) -> "bool":
        return _genicam.IEnumEntry_IsSelfClearing(self)
    Value = property(GetValue) 
    Symbolic = property(GetSymbolic) 
    NumericValue = property(GetNumericValue) 

    def __call__( self ):
        return self.GetValue()

IEnumEntry_swigregister = _genicam.IEnumEntry_swigregister
IEnumEntry_swigregister(IEnumEntry)

class IEnumeration(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetSymbolics(self) -> "void":
        return _genicam.IEnumeration_GetSymbolics(self)

    def GetEntries(self) -> "void":
        return _genicam.IEnumeration_GetEntries(self)

    def SetIntValue(self, Value: 'int64_t', Verify: 'bool'=True) -> "void":
        return _genicam.IEnumeration_SetIntValue(self, Value, Verify)

    def GetIntValue(self, Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "int64_t":
        return _genicam.IEnumeration_GetIntValue(self, Verify, IgnoreCache)

    def GetEntryByName(self, Symbolic: 'GENICAM_NAMESPACE::gcstring const &') -> "GENAPI_NAMESPACE::IEnumEntry *":
        return _genicam.IEnumeration_GetEntryByName(self, Symbolic)

    def GetEntry(self, IntValue: 'int64_t const') -> "GENAPI_NAMESPACE::IEnumEntry *":
        return _genicam.IEnumeration_GetEntry(self, IntValue)

    def GetCurrentEntry(self, Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "GENAPI_NAMESPACE::IEnumEntry *":
        return _genicam.IEnumeration_GetCurrentEntry(self, Verify, IgnoreCache)

    def __call__(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IEnumeration___call__(self)

    def GetValue(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IEnumeration_GetValue(self)

    def SetValue(self, entry: 'GENICAM_NAMESPACE::gcstring') -> "void":
        return _genicam.IEnumeration_SetValue(self, entry)
    Symbolics = property(GetSymbolics) 
    Entries = property(GetEntries) 
    IntValue = property(GetIntValue,SetIntValue) 
    Value = property(GetValue,SetValue) 
IEnumeration_swigregister = _genicam.IEnumeration_swigregister
IEnumeration_swigregister(IEnumeration)

class IBoolean(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetValue(self, Value: 'bool', Verify: 'bool'=True) -> "void":
        return _genicam.IBoolean_SetValue(self, Value, Verify)

    def GetValue(self, Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "bool":
        return _genicam.IBoolean_GetValue(self, Verify, IgnoreCache)

    def __call__(self) -> "bool":
        return _genicam.IBoolean___call__(self)
    Value = property(GetValue,SetValue) 
IBoolean_swigregister = _genicam.IBoolean_swigregister
IBoolean_swigregister(IBoolean)

class ICommand(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Execute(self, Verify: 'bool'=True) -> "void":
        return _genicam.ICommand_Execute(self, Verify)

    def __call__(self) -> "void":
        return _genicam.ICommand___call__(self)

    def IsDone(self, Verify: 'bool'=True) -> "bool":
        return _genicam.ICommand_IsDone(self, Verify)
ICommand_swigregister = _genicam.ICommand_swigregister
ICommand_swigregister(ICommand)

class IString(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetValue(self, Value: 'GENICAM_NAMESPACE::gcstring const &', Verify: 'bool'=True) -> "void":
        return _genicam.IString_SetValue(self, Value, Verify)

    def GetValue(self, Verify: 'bool'=False, IgnoreCache: 'bool'=False) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IString_GetValue(self, Verify, IgnoreCache)

    def __call__(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IString___call__(self)

    def GetMaxLength(self) -> "int64_t":
        return _genicam.IString_GetMaxLength(self)

    def GetLength(self) -> "int64_t":
        return _genicam.IString_GetLength(self)
    Value = property(GetValue,SetValue) 
    MaxLength = property(GetMaxLength) 
    Length = property(GetLength) 
IString_swigregister = _genicam.IString_swigregister
IString_swigregister(IString)

class ICategory(IValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetFeatures(self) -> "void":
        return _genicam.ICategory_GetFeatures(self)
    Features = property(GetFeatures) 
ICategory_swigregister = _genicam.ICategory_swigregister
ICategory_swigregister(ICategory)

class IReference(object):
    """


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetReference(self, pBase: 'IBase') -> "void":
        return _genicam.IReference_SetReference(self, pBase)
IReference_swigregister = _genicam.IReference_swigregister
IReference_swigregister(IReference)

class IEnumReference(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetEnumReference(self, Index: 'int', Name: 'GENICAM_NAMESPACE::gcstring') -> "void":
        return _genicam.IEnumReference_SetEnumReference(self, Index, Name)

    def SetNumEnums(self, NumEnums: 'int') -> "void":
        return _genicam.IEnumReference_SetNumEnums(self, NumEnums)
IEnumReference_swigregister = _genicam.IEnumReference_swigregister
IEnumReference_swigregister(IEnumReference)

class ISelector(IBase):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
ISelector_swigregister = _genicam.ISelector_swigregister
ISelector_swigregister(ISelector)

class ISelectorDigit(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetFirst(self) -> "bool":
        return _genicam.ISelectorDigit_SetFirst(self)

    def SetNext(self, Tick: 'bool'=True) -> "bool":
        return _genicam.ISelectorDigit_SetNext(self, Tick)

    def Restore(self) -> "void":
        return _genicam.ISelectorDigit_Restore(self)

    def ToString(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.ISelectorDigit_ToString(self)

    def GetSelectorList(self, Incremental: 'bool'=False) -> "void":
        return _genicam.ISelectorDigit_GetSelectorList(self, Incremental)
ISelectorDigit_swigregister = _genicam.ISelectorDigit_swigregister
ISelectorDigit_swigregister(ISelectorDigit)

class CSelectorSet(ISelectorDigit):
    """


    The set of selectors selecting a given node.  

    C++ includes: SelectorSet.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pBase: 'IBase'):
        """


        Constructor.  

        """
        this = _genicam.new_CSelectorSet(pBase)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_CSelectorSet
    __del__ = lambda self: None

    def IsEmpty(self) -> "bool":
        """


        returns true if no selectors are present  

        """
        return _genicam.CSelectorSet_IsEmpty(self)


    def SetFirst(self) -> "bool":
        """


        """
        return _genicam.CSelectorSet_SetFirst(self)


    def SetNext(self, Tick: 'bool'=True) -> "bool":
        """


        """
        return _genicam.CSelectorSet_SetNext(self, Tick)


    def Restore(self) -> "void":
        """


        """
        return _genicam.CSelectorSet_Restore(self)


    def ToString(self) -> "GENICAM_NAMESPACE::gcstring":
        """


        """
        return _genicam.CSelectorSet_ToString(self)


    def GetSelectorList(self, Incremental: 'bool'=False) -> "void":
        """


        """
        return _genicam.CSelectorSet_GetSelectorList(self, Incremental)

CSelectorSet_swigregister = _genicam.CSelectorSet_swigregister
CSelectorSet_swigregister(CSelectorSet)

class ChunkPort(IPortConstruct):
    """


    Port attachable to a chunk in a buffer.  

    C++ includes: ChunkPort.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pPort: 'IPort'=None):
        """


        Constructor; can attach to a port.  

        """
        this = _genicam.new_ChunkPort(pPort)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ChunkPort
    __del__ = lambda self: None

    def GetAccessMode(self) -> "GENAPI_NAMESPACE::EAccessMode":
        """


        Get the access mode of the node.  

        """
        return _genicam.ChunkPort_GetAccessMode(self)


    def GetPrincipalInterfaceType(self) -> "GENAPI_NAMESPACE::EInterfaceType":
        """


        Get the type of the main interface of a node.  

        """
        return _genicam.ChunkPort_GetPrincipalInterfaceType(self)


    def Read(self, pBuffer: 'void *', Address: 'int64_t', Length: 'int64_t') -> "void":
        """


        Reads a chunk of bytes from the port.  

        """
        return _genicam.ChunkPort_Read(self, pBuffer, Address, Length)


    def Write(self, pBuffer: 'void const *', Address: 'int64_t', Length: 'int64_t') -> "void":
        """


        Writes a chunk of bytes to the port.  

        """
        return _genicam.ChunkPort_Write(self, pBuffer, Address, Length)


    def SetPortImpl(self, pPort: 'IPort') -> "void":
        """


        Called from the port node to give the chunk port a pointer to itself.  

        """
        return _genicam.ChunkPort_SetPortImpl(self, pPort)


    def GetSwapEndianess(self) -> "GENAPI_NAMESPACE::EYesNo":
        """


        Determines if the port adapter must perform an endianess swap.  

        """
        return _genicam.ChunkPort_GetSwapEndianess(self)


    def InvalidateNode(self) -> "void":
        """


        """
        return _genicam.ChunkPort_InvalidateNode(self)


    def AttachPort(self, pPort: 'IPort') -> "bool":
        """


        Attaches the ChunkPort to the Port.  

        """
        return _genicam.ChunkPort_AttachPort(self, pPort)


    def DetachPort(self) -> "void":
        """


        Detaches the ChunkPort to the Port.  

        """
        return _genicam.ChunkPort_DetachPort(self)


    def AttachChunk(self, pBaseAddress: 'uint8_t *', ChunkOffset: 'int64_t', Length: 'int64_t', Cache: 'bool') -> "void":
        """


        Attaches the Chunk to the ChunkPort.  

        """
        return _genicam.ChunkPort_AttachChunk(self, pBaseAddress, ChunkOffset, Length, Cache)


    def DetachChunk(self) -> "void":
        """


        Detaches the Chunk from the ChunkPort.  

        """
        return _genicam.ChunkPort_DetachChunk(self)


    def GetChunkIDLength(self) -> "int":
        """


        Gets the ChunkID length.  

        """
        return _genicam.ChunkPort_GetChunkIDLength(self)


    def CheckChunkID(self, *args) -> "bool":
        """


        Checks if a ChunkID matches, version using uint64_t ID representation.  

        """
        return _genicam.ChunkPort_CheckChunkID(self, *args)


    def UpdateBuffer(self, pBaseAddress: 'uint8_t *') -> "void":
        """


        Updates the base address of the chunk.  

        """
        return _genicam.ChunkPort_UpdateBuffer(self, pBaseAddress)


    def ClearCache(self) -> "void":
        """


        Clears the chunk cache.  

        """
        return _genicam.ChunkPort_ClearCache(self)

    AccessMode = property(GetAccessMode) 
    PrincipalInterfaceType = property(GetPrincipalInterfaceType) 
ChunkPort_swigregister = _genicam.ChunkPort_swigregister
ChunkPort_swigregister(ChunkPort)


CChunkPort = ChunkPort

class AttachStatistics_t(object):
    """


    Delivers information about the attached chunks and nodes  

    C++ includes: ChunkAdapter.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    NumChunkPorts = _swig_property(_genicam.AttachStatistics_t_NumChunkPorts_get, _genicam.AttachStatistics_t_NumChunkPorts_set)
    NumChunks = _swig_property(_genicam.AttachStatistics_t_NumChunks_get, _genicam.AttachStatistics_t_NumChunks_set)
    NumAttachedChunks = _swig_property(_genicam.AttachStatistics_t_NumAttachedChunks_get, _genicam.AttachStatistics_t_NumAttachedChunks_set)

    def __init__(self):
        this = _genicam.new_AttachStatistics_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_AttachStatistics_t
    __del__ = lambda self: None
AttachStatistics_t_swigregister = _genicam.AttachStatistics_t_swigregister
AttachStatistics_t_swigregister(AttachStatistics_t)

class ChunkAdapter(object):
    """


    Connects a chunked buffer to a node map.  

    C++ includes: ChunkAdapter.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genicam.delete_ChunkAdapter
    __del__ = lambda self: None

    def AttachNodeMap(self, pNodeMap: 'INodeMap') -> "void":
        """


        Attaches to a node map and retrieves the chunk ports.  

        """
        return _genicam.ChunkAdapter_AttachNodeMap(self, pNodeMap)


    def DetachNodeMap(self) -> "void":
        """


        Detaches from the node map.  

        """
        return _genicam.ChunkAdapter_DetachNodeMap(self)


    def CheckBufferLayout(self, pBuffer: 'uint8_t *') -> "bool":
        """


        Checks if a buffer contains chunks in a known format.  

        Implement that for a specific buffer layout  

        """
        return _genicam.ChunkAdapter_CheckBufferLayout(self, pBuffer)


    def AttachBuffer(self, pBuffer: 'uint8_t *', pAttachStatistics: 'AttachStatistics_t'=None) -> "void":
        """


        Attaches a buffer to the matching ChunkPort.  

        Implement that for a specific buffer layout  

        """
        return _genicam.ChunkAdapter_AttachBuffer(self, pBuffer, pAttachStatistics)


    def DetachBuffer(self) -> "void":
        """


        Detaches a buffer.  

        """
        return _genicam.ChunkAdapter_DetachBuffer(self)


    def UpdateBuffer(self, pBaseAddress: 'uint8_t *') -> "void":
        """


        Updates the base address of the buffer.  

        """
        return _genicam.ChunkAdapter_UpdateBuffer(self, pBaseAddress)


    def ClearCaches(self) -> "void":
        """


        Clears the chunk caches.  

        """
        return _genicam.ChunkAdapter_ClearCaches(self)

ChunkAdapter_swigregister = _genicam.ChunkAdapter_swigregister
ChunkAdapter_swigregister(ChunkAdapter)


CChunkAdapter = ChunkAdapter

class GVCP_CHUNK_TRAILER(object):
    """


    header of a GVCP request packet  

    C++ includes: ChunkAdapterGEV.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ChunkID = _swig_property(_genicam.GVCP_CHUNK_TRAILER_ChunkID_get, _genicam.GVCP_CHUNK_TRAILER_ChunkID_set)
    ChunkLength = _swig_property(_genicam.GVCP_CHUNK_TRAILER_ChunkLength_get, _genicam.GVCP_CHUNK_TRAILER_ChunkLength_set)

    def __init__(self):
        this = _genicam.new_GVCP_CHUNK_TRAILER()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_GVCP_CHUNK_TRAILER
    __del__ = lambda self: None
GVCP_CHUNK_TRAILER_swigregister = _genicam.GVCP_CHUNK_TRAILER_swigregister
GVCP_CHUNK_TRAILER_swigregister(GVCP_CHUNK_TRAILER)

class ChunkAdapterGEV(ChunkAdapter):
    """


    Connects a chunked DCAM buffer to a node map.  

    C++ includes: ChunkAdapterGEV.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: 'INodeMap'=None, MaxChunkCacheSize: 'int64_t'=-1):
        """


        Constructor.  

        """
        this = _genicam.new_ChunkAdapterGEV(pNodeMap, MaxChunkCacheSize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ChunkAdapterGEV
    __del__ = lambda self: None

    def CheckBufferLayout(self, pBuffer: 'uint8_t *') -> "bool":
        """


        Checks if a buffer contains chunks in a known format.  

        """
        return _genicam.ChunkAdapterGEV_CheckBufferLayout(self, pBuffer)


    def AttachBuffer(self, pBuffer: 'uint8_t *', pAttachStatistics: 'AttachStatistics_t'=None) -> "void":
        """


        Attaches a buffer to the matching ChunkPort.  

        """
        return _genicam.ChunkAdapterGEV_AttachBuffer(self, pBuffer, pAttachStatistics)

ChunkAdapterGEV_swigregister = _genicam.ChunkAdapterGEV_swigregister
ChunkAdapterGEV_swigregister(ChunkAdapterGEV)


CChunkAdapterGEV = ChunkAdapterGEV

class U3V_CHUNK_TRAILER(object):
    """


    header of a GVCP request packet  

    C++ includes: ChunkAdapterU3V.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ChunkID = _swig_property(_genicam.U3V_CHUNK_TRAILER_ChunkID_get, _genicam.U3V_CHUNK_TRAILER_ChunkID_set)
    ChunkLength = _swig_property(_genicam.U3V_CHUNK_TRAILER_ChunkLength_get, _genicam.U3V_CHUNK_TRAILER_ChunkLength_set)

    def __init__(self):
        this = _genicam.new_U3V_CHUNK_TRAILER()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_U3V_CHUNK_TRAILER
    __del__ = lambda self: None
U3V_CHUNK_TRAILER_swigregister = _genicam.U3V_CHUNK_TRAILER_swigregister
U3V_CHUNK_TRAILER_swigregister(U3V_CHUNK_TRAILER)

class ChunkAdapterU3V(ChunkAdapter):
    """


    Connects a chunked U3V buffer to a node map.  

    C++ includes: ChunkAdapterU3V.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: 'INodeMap'=None, MaxChunkCacheSize: 'int64_t'=-1):
        """


        Constructor.  

        """
        this = _genicam.new_ChunkAdapterU3V(pNodeMap, MaxChunkCacheSize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ChunkAdapterU3V
    __del__ = lambda self: None

    def CheckBufferLayout(self, pBuffer: 'uint8_t *') -> "bool":
        """


        Checks if a buffer contains chunks in a known format.  

        """
        return _genicam.ChunkAdapterU3V_CheckBufferLayout(self, pBuffer)


    def AttachBuffer(self, pBuffer: 'uint8_t *', pAttachStatistics: 'AttachStatistics_t'=None) -> "void":
        """


        Attaches a buffer to the matching ChunkPort.  

        """
        return _genicam.ChunkAdapterU3V_AttachBuffer(self, pBuffer, pAttachStatistics)

ChunkAdapterU3V_swigregister = _genicam.ChunkAdapterU3V_swigregister
ChunkAdapterU3V_swigregister(ChunkAdapterU3V)


CChunkAdapterU3V = ChunkAdapterU3V

class SingleChunkData_t(object):
    """


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ChunkID = _swig_property(_genicam.SingleChunkData_t_ChunkID_get, _genicam.SingleChunkData_t_ChunkID_set)
    ChunkOffset = _swig_property(_genicam.SingleChunkData_t_ChunkOffset_get, _genicam.SingleChunkData_t_ChunkOffset_set)
    ChunkLength = _swig_property(_genicam.SingleChunkData_t_ChunkLength_get, _genicam.SingleChunkData_t_ChunkLength_set)

    def __init__(self):
        this = _genicam.new_SingleChunkData_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_SingleChunkData_t
    __del__ = lambda self: None
SingleChunkData_t_swigregister = _genicam.SingleChunkData_t_swigregister
SingleChunkData_t_swigregister(SingleChunkData_t)

class SingleChunkDataStr_t(object):
    """


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ChunkID = _swig_property(_genicam.SingleChunkDataStr_t_ChunkID_get, _genicam.SingleChunkDataStr_t_ChunkID_set)
    ChunkOffset = _swig_property(_genicam.SingleChunkDataStr_t_ChunkOffset_get, _genicam.SingleChunkDataStr_t_ChunkOffset_set)
    ChunkLength = _swig_property(_genicam.SingleChunkDataStr_t_ChunkLength_get, _genicam.SingleChunkDataStr_t_ChunkLength_set)

    def __init__(self):
        this = _genicam.new_SingleChunkDataStr_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_SingleChunkDataStr_t
    __del__ = lambda self: None
SingleChunkDataStr_t_swigregister = _genicam.SingleChunkDataStr_t_swigregister
SingleChunkDataStr_t_swigregister(SingleChunkDataStr_t)

class ChunkAdapterGeneric(ChunkAdapter):
    """


    Connects a generic chunked buffer to a node map.  

    C++ includes: ChunkAdapterGeneric.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: 'INodeMap'=None, MaxChunkCacheSize: 'int64_t'=-1):
        """


        Constructor.  

        """
        this = _genicam.new_ChunkAdapterGeneric(pNodeMap, MaxChunkCacheSize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_ChunkAdapterGeneric
    __del__ = lambda self: None

    def CheckBufferLayout(self, pBuffer: 'uint8_t *') -> "bool":
        """


        Checks if a buffer contains chunks in a known format.  

        Implement that for a specific buffer layout  

        """
        return _genicam.ChunkAdapterGeneric_CheckBufferLayout(self, pBuffer)


    def AttachBuffer(self, *args) -> "void":
        """


        """
        return _genicam.ChunkAdapterGeneric_AttachBuffer(self, *args)

ChunkAdapterGeneric_swigregister = _genicam.ChunkAdapterGeneric_swigregister
ChunkAdapterGeneric_swigregister(ChunkAdapterGeneric)


CChunkAdapterGeneric = ChunkAdapterGeneric

class EventPort(IPortConstruct):
    """


    Port attachable to an event.  

    C++ includes: EventPort.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pNode: 'INode'=None):
        """


        Constructor; can attach to a node.  

        """
        this = _genicam.new_EventPort(pNode)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EventPort
    __del__ = lambda self: None

    def GetAccessMode(self) -> "GENAPI_NAMESPACE::EAccessMode":
        """


        Get the access mode of the node.  

        """
        return _genicam.EventPort_GetAccessMode(self)


    def GetPrincipalInterfaceType(self) -> "GENAPI_NAMESPACE::EInterfaceType":
        """


        Get the type of the main interface of a node.  

        """
        return _genicam.EventPort_GetPrincipalInterfaceType(self)


    def Read(self, pBuffer: 'void *', Address: 'int64_t', Length: 'int64_t') -> "void":
        """


        Reads a chunk of bytes from the port.  

        """
        return _genicam.EventPort_Read(self, pBuffer, Address, Length)


    def Write(self, pBuffer: 'void const *', Address: 'int64_t', Length: 'int64_t') -> "void":
        """


        Writes a chunk of bytes to the port.  

        """
        return _genicam.EventPort_Write(self, pBuffer, Address, Length)


    def SetPortImpl(self, pPort: 'IPort') -> "void":
        """


        Called from the port node to give the chunk port a pointer to itself.  

        """
        return _genicam.EventPort_SetPortImpl(self, pPort)


    def GetSwapEndianess(self) -> "GENAPI_NAMESPACE::EYesNo":
        """


        Determines if the port adapter must perform an endianess swap.  

        """
        return _genicam.EventPort_GetSwapEndianess(self)


    def InvalidateNode(self) -> "void":
        """


        """
        return _genicam.EventPort_InvalidateNode(self)


    def AttachNode(self, pNode: 'INode') -> "bool":
        """


        Attaches to the Node.  

        """
        return _genicam.EventPort_AttachNode(self, pNode)


    def DetachNode(self) -> "void":
        """


        Detaches from the Node.  

        """
        return _genicam.EventPort_DetachNode(self)


    def GetEventIDLength(self) -> "int":
        """


        Gets the EventID length.  

        """
        return _genicam.EventPort_GetEventIDLength(self)


    def CheckEventID(self, *args) -> "bool":
        """


        Checks if a EventID matches, version using uint64_t ID representation.  

        """
        return _genicam.EventPort_CheckEventID(self, *args)


    def AttachEvent(self, pBaseAddress: 'uint8_t *', Length: 'int64_t') -> "void":
        """


        Attaches the an Event to the EventPort.  

        """
        return _genicam.EventPort_AttachEvent(self, pBaseAddress, Length)


    def DetachEvent(self) -> "void":
        """


        Detaches the Event from the EventPort.  

        """
        return _genicam.EventPort_DetachEvent(self)

EventPort_swigregister = _genicam.EventPort_swigregister
EventPort_swigregister(EventPort)


CEventPort = EventPort

class EventAdapter(object):
    """


    Delivers Events to ports.  

    C++ includes: EventAdapter.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genicam.delete_EventAdapter
    __del__ = lambda self: None

    def AttachNodeMap(self, pNodeMap: 'INodeMap') -> "void":
        """


        Attaches to a node map and retrieves the chunk ports.  

        """
        return _genicam.EventAdapter_AttachNodeMap(self, pNodeMap)


    def DetachNodeMap(self) -> "void":
        """


        Detaches from the node emap.  

        """
        return _genicam.EventAdapter_DetachNodeMap(self)


    def DeliverMessage(self, msg: 'uint8_t const []') -> "void":
        """


        Deliver message.  

        """
        return _genicam.EventAdapter_DeliverMessage(self, msg)

EventAdapter_swigregister = _genicam.EventAdapter_swigregister
EventAdapter_swigregister(EventAdapter)


CEventAdapter = EventAdapter

class EventAdapterGEV(EventAdapter):
    """


    Connects a GigE Event to a node map.  

    C++ includes: EventAdapterGEV.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: 'INodeMap'=None):
        """


        Constructor.  

        """
        this = _genicam.new_EventAdapterGEV(pNodeMap)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EventAdapterGEV
    __del__ = lambda self: None

    def DeliverMessage(self, msg: 'uint8_t const []') -> "void":
        """


        Deliver message.  

        """
        return _genicam.EventAdapterGEV_DeliverMessage(self, msg)

EventAdapterGEV_swigregister = _genicam.EventAdapterGEV_swigregister
EventAdapterGEV_swigregister(EventAdapterGEV)
COMMAND_MAGIC = cvar.COMMAND_MAGIC


CEventAdapterGEV = EventAdapterGEV

class EventAdapterU3V(EventAdapter):
    """


    Connects a U3V Event to a node map.  

    C++ includes: EventAdapterU3V.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: 'INodeMap'=None):
        """


        Constructor.  

        """
        this = _genicam.new_EventAdapterU3V(pNodeMap)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EventAdapterU3V
    __del__ = lambda self: None

    def DeliverMessage(self, msg: 'uint8_t const []') -> "void":
        """


        Deliver message.  

        """
        return _genicam.EventAdapterU3V_DeliverMessage(self, msg)

EventAdapterU3V_swigregister = _genicam.EventAdapterU3V_swigregister
EventAdapterU3V_swigregister(EventAdapterU3V)
U3V_EVENT_PREFIX = cvar.U3V_EVENT_PREFIX
GENCP_EVENT_CMD_ID = cvar.GENCP_EVENT_CMD_ID
GENCP_COMMAND_HEADER_SIZE = cvar.GENCP_COMMAND_HEADER_SIZE
GENCP_EVENT_BASIC_SIZE = cvar.GENCP_EVENT_BASIC_SIZE


CEventAdapterU3V = EventAdapterU3V

class EventAdapterGeneric(EventAdapter):
    """


    Connects a generic event to a node map.  

    C++ includes: EventAdapterGeneric.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: 'INodeMap'=None):
        """


        Constructor.  

        """
        this = _genicam.new_EventAdapterGeneric(pNodeMap)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genicam.delete_EventAdapterGeneric
    __del__ = lambda self: None

    def DeliverMessage(self, *args) -> "void":
        """


        """
        return _genicam.EventAdapterGeneric_DeliverMessage(self, *args)

EventAdapterGeneric_swigregister = _genicam.EventAdapterGeneric_swigregister
EventAdapterGeneric_swigregister(EventAdapterGeneric)


CEventAdapterGeneric = EventAdapterGeneric

class FileProtocolAdapter(object):
    """


    Adapter between the std::iostreambuf and the SFNC Features representing the
    device filesystem.  

    Adapter between the std::iostreambuf and the SFNC Features representing the
    device filesystem The adapter assumes, that the features provide stdio
    fileaccess compatible semantic  

    C++ includes: Filestream.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        Constructor.  

        """
        this = _genicam.new_FileProtocolAdapter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def attach(self, pInterface: 'INodeMap') -> "bool":
        """


        attach file protocol adapter to nodemap  

        Parameters
        ----------
        * `pInterface` :  
            NodeMap of the device to which the FileProtocolAdapter is attached  

        Returns
        -------
        true if attach was successful, false if not  

        """
        return _genicam.FileProtocolAdapter_attach(self, pInterface)


    def openFile(self, pFileName: 'char const *', mode: 'char const *') -> "bool":
        """


        open a file on the device  

        Parameters
        ----------
        * `pFileName` :  
            filename of the file to open. The filename must exist in the Enumeration
            FileSelector  
        * `mode` :  
            mode to open the file. The mode must exist in the Enumeration FileOpenMode  

        Returns
        -------
        true on success, false on error  

        """
        return _genicam.FileProtocolAdapter_openFile(self, pFileName, mode)


    def closeFile(self, pFileName: 'char const *') -> "bool":
        """


        close a file on the device  

        Parameters
        ----------
        * `pFileName` :  
            filename of the file to open. The filename must exist in the Enumeration
            FileSelector  

        Returns
        -------
        true on success, false on error  

        """
        return _genicam.FileProtocolAdapter_closeFile(self, pFileName)


    def write(self, pBuffer: 'char const *', offs: 'int64_t', pFileName: 'char const *') -> "std::streamsize":
        """


        writes data into a file.  

        Parameters
        ----------
        * `buf` :  
            source buffer  
        * `offs` :  
            offset into the device file  
        * `len` :  
            count of bytes to write  
        * `pFileName` :  
            filename of the file to write into The filename must exist in the
            Enumeration FileSelector  

        Returns
        -------
        count of bytes written  

        """
        return _genicam.FileProtocolAdapter_write(self, pBuffer, offs, pFileName)


    def read(self, pBuffer: 'char *', offs: 'int64_t', pFileName: 'char const *') -> "std::streamsize":
        """


        read data from the device into a buffer  

        Parameters
        ----------
        * `buf` :  
            target buffer  
        * `offs` :  
            offset in the device file to read from  
        * `len` :  
            count of bytes to read  
        * `pFileName` :  
            filename of the file to write into The filename must exist in the
            Enumeration FileSelector  

        Returns
        -------
        count of bytes successfully read  

        """
        return _genicam.FileProtocolAdapter_read(self, pBuffer, offs, pFileName)


    def getBufSize(self, pFileName: 'char const *', mode: 'char const *') -> "int64_t":
        """


        fetch max FileAccessBuffer length for a file  

        Parameters
        ----------
        * `pFileName` :  
            filename of the file to open. The filename must exist in the Enumeration
            FileSelector  
        * `mode` :  
            mode to open the file. The mode must exist in the Enunmeration FileOpenMode  

        Returns
        -------
        max length of FileAccessBuffer in the given mode on the given file  

        """
        return _genicam.FileProtocolAdapter_getBufSize(self, pFileName, mode)


    def deleteFile(self, pFileName: 'char const *') -> "bool":
        """


        Delete the content of the file.  

        Parameters
        ----------
        * `pFileName` :  
            filename of the file to open. The filename must exist in the Enumeration
            FileSelector  

        Returns
        -------
        true on success, false on error  

        """
        return _genicam.FileProtocolAdapter_deleteFile(self, pFileName)

    __swig_destroy__ = _genicam.delete_FileProtocolAdapter
    __del__ = lambda self: None
FileProtocolAdapter_swigregister = _genicam.FileProtocolAdapter_swigregister
FileProtocolAdapter_swigregister(FileProtocolAdapter)


class FileAccess(object):
    def __init__(self, read_bufsize = 4096):
        if read_bufsize == 0:
            raise IOError("invalid read_bufsize")

        self.isopen   = False
        self.filename = ""
        self.mode     = ""
        self.fpa      = FileProtocolAdapter()
        self.fpa_bufsize  = 0
        self.fpos     = 0
        self.read_bufsize = read_bufsize

    def open(self, nodemap, filename, openmode):
        self.fpa.attach(nodemap)
        self.filename = filename
        self.fpa.openFile(filename,openmode)
        self.fpa_bufsize = self.fpa.getBufSize(filename, openmode)
        self.fpos = 0
        self.isopen = True

    def close(self):
        self.isopen = False
        self.fpa.closeFile(self.filename)

    def _read(self, size):
        assert(self.isopen)
        read_len, data  = self.fpa.read(size, self.fpos, self.filename)
        data = data[:read_len]
        self.fpos += read_len
        return data

    def read(self, size = -1):
        assert(self.isopen)
        if size < 0:
            buf = b""
            while True:
                data  = self._read(self.read_bufsize)
                buf += data
                if len(data) < self.read_bufsize:
                    return buf

        else:
            data  = self._read(size)
            return data


    def write(self,data):
        assert(self.isopen)
        ret = self.fpa.write(data, self.fpos, self.filename)
        self.fpos += len(data)
        return ret




__version__ = '1.6.0+pylon6.1.0'
